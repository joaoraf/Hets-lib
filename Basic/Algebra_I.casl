library Basic/Algebra_I
version 0.4
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% copyright 5.5.00

from Basic/RelationsAndOrders version 0.4 get TotalOrder, ExtTotalOrder,
PreOrder, EquivalenceRelation

from Basic/PreNumbers version 0.4 get PreNat, PreInt, PreRat

spec
     SemiGroup =
     sort
          Elem
     op
          __ * __: Elem * Elem -> Elem, assoc
end

view
     SemiGroup_in_Totalorder_max  :
     SemiGroup to ExtTotalOrder[TotalOrder] =
op
     __*__ |-> max
end

view
     SemiGroup_in_Totalorder_min  :
     SemiGroup to ExtTotalOrder[TotalOrder] =
op
     __*__ |-> min
end

spec
     Monoid =
     SemiGroup
then
     ops
           1:      Elem;
           __ * __:Elem * Elem -> Elem, unit 1
end

spec
     ExtMonoid  [Monoid] given PreNat =
%def
     op
          __ ^ __: Elem * Nat -> Elem
     %prec {__*__} < {__^ __}
     vars
          x: Elem; n: Nat
     .
          %[ExtMonoid_power_0] x^0 = 1
     .
          %[ExtMonoid_power_suc] x^ suc(n)=x*x^ n
then
     %implies
     vars
          x: Elem; n,m: Nat
     .
          %[ExtMonoid_power_add] x^ (n+m)=x^ n * x^ m
     .
          %[ExtMonoid_power_mult] x^ (n*m)=(x^ n)^ m
end

spec
     CommutativeMonoid =
     Monoid
then
     op  __ * __: Elem * Elem -> Elem, comm
end

view
     CommutativeMonoid_in_PreNat_Add:
     CommutativeMonoid to PreNat
=
     sort
          Elem |-> Nat,
     ops
           1 |-> 0,
           __*__ |-> __+__
end

view
     CommutativeMonoid_in_PreNat_Mult:
     CommutativeMonoid to PreNat
=
     sort
          Elem |-> Nat
end

view
     CommutativeMonoid_in_PreInt_Mult:
     CommutativeMonoid to PreInt
=
     sort
          Elem |-> Int
end

spec
     ExtCommutativeMonoid  [CommutativeMonoid]
     given PreNat =
%def
     ExtMonoid [Monoid]
then
     %implies
     vars
          x,y: Elem; n: Nat
     .
          %[CommMon_power_basemult] x^ n * y^ n=(x*y)^ n
end

spec
     Group =
     Monoid
then
     var
          x:Elem
     .
          %[Group_Leftinverse] exists x': Elem . x' * x = 1
then
     %implies
     var
          x:Elem
     .
          %[Group_Inverse] exists x': Elem . x' * x = 1 /\ x*x'=1
end


spec
     ExtGroup  [Group ] given PreInt =
%def
     ops
           inv: Elem -> Elem;
           __ / __: Elem * Elem -> Elem;
     vars
          x,y: Elem
     .
          %[ExtGroup_inverse] inv(x) * x = 1
     .
          %[ExtGroup_div_def] x / y = x * inv(y)
and
     ExtMonoid[Monoid]
then
     %def
     op
          __^ __: Elem * Int -> Elem
     vars
          x: Elem; p: Pos
     .
          %[ExtGroup_power_neg] x^ (-p)=inv(x^ p)
then
     %implies
     vars
          x,y: Elem; n,m: Int
     .
          %[ExtGroup_power_add] x^ (n+m)=x^ n * x^ m
     .
          %[ExtGroup_power_mult] x^ (n*m)=(x^ n)^ m
     .
          %[inv_inv] inv(inv(x))=x
     .
          %[inv_1] inv(1)=1
     .
          %[inv_prod] inv(x*y)=inv(y)*inv(x)
end

spec
     AbelianGroup =
     Group with op 1 |-> 0,__ * __ |-> __ + __
then
     op
           __ + __: Elem * Elem -> Elem,
                    comm
end

view
     AbelianGroup_in_PreInt_Add:
     AbelianGroup to PreInt
=
     sort
          Elem |-> Int
end

spec ExtAbelianGroup  [AbelianGroup] given PreInt =
%def
ExtGroup[AbelianGroup fit 1:Elem|->0:Elem,
			  __*__:Elem*Elem->Elem|-> __+__:Elem*Elem->Elem] 
%% restored LS 1/9/00. Qualifications due to "given PreInt" in ExtGroup!
with 
  ops 
%%      1:Elem |-> 0,
%%     __*__:Elem*Elem->Elem |-> __+__,
      inv        |-> -__,
      __/__      |-> __-__,
      __^__      |-> __*__

then
     op
          __ * __: Int × Elem -> Elem
     vars
          n:Int; x:Elem
     .
          n * x = x * n
then
     %implies
     vars
          x,y: Elem; n: Int
     .
          %[AbGroup_distr1] x * n + y * n=(x+y)* n
     .
          %[AbGroup_distr1] n * x + n * y=n*(x+y)
end

spec
     MonoidAction  [Monoid] =
     sort
          Space
     op
          __*__: Elem * Space -> Space
     vars
          x: Space; a,b: Elem
     .
          %[MonoidAction_unit] 1*x=x
     .
          %[MonoidAction_assoc] (a*b)*x = a*(b*x)
end

spec
     ExtMonoidAction  [MonoidAction [Monoid]] given PreNat =
%def
     ExtMonoid[Monoid]
end

spec
     GroupAction  [Group] =
     MonoidAction[Monoid]
end

spec
     ExtGroupAction  [GroupAction [Group]] given PreInt =
%def
     ExtMonoidAction[MonoidAction [Monoid]]
end

spec
     Ring =
     AbelianGroup with sort Elem, ops 0, __ + __
and
     Monoid with ops 1, __*__
then
     %prec { __ + __ } < { __ * __ }
     vars
          x,y,z:Elem
     .
          %[Ring_distr1] (x+y)*z = (x * z) + (y * z)
     .
          %[Ring_distr2] z * ( x + y ) = (z * x) + (z * y)
end

spec
     ExtRing  [Ring ] given PreInt =
%def
     ExtAbelianGroup [AbelianGroup]
     with ops -__ , __ - __, __*__
and
     ExtMonoid[Monoid]
     with op  __ ^ __
and
     preds
          isIrred, isUnit: Elem
     sorts
           RUnit[Elem] = { x: Elem . isUnit(x) };
           Irred[Elem] = { x: Elem . isIrred(x) };
     vars
          x,y: Elem
     .
          %[isUnit_def] isUnit(x) <=> exists y: Elem . x * y = 1 /\ y * x =
          1
     .
          %[isIrred_def]
           isIrred(x) <=> ( not isUnit(x) /\
                          forall y, z: Elem . (x = y * z => (isUnit(z) \/
                          isUnit(z) ) ) )
then
     %prec {__ - __} < {__ * __ }
end

spec
     CommutativeRing =
     Ring
then
     op __*__: Elem * Elem -> Elem, comm
end

spec
     ExtCommutativeRing  [CommutativeRing] given PreInt =
%def
     ExtRing[Ring]
then
     preds
           hasNoZeroDivisors: ();
           __ divides __ :    Elem * Elem;
           associated:        Elem * Elem
     vars
          x,y: Elem
     .
          %[hasNoZeroDivisors_def]
          hasNoZeroDivisors <=> forall x,y: Elem . (x * y = 0 => x=0 \/ y=0)
     .
          %[divides_def] x divides y <=> exists z: Elem. x * z =y
     .
          %[associated_def] associated(x,y) <=> exists u:RUnit[Elem]. x=u*y
then
     %implies
     vars
          x,y:Elem
     .
          associated(x,y) <=> (x divides y /\ y divides x)
end

view
     PreOrder_in_ExtCRing  [CommutativeRing]
     given PreInt:
     PreOrder to
     ExtCommutativeRing[CommutativeRing] =
     pred
          __ <= __ |-> __ divides __
end

view
     EqRel_in_ExtCRing  [CommutativeRing] given PreInt:
     EquivalenceRelation to
     ExtCommutativeRing[CommutativeRing]=
     pred
          __ ~ __ |-> associated
end

spec
     IntegralDomain =
     CommutativeRing
then
     axioms
      %[zeroNotEqualOne] not (1 = 0);
      %[noZeroDivisors] forall x,y: Elem . x * y = 0 => x=0 \/ y=0
end

spec
     ExtIntegralDomain  [IntegralDomain] given PreInt =
%def
     ExtCommutativeRing [CommutativeRing]
end

spec
     EuclidianRing =
     IntegralDomain and {PreNat reveal pred  __<__ }
then
     op
          delta: Elem -> Nat
     vars
          a,b: Elem
     .
          %[degree_function_def]
           exists q,r : Elem . a = q * b + r /\
                               (r = 0 \/ delta(r) < delta(b) ) if ( not b=0
                               )
end

view
     EuclidianRing_in_PreInt :
     EuclidianRing to PreInt
=
     sort
          Elem |-> Int,
     op
          delta |-> abs
end

spec
     ExtEuclidianRing  [EuclidianRing] given PreInt=
%def
     ExtIntegralDomain [IntegralDomain]
end

spec
     ConstructField =
     CommutativeRing
then
     axiom
          not 0 = 1
     sort
          NonZeroElem = { x: Elem . not x = 0 }
then
     closed
     {
          Group with
           sort Elem |-> NonZeroElem,
           ops 1,__*__
     }
end

%% an obvious view which helps to write the specification ExtField:

view
     AbelianGroup_in_ConstructField :
     AbelianGroup to ConstructField
=
     sort
          Elem |-> NonZeroElem,
     ops
          0 |-> 1,__+__ |-> __*__
end

spec
     Field =
     ConstructField hide sort NonZeroElem
end

view
     Field_in_PreRat : Field to {PreRat hide -__}
=
     sort Elem |-> Rat
end

spec
     ExtField  [Field] given PreInt=
%def
     ExtRing [Ring]
then
closed
     {
	ExtAbelianGroup[view AbelianGroup_in_ConstructField]
	with NonZeroElem|->NonZero[Elem]
}
then
     %prec {__+ __, __ - __ } < { __ / __ }
then
     op
           __ / __: Elem × Elem ->? Elem;
           __ / __: Elem × NonZero[Elem] -> Elem
     vars
          x:Elem; n: NonZero[Elem]
     .
          %[ExtField_div_def1] 0:Elem/n=0:Elem
     .
          %[ExtField_div_def2] not def x/0:Elem
then
     %implies
     vars
          x,y:Elem
     .
          %[ExtField_div_dom] def x/y <=> not y=0
end



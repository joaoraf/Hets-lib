library Basic/Algebra_I
version 0.5
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% copyright 5.5.00

from Basic/RelationsAndOrders version 0.5 get TotalOrder, ExtTotalOrder,
PreOrder, EquivalenceRelation

from Basic/PreNumbers version 0.5 get PreNat, PreInt, PreRat, SigPreNumbers

spec 
     BinAlg =
     sort
          Elem
     op
          __ * __: Elem * Elem -> Elem
end

spec
     SemiGroup =
     BinAlg
then
     op
          __ * __: Elem * Elem -> Elem, assoc
end

view
     SemiGroup_in_Totalorder_max  :
     SemiGroup to ExtTotalOrder[TotalOrder] =
op
     __ * __ |-> max
end

view
     SemiGroup_in_Totalorder_min  :
     SemiGroup to ExtTotalOrder[TotalOrder] =
op
     __*__ |-> min
end

spec
     SigPowerBinAlg [sort Exponent] =
     BinAlg
then	
     op __ ^ __: Elem * Exponent -> Elem
     %prec {__*__} < {__^ __}
end

spec 
     PowerTheorems [sort Exponent;
		    ops __ + __, __ * __: Exponent * Exponent -> Exponent] =
     SigPowerBinAlg [sort Exponent]
then
     vars x: Elem; n,m: Exponent
     .    %[Power_add] x ^ (n + m)=x ^ n * x ^ m
     .    %[Power_mult] x ^ (n * m)=(x ^ n) ^ m
end

	
spec
     ExtSemiGroup[SemiGroup] given PreNat =
%def
     SigPowerBinAlg [sort Pos]
then
     vars
          x: Elem; n: Pos
     .
          %[SemiGroup_power_1] x ^ 1 = x
     .
          %[SemiGroup_power_suc] x ^ suc(n) = x * x ^ n
then
     %implies
     PowerTheorems [PreNat fit sort Exponent |-> Pos]
end

spec 
     CommutativeSemiGroup =
     SemiGroup
then
     op __*__: Elem * Elem -> Elem, comm
end

spec
     PowerTheoremsComm [sort Exponent;
		ops __ + __, __ * __: Exponent * Exponent -> Exponent] =
     SigPowerBinAlg [sort Exponent]
then
     vars x,y: Elem; n: Exponent
     .
          %[Power_basemult] x^ n * y^ n=(x*y)^ n
end

spec 
     ExtCommutativeSemiGroup [CommutativeSemiGroup] given PreNat =
%def
     ExtSemiGroup [SemiGroup]
then
     %implies
     PowerTheoremsComm [PreNat fit sort Exponent |-> Pos]
end

spec
     Monoid =
     SemiGroup
then
     ops
           e:      Elem;
           __ * __:Elem * Elem -> Elem, unit e
end

spec
     ExtMonoid  [Monoid] given PreNat =
%def
     ExtSemiGroup [SemiGroup]
then 
     SigPowerBinAlg [sort Nat]
then
     var
          x: Elem
     .
          %[Monoid_power_0] x ^ 0 = e
then
     %implies
     {vars
          x: Elem; n,m: Nat
     .    
	  %[Monoid_power_unit] e ^ n = e
     then
	  PowerTheorems [PreNat fit sort Exponent |-> Nat] 
     }
end

spec
     CommutativeMonoid =
     Monoid
and
     CommutativeSemiGroup
end

view
     CommutativeMonoid_in_PreNat_Add:
     CommutativeMonoid to PreNat
=
     sort
          Elem |-> Nat,
     ops
           e |-> 0,
           __ * __ |-> __ + __
end

view
     CommutativeMonoid_in_PreNat_Mult:
     CommutativeMonoid to PreNat
=
     sort
          Elem |-> Nat,
     ops
	  e |-> 1,
	  __ * __ |-> __ * __
end

view
     CommutativeMonoid_in_PreInt_Mult:
     CommutativeMonoid to PreInt
=
     sort
          Elem |-> Int,
     ops
	  e |-> 1,
	  __ * __ |-> __ * __
end

spec
     ExtCommutativeMonoid  [CommutativeMonoid]
     given PreNat =
%def
     ExtMonoid [Monoid]
and
     ExtCommutativeSemiGroup [CommutativeSemiGroup]
then
     %implies
     PowerTheoremsComm [PreNat fit sort Exponent |-> Nat] 
end

spec
     Group =
     Monoid
then
     var x: Elem
     .
	exists x': Elem . x' * x = e
end


spec
     ExtGroup [Group] given PreInt =
%def
     ExtMonoid [Monoid] 
then
     ops
           inv: Elem -> Elem;
           __ / __: Elem * Elem -> Elem;
     vars
          x,y: Elem
     .
          %[Group_inverse_def] inv(x) * x = e
     .
          %[Group_div_def] x / y = x * inv(y)
then
     SigPowerBinAlg [sort Int]
then
     vars
          x: Elem; p: Pos
     .
          %[ExtGroup_power_neg] x^ minus(p)=inv(x ^ p)
then
     %implies
     {vars x,y,z: Elem; n,m: Int
     .
	  %[Group_right_inv] x * inv(x) = e
     .
	  %[Group_left_cancellation] x = y if z * x = z * y
     .
	  %[Group_right_cancellation] x = y if x * z = y * z
     .
          %[Group_inv_inv] inv(inv(x))=x
     .
          %[Group_inv_e] inv(e)=e
     .
          %[Group_inv_prod] inv(x*y)=inv(y)*inv(x)
     then
	  PowerTheorems [PreInt fit sort Exponent |-> Int]
     }
end

spec
     AbelianGroup =
	Group 
and
	CommutativeMonoid
end

view
     AbelianGroup_in_PreInt_Add:
     AbelianGroup to PreInt
=
     sort
          Elem |-> Int,
     ops
	  __ * __ |-> __ + __,
	  e	  |-> 0
end

spec ExtAbelianGroup  [AbelianGroup] given PreInt =
%def
     ExtGroup[AbelianGroup]
and
     ExtCommutativeMonoid[AbelianGroup]
end

spec
     MonoidAction [Monoid] =
     sort
          Space
     op
          __*__: Elem * Space -> Space
     vars
          x: Space; a,b: Elem
     .
          %[MonoidAction_unit] e * x = x
     .
          %[MonoidAction_assoc] (a * b) * x = a * (b * x)
end

spec
     ExtMonoidAction [MonoidAction [Monoid]] given PreNat =
%def
     ExtMonoid [Monoid]
then 
     pred connected: Space * Space
     var x,y: Space
     .
	  %[Action_connected_def] connected(x,y) <=> 
		exists a: Elem . a * x = y
end

view PreOrder_in_ExtMonoidAction:
     PreOrder to ExtMonoidAction [MonoidAction [Monoid]] =
     sort Elem |-> Space,
     pred __ <= __ |-> connected
end

spec
     GroupAction [Group] =
     MonoidAction [Group]
end

spec
     ExtGroupAction [GroupAction [Group]] given PreInt =
%def
     ExtMonoidAction [GroupAction [Group]]
and
     ExtGroup [Group]
then
     %implies
     var a,b:Elem; x,y: Space
     .
	%[GroupAct_inj] x = y if a * x = a * y
     .
	%[GroupAct_surj] exists z: Space . a * z = x

end

view EqRel_in_ExtGroupAction:
     EquivalenceRelation to ExtGroupAction [GroupAction [Group]] =
     sort Elem |-> Space,
     pred __ ~ __ |-> connected
end

spec
     Ring =
     AbelianGroup with sort Elem, 
		       ops __ * __ |-> __ + __,
			   e	   |-> 0
and
     Monoid with ops e, __*__
then
     %prec { __ + __ } < { __ * __ }
     vars
          x,y,z:Elem
     .
          %[Ring_distr1] (x + y) * z = (x * z) + (y * z)
     .
          %[Ring_distr2] z * ( x + y ) = (z * x) + (z * y)
end

view AbelianGroup_in_Ring_add:
     AbelianGroup to Ring =
     ops e |-> 0,
	 __ * __ |-> __ + __
end

spec
     ExtRing  [Ring ] given PreInt =
%def
     ExtAbelianGroup [view AbelianGroup_in_Ring_add]
     with ops   inv     |-> -__,
		__ / __ |-> __ - __,
		__ ^ __ |-> __ times __
and
     ExtMonoid[Monoid]
     with op  __ ^ __
and
     preds
          isIrred, isUnit: Elem
     sorts
           NonZero[Elem] = { x: Elem . not x = 0 };
           RUnit[Elem] = { x: Elem . isUnit(x) };
           Irred[Elem] = { x: Elem . isIrred(x) }
     vars
          x,y: Elem
     .
          %[Ring_isUnit_def] isUnit(x) <=> 
		exists y: Elem . x * y = e /\ y * x = e
     .
          %[Ring_isIrred_def]
           isIrred(x) <=> (not isUnit(x) /\
                          forall y, z: Elem . (x = y * z => (isUnit(z) \/
                          isUnit(z))))
then
     %prec {-__, __ - __} < {__ * __ }
then %def
     ops 
	e: RUnit[Elem];
        -__: RUnit[Elem] -> RUnit[Elem];
	__ * __: RUnit[Elem] * RUnit[Elem] -> RUnit[Elem]
end

spec
     CommutativeRing =
     Ring
and
     CommutativeMonoid with ops e, __ * __     
end

spec
     ExtCommutativeRing  [CommutativeRing] given PreInt =
%def
     ExtRing[Ring]
then
     preds
           hasNoZeroDivisors: ();
           __ divides __ :    Elem * Elem;
           associated:        Elem * Elem
     vars
          x,y: Elem
     .
          %[hasNoZeroDivisors_def]
          hasNoZeroDivisors <=> forall x,y: Elem . (x * y = 0 => x=0 \/ y=0)
     .
          %[divides_def] x divides y <=> exists z: Elem. x * z = y
     .
          %[associated_def] associated(x,y) <=> exists u:RUnit[Elem]. x=u*y
then
     %implies
     vars
          x,y:Elem
     .
          associated(x,y) <=> (x divides y /\ y divides x)
end

view
     PreOrder_in_ExtCRing  [CommutativeRing]
     given PreInt:
     PreOrder to
     ExtCommutativeRing[CommutativeRing] =
     pred
          __ <= __ |-> __ divides __
end

view
     EqRel_in_ExtCRing  [CommutativeRing] given PreInt:
     EquivalenceRelation to
     ExtCommutativeRing[CommutativeRing]=
     pred
          __ ~ __ |-> associated
end

spec
     IntegralDomain =
     CommutativeRing
then
     axioms
      %[zeroNotEqualOne] not (e = 0);
      %[noZeroDivisors] forall x,y: Elem . ( x * y = 0 => 
				( x = 0 \/ y = 0 ) )
end

spec
     ExtIntegralDomain  [IntegralDomain] given PreInt =
%def
     ExtCommutativeRing [CommutativeRing]
then
     op __ * __:  NonZero[Elem] × NonZero[Elem] -> NonZero[Elem]
then
     %implies
     axiom hasNoZeroDivisors
end

spec
     EuclidianRing =
     IntegralDomain and {PreNat reveal pred  __<__ }
then
     op
          delta: Elem ->? Nat
     vars
          a,b: Elem
     .
          %[ER_delta_dom] def delta(a) if not a = 0
     .
          %[ER_div_with_remainder]
           (exists q,r : Elem . a = q * b + r /\
                               (r = 0 \/ delta(r) < delta(b) )) 
		if not b = 0 
end

view
     EuclidianRing_in_PreInt :
     EuclidianRing to PreInt
=
     sorts
          Elem |-> Int,
     ops
          delta |-> abs: Int ->? Nat,
	  e |-> 1
	  
end

spec
     ExtEuclidianRing  [EuclidianRing] given PreInt=
%def
     ExtIntegralDomain [IntegralDomain]
end

spec
     ConstructField =
     CommutativeRing
then
     axiom
          not e = 0
     sort
          NonZeroElem = { x: Elem . not x = 0 }
then
     closed
     {
          Group with
           sort Elem |-> NonZeroElem,
           ops e, __*__
     }
end

%% an obvious view which helps to write the specification ExtField:

view
     AbelianGroup_in_ConstructField :
     AbelianGroup to ConstructField 
=
     sort
          Elem |-> NonZeroElem
end

spec
     Field =
     ConstructField hide sort NonZeroElem
end

view
     Field_in_PreRat : Field to PreRat
=
     sort Elem |-> Rat,
     op e |-> 1
end

spec
     ExtField  [Field] given PreInt=
%def 
     ExtRing [Ring]
then
closed
     {
	ExtAbelianGroup[view AbelianGroup_in_ConstructField]
	with sort NonZeroElem|->NonZero[Elem],
	     ops inv, __ / __, __ ^ __}
then
     %prec {__ + __, __ - __, -__} < {__ / __}
then
     op
           __ / __: Elem × Elem ->? Elem;
           __ / __: Elem × NonZero[Elem] -> Elem
     vars
          x:Elem; n: NonZero[Elem]
     .
          %[ExtField_div_def1] 0/n=0
     .
          %[ExtField_div_def2] not def x/0
then
     %implies
     vars
          x,y:Elem
     .
          %[ExtField_div_dom] def x/y <=> not y=0
end





spec AbelianGroup =
sort
  Elem
ops
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
end

%[ view AbelianGroup_in_ConstructField =
sorts 
Elem |-> NonZeroElem
end ]%

%[ view AbelianGroup_in_Int_Add =
sorts 
Elem |-> Int
ops 
__*__ |-> __+__:Elem*Elem->Elem, e |-> 0:Elem
end ]%

%[ view AbelianGroup_in_Ring_add =

ops 
__*__ |-> __+__:Elem*Elem->Elem, e |-> 0:Elem
end ]%

spec BinAlg =
sort
  Elem
op
  __*__ : Elem*Elem->Elem

end

spec CommutativeMonoid =
sort
  Elem
ops
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
end

%[ view CommutativeMonoid_in_Int_Mult =
sorts 
Elem |-> Int
ops 
__*__ |-> __*__:Elem*Elem->Elem, e |-> 1:Elem
end ]%

%[ view CommutativeMonoid_in_Nat_Add =
sorts 
Elem |-> Nat
ops 
__*__ |-> __+__:Elem*Elem->Elem, e |-> 0:Elem
end ]%

%[ view CommutativeMonoid_in_Nat_Mult =
sorts 
Elem |-> Nat
ops 
__*__ |-> __*__:Elem*Elem->Elem, e |-> 1:Elem
end ]%

spec CommutativeRing =
sort
  Elem
ops
  0 : Elem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
end

spec CommutativeSemiGroup =
sort
  Elem
op
  __*__ : Elem*Elem->Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
end

%[ view CommutativeSemiGroup_in_ExtTotalOrder_max =

ops 
__*__ |-> max:Elem*Elem->Elem
end ]%

%[ view CommutativeSemiGroup_in_ExtTotalorder_min =

ops 
__*__ |-> min:Elem*Elem->Elem
end ]%

%[ view CommutativeSemiGroup_in_RichTotalOrder =

ops 
__*__ |-> min:Elem*Elem->Elem
end ]%

spec ConstructField =
sorts
  NonZeroElem < Elem;
  NonZeroElem
ops
  0 : Elem;
  __*__ : NonZeroElem*NonZeroElem->NonZeroElem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  e : NonZeroElem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
  . not e = 0  
forall x : Elem
  . x in NonZeroElem <=> not x = 0  
forall x : NonZeroElem;y : NonZeroElem;z : NonZeroElem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : NonZeroElem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : NonZeroElem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : NonZeroElem
  . exists x' : NonZeroElem . ( x' * x ) = e  
end

%[ view EqRel_in_ExtCRing =

preds 
__~__ |-> associated:Elem*Elem
end ]%

%[ view EqRel_in_ExtGroupAction =
sorts 
Elem |-> Space
preds 
__~__ |-> connected:Elem*Elem
end ]%

%[ view EqRel_in_RichCRing =

preds 
__~__ |-> associated:Elem*Elem
end ]%

%[ view EqRel_in_RichGroupAction =
sorts 
Elem |-> Space
preds 
__~__ |-> connected:Elem*Elem
end ]%

spec EquivalenceRelation =
sort
  Elem
pred
  __~__ : Elem*Elem
forall x : Elem
  . ( x ~ x )   %(refl)%
forall x : Elem;y : Elem
  . ( y ~ x ) => ( x ~ y )   %(sym)%
forall x : Elem;y : Elem;z : Elem
  . ( x ~ y ) /\ ( y ~ z ) => ( x ~ z )   %(trans)%
end

spec EuclidianRing =
sorts
  Elem;
  Nat
ops
  0 : Elem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  delta : Elem->?Nat;
  e : Elem
pred
  __<__ : Nat*Nat
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem
  . ( x * y ) = 0 => x = 0 \/ y = 0   %(noZeroDiv)%
forall x : Elem;y : Elem
  . not e = 0   %(zeroNeqOne)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall a : Elem;b : Elem
  . not a = 0 => def delta(a)   %(ER_delta_dom)%
forall a : Elem;b : Elem
  . not b = 0 => (exists q : Elem;r : Elem . (a = ( ( q * b ) + r ) /\ (r = 0 \/ ( delta(r) < delta(b) ))))   %(ER_div)%
end

%[ view EuclidianRing_in_Int =
sorts 
Elem |-> Int,Nat |-> Nat
ops 
0 |-> 0:Elem, __*__ |-> __*__:Elem*Elem->Elem, __+__ |-> __+__:Elem*Elem->Elem, delta |-> abs:Elem->?Nat, e |-> 1:Elem
preds 
__<__ |-> __<__:Nat*Nat
end ]%

spec ExtAbelianGroup %% [...] %%  =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : Int->Int;
  -__ : Nat->Int;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Int->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __^__ : Int*Nat->Int;
  __^__ : Nat*Nat->Nat;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  abs : Int->Nat;
  abs : Nat->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  even : Int;
  even : Nat;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec ExtCommutativeMonoid %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec ExtCommutativeRing %% [...] %%  =
sorts
  NonZero[Elem],RUnit[Elem],Irred[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  -__ : Int->Int;
  -__ : Nat->Int;
  0 : Elem;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Elem*Elem->Elem;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Elem*Elem->Elem;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Int*Nat->Int;
  __^__ : Nat*Nat->Nat;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __times__ : Elem*Pos->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Int->Elem;
  __times__ : Nat*Nat->Nat;
  __times__ : Int*Nat->Int;
  abs : Int->Nat;
  abs : Nat->Nat;
  e : RUnit[Elem];
  e : Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Int;
  even : Nat;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
end

spec ExtCommutativeSemiGroup %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec ExtEuclidianRing %% [...] %%  =
sorts
  NonZero[Elem],RUnit[Elem],Irred[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  -__ : Int->Int;
  -__ : Nat->Int;
  0 : Elem;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Elem*Elem->Elem;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Elem*Elem->Elem;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Int*Nat->Int;
  __^__ : Nat*Nat->Nat;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __times__ : Elem*Pos->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Int->Elem;
  __times__ : Nat*Nat->Nat;
  __times__ : Int*Nat->Int;
  abs : Int->Nat;
  abs : Nat->Nat;
  delta : Elem->?Nat;
  e : RUnit[Elem];
  e : Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Int;
  even : Nat;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
  . hasNoZeroDivisors  
forall x : Elem;y : Elem
  . ( x * y ) = 0 => x = 0 \/ y = 0   %(noZeroDiv)%
forall x : Elem;y : Elem
  . not e = 0   %(zeroNeqOne)%
end

spec ExtField %% [...] %%  =
sorts
  NonZero[Elem],RUnit[Elem],Irred[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : Elem->Elem;
  -__ : RUnit[Elem]->RUnit[Elem];
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __/__ : Elem*Elem->?Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : NonZero[Elem]*Pos->NonZero[Elem];
  __^__ : NonZero[Elem]*Nat->NonZero[Elem];
  __^__ : NonZero[Elem]*Int->NonZero[Elem];
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Int*Nat->Int;
  __times__ : Nat*Nat->Nat;
  __times__ : Elem*Int->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Pos->Elem;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : NonZero[Elem];
  e : Elem;
  e : RUnit[Elem];
  inv : NonZero[Elem]->NonZero[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : NonZero[Elem];n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : NonZero[Elem];n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : NonZero[Elem];n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem]
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : NonZero[Elem]
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : NonZero[Elem];n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem]
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : NonZero[Elem]
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : NonZero[Elem];p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : NonZero[Elem];n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem]
  . exists x' : NonZero[Elem] . ( x' * x ) = e  
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : NonZero[Elem];y : NonZero[Elem];n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : NonZero[Elem];y : NonZero[Elem];n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
  . not e = 0  
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem;n : NonZero[Elem]
  . ( 0 / n ) = 0   %(Field_div_def1)%
forall x : Elem;n : NonZero[Elem]
  . not def ( x / 0 )   %(Field_div_def2)%
forall x : Elem;y : Elem
  . def ( x / y ) <=> not y = 0   %(Field_div_dom)%
end

spec ExtGroup %% [...] %%  =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : Int->Int;
  -__ : Nat->Int;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Int->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __^__ : Int*Nat->Int;
  __^__ : Nat*Nat->Nat;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  abs : Int->Nat;
  abs : Nat->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  even : Int;
  even : Nat;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
end

spec ExtGroupAction %% [...] %%  =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Space
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  0 : Nat;
  0 : Int;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Int->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  connected : Space*Space;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Space;y : Space
  . connected(x,y) <=> (exists a : Elem . ( a * x ) = y)   %(Action_connected_def)%
forall x : Space;a : Elem;b : Elem
  . ( e * x ) = x   %(MAction_unit)%
forall x : Space;a : Elem;b : Elem
  . ( ( a * b ) * x ) = ( a * ( b * x ) )   %(MAction_assoc)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall a : Elem;b : Elem;x : Space;y : Space
  . ( a * x ) = ( a * y ) => x = y   %(GroupAct_inj)%
forall a : Elem;b : Elem;x : Space;y : Space
  . exists z : Space . ( a * z ) = x   %(GroupAct_surj)%
end

spec ExtIntegralDomain %% [...] %%  =
sorts
  Irred[Elem],RUnit[Elem],NonZero[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  -__ : Int->Int;
  -__ : Nat->Int;
  0 : Elem;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __+__ : Elem*Elem->Elem;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Elem*Elem->Elem;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Int*Nat->Int;
  __^__ : Nat*Nat->Nat;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __times__ : Elem*Int->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Pos->Elem;
  __times__ : Int*Nat->Int;
  __times__ : Nat*Nat->Nat;
  abs : Int->Nat;
  abs : Nat->Nat;
  e : RUnit[Elem];
  e : Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Int;
  even : Nat;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
  . hasNoZeroDivisors  
end

spec ExtMonoid %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Nat->Elem;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
end

spec ExtMonoidAction %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos;
  Space
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  connected : Space*Space;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Space;y : Space
  . connected(x,y) <=> (exists a : Elem . ( a * x ) = y)   %(Action_connected_def)%
end

spec ExtRing %% [...] %%  =
sorts
  Irred[Elem],RUnit[Elem],NonZero[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Int->Int;
  +__ : Nat->Nat;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Int->Int;
  -__ : Nat->Int;
  -__ : Elem->Elem;
  0 : Elem;
  0 : Int;
  0 : Nat;
  1 : Int;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : Elem*Elem->Elem;
  __*__ : Int*Int->Int;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Elem*Elem->Elem;
  __+__ : Int*Int->Int;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Int*Int->Int;
  __-__ : Nat*Nat->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Int*Int->?Int;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Int*Int->?Int;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __times__ : Elem*Int->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Pos->Elem;
  __times__ : Int*Nat->Int;
  __times__ : Nat*Nat->Nat;
  abs : Int->Nat;
  abs : Nat->Nat;
  e : RUnit[Elem];
  e : Elem;
  max : Int*Int->Int;
  max : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Int*Int;
  __<=__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Nat*Nat;
  even : Int;
  even : Nat;
  isIrred : Elem;
  isUnit : Elem;
  odd : Int;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
end

spec ExtSemiGroup %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Pos;
  1 : Nat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Elem*Elem->Elem;
  __*__ : Pos*Pos->Pos;
  __*__ : Nat*Nat->Nat;
  __+__ : Pos*Nat->Pos;
  __+__ : Nat*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Nat*Nat->Nat;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Pos;
  suc : Nat->Nat
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
end

spec ExtTotalOrder %% [...] %%  =
sort
  Elem
ops
  inf : Elem*Elem->?Elem;
  max : Elem*Elem->Elem;
  min : Elem*Elem->Elem;
  sup : Elem*Elem->?Elem
preds
  __<=__ : Elem*Elem;
  __<__ : Elem*Elem;
  __>=__ : Elem*Elem;
  __>__ : Elem*Elem
forall x : Elem;y : Elem
  . ( x >= y ) <=> ( y <= x )   %(SigOrder_geq_def)%
forall x : Elem;y : Elem
  . ( x < y ) <=> ( x <= y ) /\ not x = y   %(SigOrder_less_def)%
forall x : Elem;y : Elem
  . ( x > y ) <=> ( y < x )   %(SigOrder_greater_def)%
forall x : Elem;y : Elem;z : Elem
  . inf(x,y) = z <=> ( z <= x ) /\ ( z <= y ) /\ (forall t : Elem . (( t <= x ) /\ ( t <= y ) => ( t <= z )))   %(inf_def)%
forall x : Elem;y : Elem;z : Elem
  . sup(x,y) = z <=> ( x <= z ) /\ ( y <= z ) /\ (forall t : Elem . (( x <= t ) /\ ( y <= t ) => ( z <= t )))   %(sup_def)%
forall x : Elem;y : Elem
  . inf(x,y) = inf(y,x)   %(comm_law___inf)%
forall x : Elem;y : Elem
  . sup(x,y) = sup(y,x)   %(comm_law___sup)%
forall x : Elem
  . ( x <= x )   %(refl)%
forall x : Elem;y : Elem;z : Elem
  . ( x <= y ) /\ ( y <= z ) => ( x <= z )   %(trans)%
forall x : Elem;y : Elem
  . ( x <= y ) /\ ( y <= x ) => x = y   %(POrder_antisym)%
forall x : Elem;y : Elem
  . min(x,y) = x when ( x <= y ) else y   %(min_def)%
forall x : Elem;y : Elem
  . max(x,y) = y when ( x <= y ) else x   %(max_def)%
forall x : Elem;y : Elem
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Elem;y : Elem
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Elem;y : Elem;z : Elem
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Elem;y : Elem;z : Elem
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Elem;y : Elem
  . min(x,y) = inf(x,y)   %(min_inf_relation)%
forall x : Elem;y : Elem
  . max(x,y) = sup(x,y)   %(max_sup_relation)%
end

spec Field =
sort
  Elem
ops
  0 : Elem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
  . not e = 0  
forall x : Elem
  . x in NonZeroElem <=> not x = 0  
forall x : NonZeroElem;y : NonZeroElem;z : NonZeroElem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : NonZeroElem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : NonZeroElem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : NonZeroElem
  . exists x' : NonZeroElem . ( x' * x ) = e  
end

%[ view Field_in_Rat =
sorts 
Elem |-> Rat
ops 
e |-> 1:Elem
end ]%

spec Group =
sort
  Elem
ops
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
end

spec GroupAction %% [...] %%  =
sorts
  Elem;
  Space
ops
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Space;a : Elem;b : Elem
  . ( e * x ) = x   %(MAction_unit)%
forall x : Space;a : Elem;b : Elem
  . ( ( a * b ) * x ) = ( a * ( b * x ) )   %(MAction_assoc)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
end

spec Int =
sorts
  Nat,Pos < Int;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  0 : Nat;
  0 : Int;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
end

spec IntegralDomain =
sort
  Elem
ops
  0 : Elem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem
  . ( x * y ) = 0 => x = 0 \/ y = 0   %(noZeroDiv)%
forall x : Elem;y : Elem
  . not e = 0   %(zeroNeqOne)%
end

spec Monoid =
sort
  Elem
ops
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
end

spec MonoidAction %% [...] %%  =
sorts
  Elem;
  Space
ops
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  e : Elem
forall x : Space;a : Elem;b : Elem
  . ( e * x ) = x   %(MAction_unit)%
forall x : Space;a : Elem;b : Elem
  . ( ( a * b ) * x ) = ( a * ( b * x ) )   %(MAction_assoc)%
end

spec Nat =
sorts
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
end

spec PowerTheorems %% [...] %%  =
sorts
  Elem;
  Exponent
ops
  __*__ : Exponent*Exponent->Exponent;
  __*__ : Elem*Elem->Elem;
  __+__ : Exponent*Exponent->Exponent;
  __^__ : Elem*Exponent->Elem
forall x : Elem;n : Exponent;m : Exponent
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Exponent;m : Exponent
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
end

spec PowerTheoremsComm %% [...] %%  =
sorts
  Elem;
  Exponent
ops
  __*__ : Exponent*Exponent->Exponent;
  __*__ : Elem*Elem->Elem;
  __+__ : Exponent*Exponent->Exponent;
  __^__ : Elem*Exponent->Elem
forall x : Elem;y : Elem;n : Exponent
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec PreOrder =
sort
  Elem
pred
  __<=__ : Elem*Elem
forall x : Elem
  . ( x <= x )   %(refl)%
forall x : Elem;y : Elem;z : Elem
  . ( x <= y ) /\ ( y <= z ) => ( x <= z )   %(trans)%
end

%[ view PreOrder_in_ExtCRing =

preds 
__<=__ |-> __divides__:Elem*Elem
end ]%

%[ view PreOrder_in_ExtMonoidAction =
sorts 
Elem |-> Space
preds 
__<=__ |-> connected:Elem*Elem
end ]%

%[ view PreOrder_in_RichCRing =

preds 
__<=__ |-> __divides__:Elem*Elem
end ]%

%[ view PreOrder_in_RichMonoidAction =
sorts 
Elem |-> Space
preds 
__<=__ |-> connected:Elem*Elem
end ]%

spec Rat =
sorts
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Int,Nat,Pos < Rat
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  +__ : Rat->Rat;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : Rat->Rat;
  0 : Nat;
  0 : Int;
  0 : Rat;
  1 : Nat;
  1 : Pos;
  1 : Int;
  1 : Rat;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Rat*Rat->Rat;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Rat*Rat->Rat;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Rat*Rat->Rat;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Int*Pos->Rat;
  __/__ : Rat*Rat->?Rat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Rat*Int->Rat;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  abs : Rat->Rat;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  max : Rat*Rat->Rat;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  min : Rat*Rat->Rat;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<=__ : Rat*Rat;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __<__ : Rat*Rat;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>=__ : Rat*Rat;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  __>__ : Rat*Rat;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
generated
  { sorts Rat  ops __/__ : Int*Pos->Rat }
forall i : Int;j : Int;p : Pos;q : Pos
  . ( i / p ) = ( j / q ) <=> ( i * q ) = ( j * p )   %(Rat_equality)%
forall i : Int
  . ( i / 1 ) = i   %(embeddingIntToRat)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( ( i / p ) <= ( j / q ) ) <=> ( ( i * q ) <= ( j * p ) )   %(Rat_leq_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x >= y ) <=> ( y <= x )   %(Rat_geq_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x < y ) <=> ( x <= y ) /\ not x = y   %(Rat_less_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x > y ) <=> ( y < x )   %(Rat_greater_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( ( i / p ) + ( j / q ) ) = ( ( ( i * q ) + ( j * p ) ) / ( p * q ) )   %(Rat_add_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x - y ) = ( x + (- y ) )   %(Rat_sub_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( ( i / p ) * ( j / q ) ) = ( ( i * j ) / ( p * q ) )   %(Rat_mult_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . not def ( x / 0 )   %(Rat_divide_def1)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . not y = 0 => (( x / y ) = z <=> z = ( x * y ))   %(Rat_divide_def2)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . (+ x ) = x   %(Rat_plus_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . (- ( i / p ) ) = ( (- i ) / p )   %(Rat_minus_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . abs(( i / p )) = ( abs(i) / p )   %(Rat_abs_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x ^ 0 ) = 1   %(Rat_power_0)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(Rat_power_suc)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . ( x ^ (- p ) ) = ( 1 / ( x ^ p ) )   %(Rat_power_neg)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . min(x,y) = x when ( x <= y ) else y   %(Rat_min_def)%
forall p : Pos;q : Pos;n : Nat;i : Int;j : Int;x : Rat;y : Rat;z : Rat
  . max(x,y) = y when ( x <= y ) else x   %(Rat_max_def)%
forall i : Int;j : Int;p : Pos;q : Pos
  . ( ( i / p ) - ( j / q ) ) = ( ( ( i * q ) - ( j * p ) ) / ( p * q ) )   %(Rat_sub_rule)%
forall i : Int;j : Int;p : Pos;q : Pos
  . not j = 0 => ( ( i / p ) / ( j / q ) ) = ( ( i / p ) * ( q / j ) )   %(Rat_divide_rule)%
end

spec RichAbelianGroup =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  0 : Nat;
  0 : Int;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Int->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec RichCommutativeMonoid =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
end

spec RichCommutativeRing =
sorts
  Irred[Elem],RUnit[Elem],NonZero[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Elem*Int->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Pos->Elem;
  __times__ : Int*Nat->Int;
  __times__ : Nat*Nat->Nat;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  e : RUnit[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Nat;
  even : Int;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
end

spec RichCommutativeSemiGroup =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
end

spec RichEuclidianRing =
sorts
  Irred[Elem],RUnit[Elem],NonZero[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Elem*Int->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Pos->Elem;
  __times__ : Int*Nat->Int;
  __times__ : Nat*Nat->Nat;
  abs : Nat->Nat;
  abs : Int->Nat;
  delta : Elem->?Nat;
  e : Elem;
  e : RUnit[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Nat;
  even : Int;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
  . hasNoZeroDivisors  
forall x : Elem;y : Elem
  . ( x * y ) = 0 => x = 0 \/ y = 0   %(noZeroDiv)%
forall x : Elem;y : Elem
  . not e = 0   %(zeroNeqOne)%
forall a : Elem;b : Elem
  . not a = 0 => def delta(a)   %(ER_delta_dom)%
forall a : Elem;b : Elem
  . not b = 0 => (exists q : Elem;r : Elem . (a = ( ( q * b ) + r ) /\ (r = 0 \/ ( delta(r) < delta(b) ))))   %(ER_div)%
end

spec RichField =
sorts
  Irred[Elem],RUnit[Elem],NonZero[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : Elem->Elem;
  -__ : RUnit[Elem]->RUnit[Elem];
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Elem*Elem->?Elem;
  __/__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : NonZero[Elem]*Pos->NonZero[Elem];
  __^__ : NonZero[Elem]*Nat->NonZero[Elem];
  __^__ : NonZero[Elem]*Int->NonZero[Elem];
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Nat*Nat->Nat;
  __times__ : Int*Nat->Int;
  __times__ : Elem*Pos->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Int->Elem;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  e : RUnit[Elem];
  e : NonZero[Elem];
  inv : NonZero[Elem]->NonZero[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : NonZero[Elem];n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : NonZero[Elem];n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : NonZero[Elem];n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem]
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : NonZero[Elem]
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : NonZero[Elem];n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem]
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : NonZero[Elem]
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : NonZero[Elem];p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : NonZero[Elem];y : NonZero[Elem];z : NonZero[Elem];n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : NonZero[Elem];n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : NonZero[Elem];n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : NonZero[Elem]
  . exists x' : NonZero[Elem] . ( x' * x ) = e  
forall x : NonZero[Elem];y : NonZero[Elem]
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : NonZero[Elem];y : NonZero[Elem];n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : NonZero[Elem];y : NonZero[Elem];n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
  . not e = 0  
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem;n : NonZero[Elem]
  . ( 0 / n ) = 0   %(Field_div_def1)%
forall x : Elem;n : NonZero[Elem]
  . not def ( x / 0 )   %(Field_div_def2)%
forall x : Elem;y : Elem
  . def ( x / y ) <=> not y = 0   %(Field_div_dom)%
forall x : Elem
  . x in NonZeroElem <=> not x = 0  
forall x : NonZeroElem;y : NonZeroElem;z : NonZeroElem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : NonZeroElem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : NonZeroElem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : NonZeroElem
  . exists x' : NonZeroElem . ( x' * x ) = e  
end

spec RichGroup =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  0 : Nat;
  0 : Int;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Int->Elem;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
end

spec RichGroupAction %% [...] %%  =
sorts
  Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Space
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  0 : Nat;
  0 : Int;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __/__ : Elem*Elem->Elem;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Int->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  inv : Elem->Elem;
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  connected : Space*Space;
  even : Nat;
  even : Int;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Space;y : Space
  . connected(x,y) <=> (exists a : Elem . ( a * x ) = y)   %(Action_connected_def)%
forall x : Space;a : Elem;b : Elem
  . ( e * x ) = x   %(MAction_unit)%
forall x : Space;a : Elem;b : Elem
  . ( ( a * b ) * x ) = ( a * ( b * x ) )   %(MAction_assoc)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = e  
forall x : Elem;y : Elem
  . ( inv(x) * x ) = e   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x / y ) = ( x * inv(y) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = inv(( x ^ p ))   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * inv(x) ) = e   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(inv(x)) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(e) = e   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . inv(( x * y )) = ( inv(y) * inv(x) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall a : Elem;b : Elem;x : Space;y : Space
  . ( a * x ) = ( a * y ) => x = y   %(GroupAct_inj)%
forall a : Elem;b : Elem;x : Space;y : Space
  . exists z : Space . ( a * z ) = x   %(GroupAct_surj)%
end

spec RichIntegralDomain =
sorts
  NonZero[Elem],RUnit[Elem],Irred[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : NonZero[Elem]*NonZero[Elem]->NonZero[Elem];
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Elem*Pos->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Int->Elem;
  __times__ : Nat*Nat->Nat;
  __times__ : Int*Nat->Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  e : RUnit[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  __divides__ : Elem*Elem;
  associated : Elem*Elem;
  even : Nat;
  even : Int;
  hasNoZeroDivisors : ();
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
forall x : Elem;y : Elem
  . hasNoZeroDivisors <=> (forall x : Elem;y : Elem . (( x * y ) = 0 => x = 0 \/ y = 0))   %(hasNoZeroDivisors_def)%
forall x : Elem;y : Elem
  . ( x divides y ) <=> (exists z : Elem . ( x * z ) = y)   %(divides_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> (exists u : RUnit[Elem] . x = ( u * y ))   %(associated_def)%
forall x : Elem;y : Elem
  . associated(x,y) <=> ( x divides y ) /\ ( y divides x )  
  . hasNoZeroDivisors  
forall x : Elem;y : Elem
  . ( x * y ) = 0 => x = 0 \/ y = 0   %(noZeroDiv)%
forall x : Elem;y : Elem
  . not e = 0   %(zeroNeqOne)%
end

spec RichMonoid =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Nat->Elem;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
end

spec RichMonoidAction %% [...] %%  =
sorts
  Elem;
  Pos < Nat;
  Pos;
  Space
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Space->Space;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  e : Elem;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  connected : Space*Space;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Space;y : Space
  . connected(x,y) <=> (exists a : Elem . ( a * x ) = y)   %(Action_connected_def)%
forall x : Space;a : Elem;b : Elem
  . ( e * x ) = x   %(MAction_unit)%
forall x : Space;a : Elem;b : Elem
  . ( ( a * b ) * x ) = ( a * ( b * x ) )   %(MAction_assoc)%
end

spec RichRing =
sorts
  NonZero[Elem],RUnit[Elem],Irred[Elem] < Elem;
  Nat,Pos < Int;
  Pos < Nat;
  Pos;
  Irred[Elem];
  NonZero[Elem];
  RUnit[Elem]
ops
  +__ : Nat->Nat;
  +__ : Int->Int;
  -__ : Nat->Int;
  -__ : Int->Int;
  -__ : RUnit[Elem]->RUnit[Elem];
  -__ : Elem->Elem;
  0 : Nat;
  0 : Int;
  0 : Elem;
  1 : Nat;
  1 : Pos;
  1 : Int;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  Nat : Int;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Int*Int->Int;
  __*__ : Elem*Elem->Elem;
  __*__ : RUnit[Elem]*RUnit[Elem]->RUnit[Elem];
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __+__ : Int*Int->Int;
  __+__ : Elem*Elem->Elem;
  __-?__ : Nat*Nat->?Nat;
  __-__ : Nat*Nat->Int;
  __-__ : Int*Int->Int;
  __-__ : Elem*Elem->Elem;
  __/?__ : Nat*Nat->?Nat;
  __/?__ : Int*Int->?Int;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Int*Nat->Int;
  __^__ : Elem*Pos->Elem;
  __^__ : Elem*Nat->Elem;
  __div__ : Nat*Nat->?Nat;
  __div__ : Int*Int->?Int;
  __mod__ : Nat*Nat->?Nat;
  __mod__ : Int*Int->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __quot__ : Int*Int->?Int;
  __rem__ : Nat*Nat->?Nat;
  __rem__ : Int*Int->?Int;
  __times__ : Elem*Pos->Elem;
  __times__ : Elem*Nat->Elem;
  __times__ : Elem*Int->Elem;
  __times__ : Nat*Nat->Nat;
  __times__ : Int*Nat->Int;
  abs : Nat->Nat;
  abs : Int->Nat;
  e : Elem;
  e : RUnit[Elem];
  max : Nat*Nat->Nat;
  max : Int*Int->Int;
  min : Nat*Nat->Nat;
  min : Int*Int->Int;
  pre : Nat->?Nat;
  sign : Int->Int;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<=__ : Int*Int;
  __<__ : Nat*Nat;
  __<__ : Int*Int;
  __>=__ : Nat*Nat;
  __>=__ : Int*Int;
  __>__ : Nat*Nat;
  __>__ : Int*Int;
  even : Nat;
  even : Int;
  isIrred : Elem;
  isUnit : Elem;
  odd : Nat;
  odd : Int
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x ^ 0 ) = 0   %(Monoid_pow_0)%
forall n : Nat
  . ( 0 ^ n ) = 0   %(Monoid_pow_unit)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Nat;m : Nat
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
forall x : Elem
  . ( x * 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem
  . ( (- x ) * x ) = 0   %(Group_inverse_def)%
forall x : Elem;y : Elem
  . ( x - y ) = ( x * (- y ) )   %(Group_div_def)%
forall x : Elem;p : Pos
  . ( x ^ (- p ) ) = (- ( x ^ p ) )   %(Group_pow_neg)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * (- x ) ) = 0   %(Group_right_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( z * x ) = ( z * y ) => x = y   %(Group_left_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . ( x * z ) = ( y * z ) => x = y   %(Group_right_canc)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- (- x ) ) = x   %(Group_inv_inv)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- 0 ) = 0   %(Group_inv_e)%
forall x : Elem;y : Elem;z : Elem;n : Int;m : Int
  . (- ( x * y ) ) = ( (- y ) * (- x ) )   %(Group_inv_prod)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n + m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Int;m : Int
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Int  ops __-__ : Nat*Nat->Int }
forall a : Nat;b : Nat;c : Nat;d : Nat
  . ( a - b ) = ( c - d ) <=> ( a + d ) = ( c + b )   %(Int_equality)%
forall a : Nat
  . a = ( a - 0 )   %(Int_Nat_embedding)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) + ( c - d ) ) = ( ( a + c ) - ( b + d ) )   %(Int_add_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( ( a - b ) * ( c - d ) ) = ( ( ( a * c ) + ( b * d ) ) - ( ( b * c ) + ( a * d ) ) )   %(Int_mult_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m - n ) = ( m + (- n ) )   %(Int_sub_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (+ m ) = m   %(Int_pos_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . (- ( a - b ) ) = ( b - a )   %(Int_neg_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . sign(m) = 0 when m = 0 else 1 when ( m > 0 ) else (- 1 )   %(Int_sign_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m <= n ) <=> ( n - m ) in Nat   %(Int_leq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m >= n ) <=> ( n <= m )   %(Int_geq_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Int_less_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m > n ) <=> ( m < n )   %(Int_greater_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Int_min_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Int_max_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m < 0 ) => abs(m) = (- m )   %(Int_abs_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( (- 1 ) ^ a ) = 1 when even(a) else (- 1 )   %(Int_neg1_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m ^ a ) = ( ( sign(m) ^ a ) * ( abs(m) ^ a ) )   %(Int_power_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . even(m) <=> even(abs(m))   %(Int_even_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . odd(m) <=> not even(m)   %(Int_odd_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m /? n ) = ( ( sign(m) * sign(n) ) * ( abs(m) /? abs(n) ) )   %(Int_divide)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => ( ( m mod n ) < abs(n) )   %(Int_mod_range)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not n = 0 => m = ( ( ( m div n ) * n ) + ( m mod n ) )   %(Int_mod__div_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m mod 0 )   %(Int_mod_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . not def ( m div 0 )   %(Int_div_zero)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m quot n ) = ( ( sign(m) * sign(n) ) * ( abs(m) quot abs(n) ) )   %(Int_quot_def)%
forall m : Int;n : Int;r : Int;s : Int;a : Nat;b : Nat;c : Nat;d : Nat
  . ( m rem n ) = ( ( sign(m) * sign(n) ) * ( abs(m) rem abs(n) ) )   %(Int_rem_def)%
generated
  { sorts Int  ops -__ : Nat->Int; Nat : Int }
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( a -? b ) => ( a -? b ) = ( a - b )   %(Int_Nat_sub_compat)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . m = ( sign(m) * abs(m) )   %(Int_abs_decomp)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . odd(m) <=> odd(abs(m))   %(Int_odd_alt)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m /? n ) = r <=> not n = 0 /\ ( n * r ) = n   %(Int_divide_dom1)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Int_divide_dom2)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m mod n ) <=> not n = 0   %(Int_mod_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . ( m mod n ) = ( m mod abs(n) )   %(Int_mod_abs)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m div n ) <=> not n = 0   %(Int_div_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m quot n ) <=> not n = 0   %(Int_quot_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . def ( m rem n ) <=> not n = 0   %(Int_rem_dom)%
forall m : Int;n : Int;r : Int;a : Nat;b : Nat
  . not n = 0 => m = ( ( ( m quot n ) * n ) + ( m rem n ) )   %(Int_quot_rem)%
forall x : Elem
  . exists x' : Elem . ( x' * x ) = 0  
forall x : Elem;y : Elem
  . ( x * y ) = ( y * x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;n : Pos
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;n : Nat
  . ( ( x ^ n ) * ( y ^ n ) ) = ( ( x * y ) ^ n )   %(Power_basemult)%
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
forall x : Elem
  . ( x ^ 0 ) = e   %(Monoid_pow_0)%
forall n : Nat
  . ( e ^ n ) = e   %(Monoid_pow_unit)%
forall x : Elem
  . x in NonZero[Elem] <=> not x = 0  
forall x : Elem
  . x in RUnit[Elem] <=> isUnit(x)  
forall x : Elem
  . x in Irred[Elem] <=> isIrred(x)  
forall x : Elem;y : Elem
  . isUnit(x) <=> (exists y : Elem . (( x * y ) = e /\ ( y * x ) = e))   %(Ring_isUnit_def)%
forall x : Elem;y : Elem
  . isIrred(x) <=> not isUnit(x) /\ (forall y : Elem;z : Elem . (x = ( y * z ) => isUnit(y) \/ isUnit(z)))   %(Ring_isIrred_def)%
end

spec RichSemiGroup =
sorts
  Elem;
  Pos < Nat;
  Pos
ops
  +__ : Nat->Nat;
  0 : Nat;
  1 : Nat;
  1 : Pos;
  2 : Nat;
  3 : Nat;
  4 : Nat;
  5 : Nat;
  6 : Nat;
  7 : Nat;
  8 : Nat;
  9 : Nat;
  __! : Nat->Nat;
  __*__ : Nat*Nat->Nat;
  __*__ : Pos*Pos->Pos;
  __*__ : Elem*Elem->Elem;
  __+__ : Nat*Nat->Nat;
  __+__ : Nat*Pos->Pos;
  __+__ : Pos*Nat->Pos;
  __-?__ : Nat*Nat->?Nat;
  __/?__ : Nat*Nat->?Nat;
  __@@__ : Nat*Nat->Nat;
  __^__ : Nat*Nat->Nat;
  __^__ : Elem*Pos->Elem;
  __div__ : Nat*Nat->?Nat;
  __mod__ : Nat*Nat->?Nat;
  __quot__ : Nat*Nat->?Nat;
  __rem__ : Nat*Nat->?Nat;
  abs : Nat->Nat;
  max : Nat*Nat->Nat;
  min : Nat*Nat->Nat;
  pre : Nat->?Nat;
  suc : Nat->Nat;
  suc : Nat->Pos
preds
  __<=__ : Nat*Nat;
  __<__ : Nat*Nat;
  __>=__ : Nat*Nat;
  __>__ : Nat*Nat;
  even : Nat;
  odd : Nat
forall x : Elem;n : Pos
  . ( x ^ 1 ) = x   %(SGroup_pow_1)%
forall x : Elem;n : Pos
  . ( x ^ suc(n) ) = ( x * ( x ^ n ) )   %(SGroup_pow_suc)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) * ( x ^ m ) )   %(Power_add)%
forall x : Elem;n : Pos;m : Pos
  . ( x ^ ( n * m ) ) = ( ( x ^ n ) ^ m )   %(Power_mult)%
generated
  { sorts Nat  ops 0 : Nat; suc : Nat->Nat }
forall X0 : Nat
  . X0 = pre(suc(X0))   %(selector___pre)%
forall Y0 : Nat
  . not 0 = suc(Y0)   %(disjoint___0___suc)%
forall X0 : Nat;Y0 : Nat
  . suc(X0) = suc(Y0) => X0 = Y0   %(injective___suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 <= n )   %(Nat_leq_def1)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not ( suc(n) <= 0 )   %(Nat_leq_def2)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(m) <= suc(n) ) <=> ( m <= n )   %(Nat_leq_def3)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m >= n ) <=> ( n <= m )   %(Nat_geq_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m < n ) <=> ( m <= n ) /\ not m = n   %(Nat_less_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m > n ) <=> ( m < n )   %(Nat_greater_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 + m ) = m   %(Nat_add_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) + m ) = suc(( n + m ))   %(Nat_add_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 * m ) = 0   %(Nat_mult_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) * m ) = ( ( n * m ) + m )   %(Nat_mult_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ 0 ) = 1   %(Nat_power_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m ^ suc(n) ) = ( m * ( m ^ n ) )   %(Nat_power_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . min(m,n) = m when ( m <= n ) else n   %(Nat_min_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . max(m,n) = n when ( m <= n ) else m   %(Nat_max_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . (+ m ) = m   %(plus_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . abs(n) = n   %(Nat_abs)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . odd(m) <=> not even(m)   %(Nat_odd_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(0)   %(Nat_even_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . even(suc(m)) <=> odd(m)   %(Nat_even_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( 0 !) = 1   %(Nat_factorial_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( suc(n) !) = ( suc(n) * ( n !) )   %(Nat_factorial_suc)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m -? n ) = r <=> m = ( r + n )   %(Nat_sub_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . not def ( m /? 0 )   %(Nat_divide_0)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( n > 0 ) => (( m /? n ) = r <=> m = ( r * n ))   %(Nat_divide_Pos)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m div n ) = r <=> (exists s : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_div)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m mod n ) = s <=> (exists r : Nat . (m = ( ( n * r ) + s ) /\ ( s < n )))   %(Nat_mod)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m quot n ) = ( m div n )   %(Nat_quot)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m rem n ) = ( m mod n )   %(Nat_rem)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 1 = suc(0)   %(Nat_1_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 2 = suc(1)   %(Nat_2_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 3 = suc(2)   %(Nat_3_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 4 = suc(3)   %(Nat_4_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 5 = suc(4)   %(Nat_5_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 6 = suc(5)   %(Nat_6_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 7 = suc(6)   %(Nat_7_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 8 = suc(7)   %(Nat_8_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . 9 = suc(8)   %(Nat_9_def)%
forall m : Nat;n : Nat;r : Nat;s : Nat
  . ( m @@ n ) = ( ( m * suc(9) ) + n )   %(Nat_decimal_def)%
forall p : Nat
  . p in Pos <=> ( p > 0 )  
  . suc(0) as Pos = 1  
forall x : Nat;y : Nat
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Nat;y : Nat
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Nat;y : Nat;z : Nat
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Nat;y : Nat;z : Nat
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m -? n ) <=> ( m >= n )   %(Nat_sub_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m /? n ) <=> ( m mod n ) = 0   %(Nat_divide_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m div n ) <=> not n = 0   %(Nat_div_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m mod n ) <=> not n = 0   %(Nat_mod_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m quot n ) <=> not n = 0   %(Nat_quot_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . def ( m rem n ) <=> not n = 0   %(Nat_rem_dom)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . ( ( r + s ) * t ) = ( ( r * t ) + ( s * t ) )   %(Nat_distr)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . max(m,0) = m   %(Nat_max_unit)%
forall x : Nat;m : Nat;n : Nat;r : Nat;s : Nat;t : Nat;p : Pos
  . min(m,0) = 0   %(Nat_min_0)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
end

spec RichTotalOrder =
sort
  Elem
ops
  inf : Elem*Elem->?Elem;
  max : Elem*Elem->Elem;
  min : Elem*Elem->Elem;
  sup : Elem*Elem->?Elem
preds
  __<=__ : Elem*Elem;
  __<__ : Elem*Elem;
  __>=__ : Elem*Elem;
  __>__ : Elem*Elem
forall x : Elem;y : Elem
  . ( x >= y ) <=> ( y <= x )   %(SigOrder_geq_def)%
forall x : Elem;y : Elem
  . ( x < y ) <=> ( x <= y ) /\ not x = y   %(SigOrder_less_def)%
forall x : Elem;y : Elem
  . ( x > y ) <=> ( y < x )   %(SigOrder_greater_def)%
forall x : Elem;y : Elem;z : Elem
  . inf(x,y) = z <=> ( z <= x ) /\ ( z <= y ) /\ (forall t : Elem . (( t <= x ) /\ ( t <= y ) => ( t <= z )))   %(inf_def)%
forall x : Elem;y : Elem;z : Elem
  . sup(x,y) = z <=> ( x <= z ) /\ ( y <= z ) /\ (forall t : Elem . (( x <= t ) /\ ( y <= t ) => ( z <= t )))   %(sup_def)%
forall x : Elem;y : Elem
  . inf(x,y) = inf(y,x)   %(comm_law___inf)%
forall x : Elem;y : Elem
  . sup(x,y) = sup(y,x)   %(comm_law___sup)%
forall x : Elem
  . ( x <= x )   %(refl)%
forall x : Elem;y : Elem;z : Elem
  . ( x <= y ) /\ ( y <= z ) => ( x <= z )   %(trans)%
forall x : Elem;y : Elem
  . ( x <= y ) /\ ( y <= x ) => x = y   %(POrder_antisym)%
forall x : Elem;y : Elem
  . min(x,y) = x when ( x <= y ) else y   %(min_def)%
forall x : Elem;y : Elem
  . max(x,y) = y when ( x <= y ) else x   %(max_def)%
forall x : Elem;y : Elem
  . min(x,y) = min(y,x)   %(comm_law___min)%
forall x : Elem;y : Elem
  . max(x,y) = max(y,x)   %(comm_law___max)%
forall x : Elem;y : Elem;z : Elem
  . min(x,min(y,z)) = min(min(x,y),z)   %(assoc_law___min)%
forall x : Elem;y : Elem;z : Elem
  . max(x,max(y,z)) = max(max(x,y),z)   %(assoc_law___max)%
forall x : Elem;y : Elem
  . min(x,y) = inf(x,y)   %(min_inf_relation)%
forall x : Elem;y : Elem
  . max(x,y) = sup(x,y)   %(max_sup_relation)%
forall x : Elem;y : Elem
  . ( x <= y ) \/ ( y <= x )   %(TOrder_comparability)%
end

spec Ring =
sort
  Elem
ops
  0 : Elem;
  __*__ : Elem*Elem->Elem;
  __+__ : Elem*Elem->Elem;
  e : Elem
forall x : Elem;y : Elem;z : Elem
  . ( x + ( y + z ) ) = ( ( x + y ) + z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x + 0 ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( 0 + x ) = x   %(left_unit_law_____*__)%
forall x : Elem
  . exists x' : Elem . ( x' + x ) = 0  
forall x : Elem;y : Elem
  . ( x + y ) = ( y + x )   %(comm_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
forall x : Elem
  . ( x * e ) = x   %(right_unit_law_____*__)%
forall x : Elem
  . ( e * x ) = x   %(left_unit_law_____*__)%
forall x : Elem;y : Elem;z : Elem
  . ( ( x + y ) * z ) = ( ( x * z ) + ( y * z ) )   %(Ring_distr1)%
forall x : Elem;y : Elem;z : Elem
  . ( z * ( x + y ) ) = ( ( z * x ) + ( z * y ) )   %(Ring_distr2)%
end

spec SemiGroup =
sort
  Elem
op
  __*__ : Elem*Elem->Elem
forall x : Elem;y : Elem;z : Elem
  . ( x * ( y * z ) ) = ( ( x * y ) * z )   %(assoc_law_____*__)%
end

spec SigPowerBinAlg %% [...] %%  =
sorts
  Elem;
  Exponent
ops
  __*__ : Elem*Elem->Elem;
  __^__ : Elem*Exponent->Elem

end

spec TotalOrder =
sort
  Elem
pred
  __<=__ : Elem*Elem
forall x : Elem
  . ( x <= x )   %(refl)%
forall x : Elem;y : Elem;z : Elem
  . ( x <= y ) /\ ( y <= z ) => ( x <= z )   %(trans)%
forall x : Elem;y : Elem
  . ( x <= y ) /\ ( y <= x ) => x = y   %(POrder_antisym)%
forall x : Elem;y : Elem
  . ( x <= y ) \/ ( y <= x )   %(TOrder_comparability)%
end

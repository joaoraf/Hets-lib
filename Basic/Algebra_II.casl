library Basic/Algebra_II
version 0.4
%% authors: M.Roggenbach, T.Mossakowski, L. Schröder
%% copyright: 15.03.00

from
     Basic/RelationsAndOrders version 0.4 get
     PartialOrder, ExtPartialOrder, TotalOrder
from
     Basic/Algebra_I version 0.4 get
     CommutativeRing, ExtCommutativeRing, IntegralDomain,
     ExtIntegralDomain, Field, ExtField, EuclidianRing,
     ExtEuclidianRing
from
     Basic/Numbers version 0.4 get Int
from
     Basic/StructuredDatatypes version 0.4 get List, Bag

spec
     CompactInt=
     Int
then
free
     {
     type
          CompactInt::=sort Int | infinity | -__(CompactInt)
     ops
           __+__: CompactInt × CompactInt ->? CompactInt, comm;
           __-__: CompactInt× CompactInt ->? CompactInt
     then
          ExtPartialOrder[PartialOrder]
          with sort Elem |-> CompactInt
     then
     vars
          n:Int;m,k:CompactInt
     .
          %[double_neg_compact] -(-m)=m
     .
          %[neg_sum_compact] (-m)+(-k)= -(m+k)
     .
          %[leq_compact_def1] -infinity<n
     .
          %[leq_compact_def2] n<infinity
     .
          %[infinity_plus_n_def] m> -infinity => infinity+m=infinity
     .
          %[compact_minus_def] m - k = m + ( - k )
}
end

view
     TotalOrder_in_CompactInt :
     TotalOrder to CompactInt =
     sort Elem |-> CompactInt %%changed
end

spec
     ConstructFactorialRing =
     ExtIntegralDomain [IntegralDomain]
               with sorts RUnit[Elem], Irred[Elem], pred associated
then
     %def
     Bag [sort Irred[Elem] fit Elem |-> Irred[Elem]] 
	with sort Bag[Irred[Elem]] |-> Factors[Elem]
then
     %def
     pred
          equiv: Factors[Elem] * Factors[Elem]
     op
          prod: Factors[Elem] -> Elem
     vars
          i,j: Irred[Elem]; S,T:Factors[Elem]
     .
          %[product_Bag_empty] prod({}) = e
     .
          %[product_Bag_plus] prod(S+i) = prod(S)*i
     .
          %[equiv_Bag_def]
           equiv(S,T) <=> (( S={} /\ T={} ) \/
                          (exists s,t: Irred[Elem] . (s eps S /\ t eps T /\
                          associated(s,t) /\ equiv(S - s, T - t)) ) )
then
     vars
          x:Elem; S,T:Factors[Elem]
     .
          %[exists_factorization] exists V:Factors[Elem] . x = prod(V)
     .
          %[unique_factorization] equiv(S,T) if associated(prod(S),prod(T))
end

spec
     FactorialRing =
     ConstructFactorialRing
        reveal sort Elem, 
	       ops __ + __: Elem * Elem -> Elem, 
		   __ * __: Elem * Elem -> Elem,
		   0: Elem, e: Elem
end

spec
     ExtFactorialRing  [FactorialRing] given Int=
     ExtIntegralDomain [FactorialRing]
then
     ConstructFactorialRing
end


view
     FactorialRing_in_ExtEuclRing  [EuclidianRing]
     given Int:
     FactorialRing to
     ExtEuclidianRing[EuclidianRing]
end


spec
     Polynomial  [CommutativeRing] given Int =
%def
     CompactInt and ExtCommutativeRing[CommutativeRing]
then
     local List[sort Elem]
within
     {
          sort
               Poly[Elem] = { l: List[Elem] . not last(l) = 0 }
     then
          sort
               Elem < Poly[Elem]
          ops
		0, e: Poly[Elem];
                X: Poly[Elem];
                degree: Poly[Elem] -> CompactInt;
                __:::__: Elem×Poly[Elem] -> Poly[Elem];
		__ + __: Poly[Elem] * Poly[Elem] -> Poly[Elem];
		__ * __: Poly[Elem] * Poly[Elem] -> Poly[Elem]
          vars
               a: Elem; p: Poly[Elem]
          .
               %[Poly_0] 0 = []
          .
               %[Embedding_of_Elem_in_Poly] a = a::[] if not a = 0
          .
               %[X_def] X = 0::e::[]
          .
               %[cons_Poly_def] a:::p = a when p = 0 else a :: p
          .
               %[degree_def] degree(p) = -infinity when p = 0 else #p - 1
     then
          closed
               {ExtCommutativeRing[CommutativeRing] with
                         sort Elem |-> Poly[Elem]}
     then
          vars
               p, q: Poly[Elem]; a, b: Elem
          .
               %[add_Polynomial_zero_def] p + 0 = p
          .
               %[add_Polynomial_cons_def]
               (a:::p) + (b:::q) = (a + b):::(p + q)
          .
               %[mult_Polynomial_zero_def] p * (0:Elem) = 0
          .
               %[mult_Polynomial_cons_def]
               (a:::p) * (b:::q) = ((a*b):::((b*p) + (a*q))) + 
		(0:::(0:::(p * q)))
     then
          %implies
          vars
               p,q:Poly[Elem]
          .
               %[degree_sum]
               degree(p) <= degree(q) => degree(p+q) <= degree(q)
          .
               %[degree_product] degree(p * q) <= degree(p) + degree(q)
          .
               %[degree_product_noZeroDivisors]
               hasNoZeroDivisors => degree(p * q) = degree(p) + degree(q)
}
end

view
     EuclidianRing_in_Polynomial [Field]:
     EuclidianRing to 
	{Polynomial [Field]
	  then
	     op natdegree: Poly[Elem] ->? Nat
	     var p: Poly[Elem]
	     .
		%[Poly_natdegree_def] natdegree(p) = degree(p) as Nat
	} =
     sorts
          Elem |-> Poly[Elem],
     ops
          delta |-> natdegree
end



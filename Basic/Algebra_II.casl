library Basic/Algebra_II
version 0.7 
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 23.3.01

%prec {__ * __} < {__ ^ __}
%prec {__ + __, __ - __, -__} < {__ / __, __ * __}
%left_assoc __ + __, __ * __, __ ^ __


from
     Basic/RelationsAndOrders version 0.7 get
     SigOrder, TotalOrder
from
     Basic/Algebra_I version 0.7 get
     CommutativeRing, RichIntegralDomain,
     Field, EuclidianRing, ExtEuclidianRing,
     RichEuclidianRing, ExtCommutativeRing
from
     Basic/Numbers version 0.7 get Int
from
     Basic/StructuredDatatypes version 0.7 get List, Bag


spec
     IntInfinity = Int
then
 {
     free type 
           IntInfty ::= sort Int | infty | negInfty
     ops
           __ + __, __ * __: IntInfty * IntInfty ->? IntInfty, comm;
	   __ - __: 	     IntInfty * IntInfty ->? IntInfty;
           - __:    	     IntInfty -> IntInfty
then
     SigOrder [sort IntInfty]
then
     forall n: Int; m, k: IntInfty
     . - infty = negInfty		        %(neg_def1_II)%
     . - negInfty = infty		        %(neg_def2_II)%

     . - negInfty <= m 				%(leq_def1_II)%
     . m <= infty             			%(leq_def2_II)%
     . m <= negInfty => m = negInfty		%(leq_def3_II)%
     . infty <= m => infty = m            	%(leq_def4_II)%

     . infty + n = infty			%(add_def1_II)%
     . infty + infty = infty			%(add_def2_II)%
     . not def infty + negInfty			%(add_def3_II)%
     . negInfty + k = - (infty + (- k))		%(add_def4_II)%

     . m > 0 => infty * m = infty		%(mult_def1_II)%
     . not def infty * 0			%(mult_def2_II)%
     . (- m) * k = -(m * k)			%(mult_def3_II)%

     . m - k = m + (- k)			%(sub_def_II)%
 }
hide 
     negInfty
end

view
     TotalOrder_in_IntInfinity :
     TotalOrder to IntInfinity =
     sort Elem |-> IntInfty
end

spec
     ConstructFactorialRing =
     RichIntegralDomain with sorts RUnit[Elem], Irred[Elem], pred associated
then
     %%mono
     Bag [sort Irred[Elem] fit sort Elem|-> Irred[Elem]] 
	with sort Bag[Irred[Elem]] |-> Factors[Elem]
then
     %def
     pred
	  equivalent: Factors[Elem] * Factors[Elem]
     op
          prod: Factors[Elem] -> Elem

     forall i,j: Irred[Elem]; S,T:Factors[Elem]
     . prod({}) = e				%(prod_empty_CFR)%
     . prod(S+i) = prod(S)*i			%(prod_plus_CFR)%
     . equivalent(S,T) <=> (( S={} /\ T={} ) \/
	(exists s,t: Irred[Elem] . (s eps S /\ t eps T /\
        associated(s,t) /\ equivalent(S - s, T - t)) ) )   
						%(equivalent_def_CFR)%
then
     forall x: Elem; S, T: Factors[Elem]
     . exists V: Factors[Elem] . x = prod(V)	%(existsFact_CFR)%
     . equivalent(S,T) if associated(prod(S), prod(T))
						%(uniqueFact_CFR)%
end

spec
     FactorialRing =
     ConstructFactorialRing
        reveal sort Elem, 
	       ops __ + __: Elem * Elem -> Elem, 
		   __ * __: Elem * Elem -> Elem,
		   0: Elem, e: Elem
end

spec
     ExtFactorialRing  [FactorialRing] given Int=
     RichIntegralDomain
and
     ConstructFactorialRing
end


view
     FactorialRing_in_ExtEuclRing  [EuclidianRing]
     given Int:
     FactorialRing to ExtEuclidianRing [EuclidianRing]
end

spec
     ConstructPolynomial [CommutativeRing] given Int =
%mono
     IntInfinity 
then
     local List[sort Elem] %[ [a_0,...,a_n] is a_n * x^n + ... + a_0 ]%
within
     {
          sort
               	Poly[Elem] = { l: List[Elem] . not last(l) = 0 }
     then
          sort
               	Elem < Poly[Elem]
          ops
                X: Poly[Elem];
                degree: Poly[Elem] -> IntInfty;
                __ ::: __: Elem * Poly[Elem] -> Poly[Elem];
		__ + __, __ * __:   
			Poly[Elem] * Poly[Elem] -> Poly[Elem]

          forall a, b: Elem; p, q: Poly[Elem]
          . 0 = []             			%(emb_def1_Poly)%
          . a = a :: [] if not a = 0		%(emb_def2_Poly)%

          . X = 0 :: e :: []             	%(X_def_Poly)%
          . a ::: p = a when p = 0 else a :: p	%(cons_def_Poly)%
          . degree(p) = - infty when p = 0 else pre(#p)
						%(degree_def_Poly)%

          . p + 0 = p				%(add_zero1_Poly)%
	  . 0 + p = 0				%(add_zero2_Poly)%
          . (a ::: p) + (b ::: q) = (a + b) ::: (p + q)
						%(add_cons_Poly)%

          . p * 0 = 0				%(mult_zero1_Poly)%
	  . 0 * p = 0				%(mult_zero2_Poly)%
          . (a ::: p) * (b ::: q) = ((a * b) ::: ((b * p) + (a * q))) + 
		(0 ::: (0 ::: (p * q)))             %(mult_cons_Poly)%
     }
end





view 
     CRing_in_CPolynomial [CommutativeRing] given Int:
     CommutativeRing to ConstructPolynomial [CommutativeRing] =
     sort Elem |-> Poly[Elem]
end

spec
     Polynomial [CommutativeRing] given Int =
     ExtCommutativeRing [view CRing_in_CPolynomial [CommutativeRing]] 
then
     %implies
     forall p,q:Poly[Elem]
     . degree(p) <= degree(q) => degree(p + q) <= degree(q)
						%(degree_add_Poly)%
     . degree(p * q) <= degree(p) + degree(q)
						%(degree_mult1_Poly)%
     . hasNoZeroDivisors => degree(p * q) = degree(p) + degree(q)
						%(degree_mult2_Poly)%
end

view
     EuclidianRing_in_Polynomial [Field] given Int:
     EuclidianRing to 
	{Polynomial [Field]
	  then
	     op natdegree: Poly[Elem] ->? Nat
	     forall p: Poly[Elem]
	     . natdegree(p) = degree(p) as Nat	%(natdegree_def)%
	} =
     sorts
          Elem |-> Poly[Elem],
     ops
          delta |-> natdegree
end


spec RichFactorialRing = 
     ExtFactorialRing [FactorialRing]
end

view
     FactorialRing_in_RichEuclidianRing:
     FactorialRing to RichEuclidianRing
end





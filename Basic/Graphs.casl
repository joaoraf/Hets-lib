library Basic/Graphs
version 0.95
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 19.06.02

%left_assoc __intersection__  %[ Should go to StructuredDatatypes ]%

from Basic/StructuredDatatypes get FiniteSet, FiniteMap


%[ Labelled (un)directed graphs; labels of nodes must be unique
   Labels of edges between to given nodes must be unique as well
   If necessary, take a product sort (e.g. OldLabel x Int) as labels
   If you do not need labels, instantiate them with a singleton sort ]%

spec AbstractGraph[sort NodeLabel][sort EdgeLabel] =
  generated type Edge ::= edge(source,target:NodeLabel; label:EdgeLabel)
  %% Equality on edges is left unspecified
then
  FiniteSet[sort NodeLabel fit Elem |-> NodeLabel]
and
  FiniteSet[sort Edge fit Elem |-> Edge]
then
  generated type Graph ::= 
     make_graph (nodes : FinSet[NodeLabel];
                 edges : FinSet[Edge])?
  vars nds:FinSet[NodeLabel];
       eds:FinSet[Edge]; 
       g,g':Graph
  . def make_graph(nds,eds) <=> 
    forall e:Edge . e eps eds => source(e) eps nds /\ target(e) eps nds
  . g=g' <=> nodes(g)=nodes(g') /\ edges(g)=edges(g')

then %def
  op remove_node : NodeLabel * FinSet[Edge] -> FinSet[Edge]
  forall n,n1,n2:NodeLabel; e:EdgeLabel; eds:FinSet[Edge]
  . edge(n1,n2,e) eps remove_node(n,eds) <=> edge(n1,n2,e) eps eds /\ not n=n1 /\ not n=n2

  ops add_node (n:NodeLabel; g:Graph) : Graph =
        make_graph(nodes(g)+n, edges(g));
       
      add_edge (e:EdgeLabel; n1,n2:NodeLabel; g:Graph) :? Graph =
        make_graph(nodes(g)+n1+n2, edges(g)+edge(n1,n2,e));
       
      remove_node(n:NodeLabel; g:Graph) : Graph =
        make_graph(nodes(g)-n,
                   remove_node(n,edges(g)));
      
      remove_edge(e:Edge; g:Graph) : Graph =
        make_graph(nodes(g), edges(g)-e)
        
end

spec DirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel
  . edge(s1,t1,e1)=edge(s2,t2,e2) <=> e1=e2 /\ s1=s2 /\ t1=t2 
end

spec UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel
  . edge(s1,t1,e1)=edge(s2,t2,e2) <=> 
    e1=e2 /\ ((s1=s2 /\ t1=t2) \/ (s1=t2 /\ s2=t1))
end


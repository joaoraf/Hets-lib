library Basic/Graphs
version 0.95
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 19.06.02

%left_assoc __intersection__  %[ Should go to StructuredDatatypes ]%

from Basic/StructuredDatatypes get FiniteSet, FiniteMap


%[ Labelled (un)directed graphs; labels of nodes must be unique
   Labels of edges between to given nodes must be unique as well
   If necessary, take a product sort (e.g. OldLabel x Int) as labels
   If you do not need labels, instantiate them with a singleton sort ]%

spec AbstractGraph[sort NodeLabel][sort EdgeLabel] =
  generated type Graph ::= emptyGraph
                         | addnode(node :? NodeLabel; graph :? Graph)
                         | addedge(source,target :? NodeLabel; edge :? EdgeLabel; graph :? Graph)
  preds __eps__ : NodeLabel * Graph;
        has_edge : NodeLabel * NodeLabel * EdgeLabel * Graph
  forall n,n1,s,t,s1,t1,s2,t2:NodeLabel; e,e1,e2:EdgeLabel; g,g':Graph
  . not n eps emptyGraph
  . n eps addnode(n1,g) <=> n=n1 \/ n eps g
  . n eps addedge(s,t,e,g) <=> n=s \/ n=t \/ n eps g
  . not has_edge(s,t,e,emptyGraph)
  . has_edge(s,t,e,addnode(n,g)) <=> has_edge(s,t,e,g)
  %% has_edge is left underspecified
  %% This allows a refinement into both directed and undirected graphs
  . has_edge(s1,t1,e1,addedge(s1,t1,e1,g))
  . has_edge(s1,t1,e1,addedge(s2,t2,e2,g)) if has_edge(s1,t1,e1,g)

  . g=g' <=> (forall n:NodeLabel . n eps g <=> n eps g')
         /\ (forall s,t:NodeLabel; e:EdgeLabel . has_edge(s,t,e,g) <=> has_edge(s,t,e,g'))
end

%[
then %def

  ops  remove_node(n:NodeLabel; g:Graph) : Graph =
        make_graph(nodes(g)-n,
                   remove_node(n,edges(g)));
      
      remove_edge(e:Edge; g:Graph) : Graph =
        make_graph(nodes(g), edges(g)-e)
        
end
]%

spec DirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . has_edge(s1,t1,e1,addedge(s2,t2,e2,g)) <=> (s1=s2 /\ t1=t2 /\ e1=e2) \/ has_edge(s1,t1,e1,g)
end

spec UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . has_edge(s1,t1,e1,addedge(s2,t2,e2,g)) <=> 
    (s1=s2 /\ t1=t2 /\ e1=e2) \/ 
    (s1=t2 /\ t1=s2 /\ e1=e2) \/ 
    has_edge(s1,t1,e1,g)
end

spec SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  DirectedGraph[sort NodeLabel][sort EdgeLabel]
then
  sort SymmetricGraph =
       {g:Graph . forall s,t:NodeLabel; e:EdgeLabel . 
                    has_edge(s,t,e,g) <=> has_edge(t,s,e,g)}
  type SymmetricGraph ::= emptyGraph
                         | addnode(node :? NodeLabel; graph :? SymmetricGraph)
                         | addedge_sym(source,target :? NodeLabel; edge :? EdgeLabel; graph :? SymmetricGraph)
  preds __eps__ : NodeLabel * SymmetricGraph;
        has_edge : NodeLabel * NodeLabel * EdgeLabel * SymmetricGraph
  forall s,t:NodeLabel; e:EdgeLabel; g:SymmetricGraph
  . addedge_sym(s,t,e,g) = addedge(s,t,e,addedge(t,s,e,g)) as SymmetricGraph
  %% the other operations and predicates are determined by the overloading relations
end

view Symmetric_as_Undirected[sort NodeLabel][sort EdgeLabel] : 
     UndirectedGraph[sort NodeLabel][sort EdgeLabel]
  to SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  sort Graph |-> SymmetricGraph,
  op addedge |-> addedge_sym
end


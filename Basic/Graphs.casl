library Basic/Graphs
version 0.9
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% Corresponding author: Till Mossakowski, till@tzi.de
%% date: 17.09.02

%left_assoc __intersection__  %[ Should go to StructuredDatatypes ]%

from Basic/StructuredDatatypes get FiniteSet, FiniteMap, List


%[ We treat labelled directed and undirected graphs uniformly, thus
   avoiding duplicate definitions. Later, we refine this into directed
   and undirected graphs.
   Labels of nodes must be unique.
   Labels of edges between two given nodes must be unique as well.
   If you needed multiple edges with the same label, take a product 
   sort (e.g. OldLabel x Int) as labels. If you do not need labels, 
   instantiate them with a singleton sort (cf. SimpleAbstractGraph 
   below). ]%

spec AbstractGraph[sort NodeLabel][sort EdgeLabel] =
  generated type Graph ::= emptyGraph
                         | addNode(NodeLabel; Graph)
                         | addEdge(NodeLabel; NodeLabel; 
                                   EdgeLabel; Graph)
  preds __isIn__ : NodeLabel * Graph;
        __::__-->__ isIn __ : EdgeLabel * NodeLabel * NodeLabel * Graph
  forall n,n1,s,t,s1,t1,s2,t2:NodeLabel; e,e1,e2:EdgeLabel; g,g':Graph
  . not n isIn emptyGraph                              %(isIn_emptyGraph)%
  . n isIn addNode(n1,g) <=> n=n1 \/ n isIn g              %(isIn_addNode)%
  . n isIn addEdge(s,t,e,g) <=> n=s \/ n=t \/ n isIn g     %(isIn_addEdge)%
  . not e::s-->t isIn emptyGraph                     %(isIn_emptyGraph)%
  . e::s-->t isIn addNode(n,g) <=> e::s-->t isIn g      %(isIn_addNode)%

  %% __::__-->__ isIn __ is left underspecified
  %% This allows a refinement into both directed and undirected graphs
  . e1::s1-->t1 isIn addEdge(s1,t1,e1,g)               %(isIn_addEdge1)%
  . e::s-->t isIn addEdge(s2,t2,e2,g) if e::s-->t isIn g
                                                       %(isIn_addEdge2)%

  . g=g' <=> (forall n:NodeLabel . n isIn g <=> n isIn g')
         /\ (forall s,t:NodeLabel; e:EdgeLabel .
                 e::s-->t isIn g <=> e::s-->t isIn g') %(extensionality)%
end

spec RichAbstractGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel] 
then %def
  ops removeNode : NodeLabel * Graph -> Graph;
      removeEdge : EdgeLabel * Graph -> Graph

  forall n,n1,n2:NodeLabel; e,e1,e2:EdgeLabel; g,g':Graph
  . removeNode(n,emptyGraph) = emptyGraph      %(removeNode_emtpyGraph)%
  . removeNode(n,addNode(n1,g)) =
      removeNode(n,g) when n=n1
      else addNode(n1,removeNode(n,g))            %(removeNode_addNode)%
  . removeNode(n,addEdge(n1,n2,e,g)) =
      removeNode(n,g) when n=n1 \/ n=n2
      else addEdge(n1,n2,e,removeNode(n,g))       %(removeNode_addEdge)%

  . removeEdge(e,emptyGraph) = emptyGraph      %(removeEdge_emtpyGraph)%
  . removeEdge(e,addNode(n1,g)) =
      addNode(n1,removeEdge(e,g))                 %(removeEdge_addNode)%
  . removeEdge(e,addEdge(n1,n2,e1,g)) =
      removeEdge(e,g) when e=e1
      else addEdge(n1,n2,e1,removeEdge(e,g))      %(removeEdge_addEdge)%

  pred symmetric(g:Graph) <=> 
    forall n1,n2:NodeLabel; e:EdgeLabel .
        e::n1-->n2 isIn g => 
           exists e':EdgeLabel . e'::n2-->n1 isIn g    %(symmetric_def)%

  pred transitive(g:Graph) <=>
    forall n1,n2,n3:NodeLabel; e1,e2:EdgeLabel . 
        e1::n1-->n2 isIn g /\ e2::n2-->n3 isIn g =>
           exists e3:EdgeLabel . e2::n1-->n3 isIn g   %(transitive_def)%

  pred loopFree(g:Graph) <=>
     not (exists n:NodeLabel; e:EdgeLabel . e::n-->n isIn g)
                                                        %(loopFree_def)%

  pred __subgraphOf__ (g1,g2:Graph) <=>
    (forall n:NodeLabel . n isIn g1 => n isIn g2) /\
    (forall n1,n2:NodeLabel; e:EdgeLabel .
          e::n1-->n2 isIn g1 => e::n1-->n2 isIn g2)  %(subgraphOf_def)%

  pred complete(g:Graph) <=>
    forall n1,n2:NodeLabel . n1 isIn g /\ n2 isIn g =>
         exists e:EdgeLabel . e::n1-->n2 isIn g             %(complete)%

  pred __cliqueOf__ (g1,g2:Graph) <=>
    g1 subgraphOf g2 /\ complete(g1)                    %(cliqueOf_def)%

  pred __maxCliqueOf__ (g1,g2:Graph) <=>
    g1 cliqueOf g2
    /\ forall g3:Graph . 
        g1 subgraphOf g3 /\ g3 cliqueOf g2 => g1=g3
                                                    %(max_cliqueOf_def)%
end


spec AbstractGraphToSet[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel] 
and
  FiniteMap[sort EdgeLabel][sort NodeLabel]
then %def
  ops sourceMap, targetMap : Graph -> FiniteMap[EdgeLabdel][NodeLabel]
  forall g:Graph; n:NodeLabel; e:EdgeLabel
  . [n/e] eps sourceMap(g) <=> exists n':NodeLabel . e::n-->n' isIn g 
  . [n/e] eps targetMap(g) <=> exists n':NodeLabel . e::n'-->n isIn g 
end

spec DirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . e1::s1-->t1 isIn addEdge(s2,t2,e2,g) <=>
      (s1=s2 /\ t1=t2 /\ e1=e2) \/ e1::s1-->t1 isIn g  %(isIn_Directed)%
end

spec UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . e1::s1-->t1 isIn addEdge(s2,t2,e2,g) <=> 
    (s1=s2 /\ t1=t2 /\ e1=e2) \/ 
    (s1=t2 /\ t1=s2 /\ e1=e2) \/ 
    e1::s1-->t1 isIn g                               %(isIn_Undirected)%
end

%% the subsort of symmetric graphs
spec SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  DirectedGraph[sort NodeLabel][sort EdgeLabel]
then
  sort SymmetricGraph =                           %(SymmetricGraph_def)%
       {g:Graph . forall s,t:NodeLabel; e:EdgeLabel . 
                    e::s-->t isIn g <=> e::t-->s isIn g}
  type SymmetricGraph ::= emptyGraph
            | addNode(node :? NodeLabel; graph :? SymmetricGraph)
            | addEdgeSym(source,target :? NodeLabel; 
                         edge :? EdgeLabel; graph :? SymmetricGraph)
  preds __isIn__ : NodeLabel * SymmetricGraph;
        __::__-->__ isIn __ : 
                   EdgeLabel * NodeLabel * NodeLabel * SymmetricGraph
  forall s,t:NodeLabel; e:EdgeLabel; g:SymmetricGraph
  . addEdgeSym(s,t,e,g) = 
      addEdge(s,t,e,addEdge(t,s,e,g)) as SymmetricGraph  %(addEdge_def)%
  %% the other operations and predicates are determined
  %% by the overloading relations
end

%% symmetric graphs are the same as undirected graphs
view Symmetric_as_Undirected[sort NodeLabel][sort EdgeLabel] : 
     UndirectedGraph[sort NodeLabel][sort EdgeLabel]
  to SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  sort Graph |-> SymmetricGraph,
  op addEdge |-> addEdgeSym
end

view Undirected_as_Symmetric[sort NodeLabel][sort EdgeLabel] : 
  { SymmetricGraph[sort NodeLabel][sort EdgeLabel] hide Graph } to
  UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  sort SymmetricGraph |-> Graph,
  op addEdgeSym |-> addEdge
end


spec SimpleAbstractGraph[sort NodeLabel] =
  free type Unit ::= *
then
  AbstractGraph[sort NodeLabel][sort Unit]
then
  pred __-->__isIn__ : NodeLabel * NodeLabel * Graph
  forall n1,n2:NodeLabel; g:Graph
  . n1-->n2 isIn g <=> * :: n1-->n2 isIn g              %(isIn_def2)%
end

spec LoopFreeAbstractGraph[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall g:Graph . loopFree(g)                           %(loopFree)%
end

spec SymmetricClosure[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  op sc : Graph -> Graph
  forall n,n1,n2:NodeLabel; e:EdgeLabel; g:Graph
  . n isIn sc(g) <=> n isIn g                            %(sc_def_1)%
  . e::n1-->n2 isIn sc(g) <=> 
      (e::n1-->n2 isIn g \/ e::n2-->n1 isIn g)           %(sc_def_2)%
end

spec TransitiveClosure[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
and
  List[sort EdgeLabel fit Elem |-> EdgeLabel]
and
  SymmetricClosure[sort NodeLabel][sort List[EdgeLabel]]
  with Graph |-> PathGraph
then
  ops tc,stc : Graph -> PathGraph
  preds __pathSubgraphOf__ : Graph * PathGraph;
        pathTransitive : PathGraph
  forall n,n1,n2:NodeLabel; e:EdgeLabel; g:Graph; g':PathGraph
  . g pathSubgraphOf g' <=>
      (forall n:NodeLabel . n isIn g <=> n isIn g') /\
      (forall n1,n2:NodeLabel; e:EdgeLabel .
          e::n1-->n2 isIn g <=> (e::[])::n1-->n2 isIn g') 
                                                %(pathSubgraphOf_def)%
  . pathTransitive(g') <=>
      forall n1,n2,n3:NodeLabel; e1,e2:List[EdgeLabel] . 
        e1::n1-->n2 isIn g' /\ e2::n2-->n3 isIn g' =>
           (e1++e2)::n1-->n3 isIn g'            %(pathTransitive_def)%

  . pathTransitive(tc(g))                                  %(tc_def1)%
  . g pathSubgraphOf tc(g)                                 %(tc_def2)%
  . g pathSubgraphOf g' /\ pathTransitive(g') =>
      tc(g) subgraphOf g'                                  %(tc_def3)%

  . stc(g) = sc(tc(g))                                     %(stc_def)%
end

spec GraphHomomorphism[sort N1][sort E1][sort N2][sort E2] =
  AbstractGraph[sort N1][sort E1] with Graph |-> Graph1
and
  AbstractGraph[sort N2][sort E2] with Graph |-> Graph2
and
  FiniteMap[sort N1 fit S |-> N1][sort N2 fit T |-> N2]
and
  FiniteMap[sort E1 fit S |-> E1][sort E2 fit T |-> E2]
then
  free type PreHom ::= preHom(source : Graph1;
                              target : Graph2;
                              nodeMap : FiniteMap[N1,N2];
                              edgeMap : FiniteMap[E1,E2])
  sort Hom =                                               %(Hom_def)% 
   {h:PreHom .
      forall n,n':N1; e:E1 . e::n-->n' isIn source(h) =>
       eval(e,edgeMap(h))::eval(n,nodeMap(h))-->eval(n',nodeMap(h))
                                                    isIn target(h)   }
end

spec Minor[sort N1][sort E1][sort N2][sort E2] =
  TransitiveClosure[sort N2][sort E2] with Graph |-> Graph2
and
  GraphHomomorphism[sort N1][sort E1][sort N2][sort List[E2]]
  with Graph2 |-> PathGraph 
then
  pred __minorOf__(g1:Graph1; g2:Graph2) <=>           %(minorOf_def)%
    exists h:Hom . source(h)=g1 /\ target(h)=stc(g2)
end

spec K5 =
  free type Five ::= 1 | 2 | 3 | 4 | 5
then
  SimpleAbstractGraph[sort Five] with Graph |-> K5
then
  op k5 : K5
  forall n,n1,n2 : Five
  . n isIn k5                                             %(k5_def_1)%
  . n1 --> n2 isIn k5                                     %(k5_def_2)%
end

spec K3_3 =
  free type Three ::= 1 | 2 | 3
  free type Three2 ::= left(Three) | right(Three)
then
  SimpleAbstractGraph[sort Three2] with Graph |-> K3_3
then
  op k3_3 : K3_3
  forall n,n1,n2 : Three
  . left(n) isIn k3_3                                   %(k3_3_def_1)%
  . right(n) isIn k3_3                                  %(k3_3_def_2)%
  . left(n1) --> right(n2) isIn k3_3                    %(k3_3_def_3)%
end

%% planar graphs defined using the Kuratowski characterization
spec Planar[sort NodeLabel][sort EdgeLabel] =
  K5 and K3_3
and
  Minor[sort Five][sort Unit][sort NodeLabel][sort EdgeLabel]
  with Graph1 |-> K5, Graph2 |-> Graph
and
  Minor[sort Three2][sort Unit][sort NodeLabel][sort EdgeLabel]
  with Graph1 |-> K3_3, Graph2 |-> Graph
then
  pred planar(g:Graph) <=> not k5 minorOf g /\ not k3_3 minorOf g
                                                        %(planar_def)%
end


library Basic/Graphs
version 0.95
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% Corresponding author: Till Mossakowski, till@tzi.de
%% date: 17.09.02

%left_assoc __intersection__  %[ Should go to StructuredDatatypes ]%
%%list [__], [], __::__

from Basic/StructuredDatatypes get FiniteSet, FiniteMap, List


%[ Labelled (un)directed graphs; labels of nodes must be unique
   Labels of edges between to given nodes must be unique as well
   If necessary, take a product sort (e.g. OldLabel x Int) as labels
   If you do not need labels, instantiate them with a singleton sort ]%

spec AbstractGraph[sort NodeLabel][sort EdgeLabel] =
  generated type Graph ::= emptyGraph
                         | addNode(node :? NodeLabel; graph :? Graph)
                         | addEdge(source,target :? NodeLabel; 
                                   edge :? EdgeLabel; graph :? Graph)
  preds __eps__ : NodeLabel * Graph;
        __::__-->__ isin __ : EdgeLabel * NodeLabel * NodeLabel * Graph
  forall n,n1,s,t,s1,t1,s2,t2:NodeLabel; e,e1,e2:EdgeLabel; g,g':Graph
  . not n eps emptyGraph                              %(eps_emptyGraph)%
  . n eps addNode(n1,g) <=> n=n1 \/ n eps g              %(eps_addNode)%
  . n eps addEdge(s,t,e,g) <=> n=s \/ n=t \/ n eps g     %(eps_addEdge)%
  . not e::s-->t isin emptyGraph                     %(isin_emptyGraph)%
  . e::s-->t isin addNode(n,g) <=> e::s-->t isin g      %(isin_addNode)%
  %% __::__-->__ isin __ is left underspecified
  %% This allows a refinement into both directed and undirected graphs
  . e1::s1-->t1 isin addEdge(s1,t1,e1,g)               %(isin_addEdge1)%
  . e::s-->t isin addEdge(s2,t2,e2,g) if e::s-->t isin g
                                                       %(isin_addEdge2)%

  . g=g' <=> (forall n:NodeLabel . n eps g <=> n eps g')
         /\ (forall s,t:NodeLabel; e:EdgeLabel .
                 e::s-->t isin g <=> e::s-->t isin g') %(extensionality)%
end

spec RichAbstractGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel] 
then %def
  ops removeNode : NodeLabel * Graph -> Graph;
      removeEdge : EdgeLabel * Graph -> Graph;
  preds symmetric, transitive, loopFree : Graph;
        __subgraphOf__ : Graph * Graph
  forall n,n1,n2:NodeLabel; e,e1,e2:EdgeLabel; g,g':Graph
  . removeNode(n,emptyGraph) = emptyGraph      %(removeNode_emtpyGraph)%
  . removeNode(n,addNode(n1,g)) =
      removeNode(n,g) when n=n1
      else addNode(n1,removeNode(n,g))            %(removeNode_addNode)%
  . removeNode(n,addEdge(n1,n2,e,g)) =
      removeNode(n,g) when n=n1 \/ n=n2
      else addEdge(n1,n2,e,removeNode(n,g))       %(removeNode_addEdge)%

  . removeEdge(e,emptyGraph) = emptyGraph      %(removeEdge_emtpyGraph)%
  . removeEdge(e,addNode(n1,g)) =
      addNode(n1,removeEdge(e,g))                 %(removeEdge_addNode)%
  . removeEdge(e,addEdge(n1,n2,e1,g)) =
      removeEdge(e,g) when e=e1
      else addEdge(n1,n2,e1,removeEdge(e,g))      %(removeEdge_addEdge)%

  . symmetric(g) <=> 
      forall n1,n2:NodeLabel; e:EdgeLabel .
        e::n1-->n2 isin g => 
           exists e':EdgeLabel . e'::n2-->n1 isin g    %(symmetric_def)%

  . transitive(g) <=>
      forall n1,n2,n3:NodeLabel; e1,e2:EdgeLabel . 
        e1::n1-->n2 isin g /\ e2::n2-->n3 isin g =>
           exists e3:EdgeLabel . e2::n1-->n3 isin g   %(transitive_def)%

  . loopFree(g) <=>
       not (exists n:NodeLabel; e:EdgeLabel .
             e::n-->n isin g)                           %(loopFree_def)%

  . g subgraphOf g' <=>
      (forall n:NodeLabel . n eps g <=> n eps g') /\
      (forall n1,n2:NodeLabel; e:EdgeLabel .
          e::n1-->n2 isin g <=> e::n1-->n2 isin g')   %(subgraphOf_def)%
end


spec DirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . e1::s1-->t1 isin addEdge(s2,t2,e2,g) <=>
      (s1=s2 /\ t1=t2 /\ e1=e2) \/ e1::s1-->t1 isin g  %(isin_Directed)%
end

spec UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  AbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall s1,s2,t1,t2:NodeLabel; e1,e2:EdgeLabel; g:Graph
  . e1::s1-->t1 isin addEdge(s2,t2,e2,g) <=> 
    (s1=s2 /\ t1=t2 /\ e1=e2) \/ 
    (s1=t2 /\ t1=s2 /\ e1=e2) \/ 
    e1::s1-->t1 isin g                               %(isin_Undirected)%
end

%% the subsort of symmetric graphs
spec SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  DirectedGraph[sort NodeLabel][sort EdgeLabel]
then
  sort SymmetricGraph =                           %(SymmetricGraph_def)%
       {g:Graph . forall s,t:NodeLabel; e:EdgeLabel . 
                    e::s-->t isin g <=> e::t-->s isin g}
  type SymmetricGraph ::= emptyGraph
            | addNode(node :? NodeLabel; graph :? SymmetricGraph)
            | addEdgeSym(source,target :? NodeLabel; 
                         edge :? EdgeLabel; graph :? SymmetricGraph)
  preds __eps__ : NodeLabel * SymmetricGraph;
        __::__-->__ isin __ : 
                   EdgeLabel * NodeLabel * NodeLabel * SymmetricGraph
  forall s,t:NodeLabel; e:EdgeLabel; g:SymmetricGraph
  . addEdgeSym(s,t,e,g) = 
      addEdge(s,t,e,addEdge(t,s,e,g)) as SymmetricGraph  %(addEdge_def)%
  %% the other operations and predicates are determined
  %% by the overloading relations
end

%% symmetric graphs are the same as undirected graphs
view Symmetric_as_Undirected[sort NodeLabel][sort EdgeLabel] : 
     UndirectedGraph[sort NodeLabel][sort EdgeLabel]
  to SymmetricGraph[sort NodeLabel][sort EdgeLabel] =
  sort Graph |-> SymmetricGraph,
  op addEdge |-> addEdgeSym
end

view Undirected_as_Symmetric[sort NodeLabel][sort EdgeLabel] : 
  { SymmetricGraph[sort NodeLabel][sort EdgeLabel] hide Graph } to
  UndirectedGraph[sort NodeLabel][sort EdgeLabel] =
  sort SymmetricGraph |-> Graph,
  op addEdgeSym |-> addEdge
end


spec SimpleAbstractGraph[sort NodeLabel] =
  free type Unit ::= *
then
  AbstractGraph[sort NodeLabel][sort Unit]
then
  pred __-->__isin__ : NodeLabel * NodeLabel * Graph
  forall n1,n2:NodeLabel; g:Graph
  . n1-->n2 isin g <=> * :: n1-->n2 isin g
end

spec LoopFreeAbstractGraph[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  forall g:Graph . loopFree(g)
end

spec SymmetricClosure[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
then
  op sc : Graph -> Graph
  forall n,n1,n2:NodeLabel; e:EdgeLabel; g:Graph
  . n eps sc(g) <=> n eps g
  . e::n1-->n2 isin sc(g) <=> (e::n1-->n2 isin g \/ e::n2-->n1 isin g)
end

spec TransitiveClosure[sort NodeLabel][sort EdgeLabel] =
  RichAbstractGraph[sort NodeLabel][sort EdgeLabel]
and
  List[sort EdgeLabel fit Elem |-> EdgeLabel]
and
  SymmetricClosure[sort NodeLabel][sort List[EdgeLabel]]
  with Graph |-> PathGraph
then
  ops tc,stc : Graph -> PathGraph
  preds __pathSubgraphOf__ : Graph * PathGraph;
        pathTransitive : PathGraph
  forall n,n1,n2:NodeLabel; e:EdgeLabel; g:Graph; g':PathGraph
  . g pathSubgraphOf g' <=>
      (forall n:NodeLabel . n eps g <=> n eps g') /\
      (forall n1,n2:NodeLabel; e:EdgeLabel .
          e::n1-->n2 isin g <=> (e::[])::n1-->n2 isin g') 
                                                %(pathSubgraphOf_def)%
  . pathTransitive(g') <=>
      forall n1,n2,n3:NodeLabel; e1,e2:List[EdgeLabel] . 
        e1::n1-->n2 isin g' /\ e2::n2-->n3 isin g' =>
           (e1++e2)::n1-->n3 isin g'            %(pathTransitive_def)%

  . pathTransitive(tc(g))                                  %(tc_def1)%
  . g pathSubgraphOf tc(g)                                 %(tc_def2)%
  . g pathSubgraphOf g' /\ pathTransitive(g') =>
      tc(g) subgraphOf g'                                  %(tc_def3)%

  . stc(g) = sc(tc(g))                                     %(stc_def)%
end

spec GraphHomomorphism[sort N1][sort E1][sort N2][sort E2] =
  AbstractGraph[sort N1][sort E1] with Graph |-> Graph1
and
  AbstractGraph[sort N2][sort E2] with Graph |-> Graph2
and
  FiniteMap[sort N1 fit S |-> N1][sort N2 fit T |-> N2]
and
  FiniteMap[sort E1 fit S |-> E1][sort E2 fit T |-> E2]
then
  free type PreHom ::= preHom(source : Graph1;
                              target : Graph2;
                              nodeMap : FiniteMap[N1,N2];
                              edgeMap : FiniteMap[E1,E2])
  sort Hom = {h:PreHom .
        forall n,n':N1; e:E1 .
          e::n-->n' isin source(h) =>
            eval(e,edgeMap(h))::
              eval(n,nodeMap(h))-->eval(n',nodeMap(h))
                 isin target(h)   }
end

spec Minor[sort N1][sort E1][sort N2][sort E2] =
  TransitiveClosure[sort N2][sort E2] with Graph |-> Graph2
and
  GraphHomomorphism[sort N1][sort E1][sort N2][sort List[E2]]
  with Graph2 |-> PathGraph 
then
  pred __minorOf__ : Graph1 * Graph2
  forall g1:Graph1; g2:Graph2
  . g1 minorOf g2 <=> 
     exists h:Hom . source(h)=g1 /\ target(h)=stc(g2)
end

spec K5 =
  free type Five ::= 1 | 2 | 3 | 4 | 5
then
  SimpleAbstractGraph[sort Five] with Graph |-> K5
then
  op k5 : K5
  forall n,n1,n2 : Five
  . n eps k5
  . n1 --> n2 isin k5
end

spec K3_3 =
  free type Three ::= 1 | 2 | 3
  free type Three2 ::= left(Three) | right(Three)
then
  SimpleAbstractGraph[sort Three2] with Graph |-> K3_3
then
  op k3_3 : K3_3
  forall n,n1,n2 : Three
  . left(n) eps k3_3
  . right(n) eps k3_3
  . left(n1) --> right(n2) isin k3_3
end

%% planar graphs defined using the Kuratowski charaterization
spec Planar[sort NodeLabel][sort EdgeLabel] =
  K5 and K3_3
and
  Minor[sort Five][sort Unit][sort NodeLabel][sort EdgeLabel]
  with Graph1 |-> K5, Graph2 |-> Graph
and
  Minor[sort Three2][sort Unit][sort NodeLabel][sort EdgeLabel]
  with Graph1 |-> K3_3, Graph2 |-> Graph
then
  pred planar : Graph
  forall g:Graph
  . planar(g) <=> not k5 minorOf g /\ not k3_3 minorOf g
end
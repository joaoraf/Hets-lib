spec Int =
	generated type Int ::= __ - __(Nat;Nat)
	forall a,b,c,d: Nat
		.  a - b = c - d <=> a + c = b + d %(Int_equality)%
then
	sort  Nat < Int	
	forall a: Nat
		.  a = a - 0  %(Int_Nat_embedding)%

	preds   __ <= __, __ < __,
        	__ >= __, __ > __: Int * Int;
          	odd, even: Int

	ops	__ + __, __ * __: Int * Int -> Int %left assoc;
	        __ ^ __: Int * Int -> Int;
		- __: Int -> Int;
        	min, max: Int * Int ->  Int;
	        + __: Int -> Int;
        	abs: Int -> Nat;
		sign: Int -> Int;
	        __ - __: Int × Int -> Int;
	        __ /? __: Int × Int ->? Int;
	        __ div __,  __ quot __, __ rem __ :
						Int × Int ->? Int;
		__ mod __: Int × Int ->? Nat

     %prec { __ - __ , __ + __ } < 
           { __*__, __ /? __, __div__, __mod__, __ quot __, __rem__ }
     %prec { __*__, __ /? __, __div__, __mod__, __ quot __, __rem__ } 
           < { __ ^ __}
     %prec {+__} <> {__ ^ __}

	vars m,n,r,s: Int; a,b,c,d: Nat
		. (a - b) + (c - d) = (a + c) - (b + d) %(Int_add_def)%
		. - (a - b) = b - a  %(Int_neg_def)%
		. (a - b) * (c - d) = (a * c + b * d) - (b * c + a * d)
						%(Int_mult_def)%
				
		. m - n = m + ( - n ) %(Int_sub_def)%
		. + m = m  %(Int_pos_def)%

		. m <= n <=> n - m in Nat  %(Int_leq_def)%
     	 	. m >= n <=> n <= m  	%(Int_geq_def)%
     		. m < n <=> (m <= n /\ not (m=n)) %(Int_less_def)%
     		. m > n <=> m < n   	%(Int_greater_def)%

		. abs(m) = - m if m < 0   %(Int_abs_def)%
		. sign(m) = 0 when m = 0 else 1 when m > 0 else -1
					%(Int_sign_def)% 

		. (- 1) ^ a = 1 when even(a) else - 1
					%(Int_neg1_power_def)%
		. m ^ a = sign(m)^a * abs(m)^a %(Int_power_def)%

		. min(m,n) = m when m <= n else n %(Int_min_def)%
     		. max(m,n) = n when m <= n else m %(Int_max_def)%

		. even(m) <=> even(abs(m))  %(Int_even_def)%
		. odd(m) <=> not(even(m))   %(Int_odd_def)%

		. m /? n = sign(m) * sign(n) * (abs(m) /? abs(n))
					    %(Int_divide)%

		. m mod n < abs(n)  if not n = 0 %(Int_mod_range)%
		. m = (m div n) * n + (m mod n) if not n = 0
					%(Int_mod__div_def)%
		. not def m mod 0   %(Int_mod_zero)%
		. not def m div 0   %(Int_div_zero)%

		. m quot n = sign(m) * sign(n) * (abs(m) quot abs(n))
						%(Int_quot_def)%
		. m rem n = sign(m) * sign(n) * (abs(m) rem abs(n))
						%(Int_rem_def)%
				
		
 
then %implies
	generated type
		Int::= Nat | -__ (Nat)
	vars m,n,r: Int; a,b: Nat
		. def(a -? b) => a -? b = a - b %(Int_Nat_sub_compat)%
		. m = sign(m) * abs(m)  %(Int_abs_decomp)%
		. odd(m) <=> odd(abs(m)) %(Int_odd_alt)%
		. m /? n = r <=> not n = 0 /\ n * r = n %(Int_divide_dom1)%
	     	. def (m /? n) <=> m mod n = 0   %(Int_divide_dom2)%
		. def (m mod n) <=> not n = 0 %(Int_mod_dom)%
		. def (m div n) <=> not n = 0 %(Int_div_dom)%
		. def (m quot n) <=> not n = 0    %(Int_quot_dom)%
		. def (m rem n) <=> not n = 0     %(Int_rem_dom)%
		. m = (m quot n) * n + (m rem n) if not n = 0 
						%(Int_quot_rem)%
end
	

		
library Basic/LinearAlgebra
version 0.4
%% authors: M.Roggenbach, T.Mossakowski, L. Schröder
%% copyright: 15.03.2000

from
     Basic/Algebra_I version 0.4 get
     AbelianGroup, ExtAbelianGroup, Monoid, ExtMonoid,
     Group, ExtGroup, MonoidAction, ExtMonoidAction,
     GroupAction, ExtGroupAction, Ring, ExtRing,
     CommutativeRing, ExtCommutativeRing, Field, ExtField
from
     Basic/PreNumbers version 0.4 get PreNat, PreInt
from 
     Basic/Numbers version 0.4 get Int
from
     Basic/Algebra_II version 0.4 get
     Polynomial
from
     Basic/StructuredDatatypes version 0.4 get
     Array, FiniteMap

spec
     VectorSpace [Field]=
     MonoidAction [Monoid with ops e,__*__]
     with sort Space, op __*__
then
     closed{AbelianGroup with
          sort Elem |-> Space, ops e |-> 0, __ * __ |-> __ + __}
then
     vars
          x,y: Space; a,b: Elem
     .
          %[VS_distr1] (a + b) * x = a * x + b * x
     .
          %[VS_distr2] a * (x + y) = a * x + a * y
end

view AbelianGroup_in_VectorSpace [Field]:
     AbelianGroup to VectorSpace [Field] = 
     sort Elem |-> Space,
	  ops  e         |-> 0,
	        __ * __  |-> __ + __
end

view GroupAction_in_VectorSpace [Field]:
     GroupAction [Group] to
     {
	VectorSpace [ExtField [Field] reveal 
				sorts Elem, NonZero[Elem], 
				ops __ + __, __ * __, 0, e]
	then %def
	   op __ * __: NonZero[Elem] * Space -> Space} =
     
     sort Elem |-> NonZero[Elem]
end

view VectorSpace_in_Field [Field]:
     VectorSpace [Field] to Field =
     sort Space |-> Elem,
     op __ * __: Elem * Space -> Space |-> __ * __: Elem * Elem -> Elem
end
	
spec
     ExtVectorSpace [VectorSpace [Field]] given PreInt =
%def
     ExtField [Field]
and
     ExtAbelianGroup [view AbelianGroup_in_VectorSpace [Field]]
     with 
	ops
	  inv	  |-> -__,
	  __ ^ __ |-> __ times __, 
	  __ / __ |-> __ - __
and
     ExtMonoidAction [MonoidAction [Monoid]]
and
     {FiniteMap[sort Space][sort Elem]
          with sort FiniteMap[Space,Elem] |-> LC[Space,Elem]}
	  hide sorts FinSet[Space], FinSet[Elem],
		     NonEmptySet[Space], NonEmptySet[Elem]
then
     ExtGroupAction [view GroupAction_in_VectorSpace [Field]]
then
     op
          eval: LC[Space,Elem] -> Space
     pred
          isZero: LC[Space,Elem]
     vars
          x: Space; r: Elem; l:LC[Space,Elem]
     .
          %[eval_empty] eval([])=0
     .
          %[eval_add] [r/x]eps l => eval(l)=r*x+eval(l-[r/x])
     .
          %[isZero_def]
          isZero(l) <=> forall y: Space. (def eval(y,l) => eval(y,l)=0)
end

spec
     ConstructVSWithBase [Field][sort Base] given PreInt=
     ExtVectorSpace [VectorSpace [Field]]
then
     %cons
{
     sort
          Base < Space
then
     %def
     FiniteMap [sort Base][sort Elem]
         with sort FiniteMap[Base,Elem] |-> LC[Base,Elem]
then
     sort
          LC[Base,Elem]<LC[Space,Elem]
     var
          l:LC[Base,Elem]
     .
          %[generating] forall y:Space. exists k:LC[Base,Elem]. y=eval(k)
     .
          %[independent] eval(l)=0 => isZero(l)
}
end

spec
     VSWithBase [Field][sort Base]=
    { ConstructVSWithBase [Field][sort Base]}
          reveal sort Space, 
		 ops __ + __: Space * Space -> Space, 
	    	     __ * __: Elem * Space -> Space,
		     0	    : Space
end

spec
     ExtVSWithBase [VSWithBase [Field][sort Base]] given PreInt =
%def
     ExtVectorSpace [VSWithBase [Field][sort Base]]
and
     ConstructVSWithBase [Field][sort Base]
	with sort LC[Base,Elem]
then
     %implies
     vars
          l,k: LC[Base,Elem]
     .
          %[unique_representation] eval(l)=eval(k) => l=k
then
     %def
     op
          coefficients: Space -> LC[Base,Elem]
     var
          x:Space
     .
          %[coefficients_def] eval(coefficients(x))=x
then
     %implies
     var
          l:LC[Base,Elem]
     .
          %[recover_coefficients] coefficients(eval(l))=l
end

view
     VSWithBase_in_Field [Field]:
     VSWithBase [Field][sort Base] to
     {Field then sort One = {x: Elem. x = e} } =
     sorts
          Space |-> Elem, Base |-> One,
     op   __ * __: Elem * Space -> Space |->
		          __ * __: Elem * Elem -> Elem
end

view
     VSWithBase_in_VectorSpace [Field] given PreInt:
     {VSWithBase [Field][sort Base] hide sort Base} to
     VectorSpace [Field]
end

spec
     Algebra [Field]=
     VectorSpace [Field]
and
     closed
          {Ring with sort Elem |-> Space, 
		     ops __ + __, __ * __, 0, e}
then
     sort
          Elem < Space
     vars
          r: Elem; x, y: Space
     .
          %[Algebra_left_linear] (r * x) * y = r * (x * y)
     .
          %[Algebra_right_linear] x * (r * y) = r  * (x * y)
end

spec
     ExtAlgebra [Algebra [Field]] given PreInt =
%def
     ExtField [Field]
and
     ExtVectorSpace [VectorSpace [Field]]
and
     ExtRing [Algebra [Field] fit sort Elem |-> Space]
and
     Polynomial [Field]
then
     op
          eval: Poly[Elem] * Space -> Space
     vars
          a: Elem; p: Poly[Elem]; x: Space
     .
          %[eval_poly_0] eval(0,x) = 0
     .
          %[eval_poly_cons] eval(a:::p, x) = a + eval(p,x) * x
end

spec
     FreeVectorSpace [Field][sort Base]=
free
     {VectorSpace [Field]
     then
          op
               inject: Base -> Space
}
end

spec
     ExtFreeVectorSpace [Field][sort Base] given PreInt =
     ExtVectorSpace [FreeVectorSpace [Field][sort Base]]
end

view
     FreeVectorSpace_in_VSWithBase [Field] given PreInt:
     FreeVectorSpace [Field][sort Base] to
     {
          VSWithBase [Field][sort Base]
     then
          op
               inject: Base -> Space
          var
               x:Base
          .
               %[VSWB_inject_def] inject(x) = x
     }
end

view
     VSWithBase_in_FreeVectorSpace [Field][sort Base] given PreInt:
     VSWithBase [Field][sort Base] to
     {FreeVectorSpace [Field][sort Base] 
	then
	   %def
	   sort Base < Space
	   var x: Base
	   .
		%[FVS_embed_def] x = inject(x)
     }
end

spec
     VectorTuple [VectorSpace[Field]][op n: Pos] given PreInt =
%def
{
     {{Array [ops 1,n: Int fit ops min |-> 1, max |-> n][sort Space]
          with sorts
           Index |-> Index[n], Array[Space]}
	  hide sorts FinSet[Space], FinSet[Index[n]],
		     NonEmptySet[Space], NonEmptySet[Index[n]]}
     then
          sort
		Tuple[Space,n]={ x: Array[Space].
			 forall i: Index[n]. def x ! i }		
          ops
		__ ! __: Tuple[Space,n] * Index[n] -> Space;
                0:      Tuple[Space,n];
                __*__:  Elem * Tuple[Space,n] -> Tuple[Space,n];
                __+__:  Tuple[Space,n] * Tuple[Space,n] -> Tuple[Space,n];
                auxsum: Tuple[Space,n] * Index[n] -> Space;
                sum:    Tuple[Space,n] -> Space
          vars
               r: Elem; x,y: Tuple[Space,n]; i: Index[n]
          .
               %[Tuple_zero_def] 0 ! i = 0
          .
               %[Elem_times_Tuple_def] (r * x) ! i = r * (x ! i)
          .
               %[Tuple_plus_def] (x + y) ! i = (x ! i) + (y ! i)
          .
               %[Tuple_auxsum_1]
               auxsum(x, 1 as Index[n]) = x ! (1 as Index[n])
          .
               %[Tuple_auxsum_suc]
                auxsum(x, suc(i) as Index[n])=
                auxsum(x,i) + (x ! (suc(i) as Index[n]))
          .
               %[Tuple_sum_def] sum(x) = auxsum(x, n as Index[n])
}
     hide op auxsum
end

view
     VectorSpace_in_VectorTuple [VectorSpace [Field]]
     [op n:Pos] given PreInt:
     VectorSpace [Field] to
     VectorTuple [VectorSpace [Field]][op n:Pos]=
     sort
          Space |-> Tuple[Space,n]
end

spec
     ConstructVector [Field][op n: Pos] given PreInt =
%def
     {VectorTuple [view VectorSpace_in_Field [Field]][op n: Pos] with
          sort
                Tuple[Elem,n] |-> Vector[Elem,n], Index[n],
          ops
                0, __ * __, __ + __, sum} 
	with op __ ! __: Vector[Elem,n] * Index[n] -> Elem
then
     {
     ops
          <__ || __> : Vector[Elem,n] * Vector[Elem,n] -> Elem;
          prod:        Vector[Elem,n] -> Elem;
          unitVector:  Index[n] -> Vector[Elem,n];
          auxmult:     Vector[Elem,n] * Vector[Elem,n] -> Vector[Elem,n];
          auxprod:     Vector[Elem,n] * Index[n] -> Elem
     pred
          perp: Vector[Elem,n] * Vector[Elem,n]
     vars
          x, y: Vector[Elem,n]; i, j: Index[n]
     .
          %[Vector_auxmult_def] auxmult(x,y) ! i = (x ! i) * (y ! i)
     .
          %[Vector_times_def] <x || y> =sum(auxmult(x,y))
     .
          %[Vector_auxprod_1]
          auxprod(x, 1 as Index[n])=x ! (1 as Index[n])
     .
          %[Vector_auxprod_suc]
          auxprod(x, suc(i) as Index[n]) = auxprod(x,i) * (x ! (suc(i) as 
          Index[n]))
     .
          %[Vector_prod_def] prod(x) = auxprod(x, n as Index[n])
     .
          %[perp_def] perp(x,y) <=> ( <x || y> =0)
     .
          %[unitVector_def] unitVector(i) ! j = e when i = j else 0
     sort
           UnitVector[Elem,n]=
           {x: Vector[Elem,n] . exists i: Index[n]. x = unitVector(i)}
}
     hide ops auxmult,auxprod
then
     %implies
     vars
          x,y: Vector[Elem,n]
     .
          %[scalar_prod_comm] <x || y> = <y || x>
     .
          %[scalar_prod_pos] <x || x> = 0 => x = 0 
end

spec Vector [Field]=
     ConstructVector [Field][op n: Pos] 
     reveal sorts Vector[Elem,n], UnitVector[Elem,n],
	    ops __ + __: Vector[Elem,n] * Vector[Elem,n] -> Vector[Elem,n],
		__ * __: Elem * Vector[Elem,n] -> Vector[Elem,n],
		0 : Vector[Elem,n]
end

view VectorSpace_in_Vector [Field] given PreNat:
     VectorSpace [Field] to Vector [Field] =
     sort Space |-> Vector[Elem,n]
end

	   
view VSWithBase_in_Vector [Field] given PreNat:
     VSWithBase [Field][sort Base] to Vector [Field] =
     sorts
          Space |-> Vector[Elem,n],
          Base |-> UnitVector[Elem,n]
end

spec
     SymmetricGroup [op n: Pos] given PreInt =
%def
     Int reveal sort RUnit[Int], op __!
then
     sort
          Nat[n] = {i: Pos . i <= n}
then
     %def
     Array [ops 1, n: Int fit ops min |-> 1, max |-> n][sort Nat[n]]
          with sorts Array[Nat[n]], Index |-> Nat[n]
then
     %def
     sort
          Perm[n]={p: Array[Nat[n]] . forall i: Nat[n] . 
					exists j: Nat[n] . p ! j = i}
     ops
	   id: Perm[n];
           __  comp  __: Perm[n] * Perm[n] -> Perm[n];
           sign: Perm[n] -> RUnit[Int];
           nFac: Nat = n!
     var
          p,q: Perm[n]; i: Nat[n]
     .
	  %[Perm_id_def] id ! i = i
     .
          %[Perm_comp_def] (p comp q) ! i = p ! (q ! i)
     .
          %[Perm_sign_homomorphic] sign(p comp q) = sign(p) * sign(q)
     .
          %[Perm_sign_surjective] exists r: Perm[n]. sign(r)= minus(1)
then
     %cons
     sort
          PNat[n] = {i: Pos. i <= nFac}
     op
          perm: PNat[n] -> Perm[n]
     axiom
          forall p: Perm[n]. exists i: PNat[n]. perm(i) = p
end

view
     Group_in_SymmetricGroup [op n: Pos] given PreNat:
     Group to SymmetricGroup [op n: Pos]=
     sort
          Elem |-> Perm[n],
     op
          __ * __ |-> __ comp __,
	  e	  |-> id
end

spec
     Matrix [Field][op n: Pos] given PreInt=
%def
     VectorTuple [view VectorSpace_in_Vector [Field]]
          [op n: Pos]
     with
          sort Index[n], Tuple[Vector[Elem,n],n] |-> Matrix[Elem,n]
and 
     ConstructVector [Field][op n: Pos]
then
     ops
           transpose:  Matrix[Elem,n] -> Matrix[Elem,n];
           1:          Matrix[Elem,n];
           elementary: Index[n] * Index[n] -> Matrix[Elem,n];
           __ * __:    Matrix[Elem,n] * Vector[Elem,n] -> Vector[Elem,n];
           __ * __:    Matrix[Elem,n] * Matrix[Elem,n] -> Matrix[Elem,n];
           det:        Matrix[Elem,n] -> Elem
     vars
          a,b: Matrix[Elem,n]; x: Vector[Elem,n]; i,j,k: Index[n]
     .
          %[transpose_def] (transpose(a) ! i) ! j = (a ! j) ! i
     .
          %[Matrix_1_def] (1 ! i) ! j = e when i = j else 0
     .
          %[elementary_def]
          elementary(i,j) ! k = unitVector(j) when i = k else 0
     .
          %[Matrix_times_Vector_def](a * x) ! i = <transpose(a) ! i || x>
     .
          %[Matrix_mult_def] ((a * b) ! i) = a * (b ! i)
     sort
           ElemMatrix[Elem,n]=
           {x: Matrix[Elem,n]. exists i,j: Index[n]. x = elementary(i,j)}
    then
          local {
               SymmetricGroup [op n: Pos] with
                    sorts Perm[n], PNat[n], ops sign, perm, nFac
          then
               closed{ConstructVector [Field][op nFac: Pos]}
		with sort Vector[Elem,nFac]
          then
               sorts
                    Index[nFac]=PNat[n]
               ops
                    summands: Matrix[Elem,n] -> Vector[Elem,nFac];
                    factors:  Matrix[Elem,n] * PNat[n] -> Vector[Elem,n]
     }
     within {
     vars
          a: Matrix[Elem,n]; i: Index[n]; j: PNat[n]
     .
          %[Matrix_factors_def] factors(a,j) ! i=(a ! i) ! (perm(j) ! i)
     .
          %[Matrix_summands_def]
          summands(a) ! j=sign(perm(j)) * prod(factors(a,j))
     .
          %[Leibnitz] det(a)=sum(summands(a))
     } 
then
     %implies
vars
     a,b: Matrix[Elem,n]
.
     %[det_0] det(0) = 0
.
     %[det_vanishes]
     not det(a) = 0 <=> forall x: Vector[Elem,n]. (a * x = 0 => x = 0)
.
     %[det_1] det(1) = e
.
     %[det_mult] det(a * b) = det(a) * det(b)
end

view
     Algebra_in_Matrix [Field][op n: Pos] given PreNat:
     Algebra [Field] to Matrix [Field][op n: Pos]=
     sort
          Space |-> Matrix[Elem,n],
     op
	  e |-> 1
end

view
     VSWithBase_in_Matrix [Field][op n: Pos] given PreNat:
     VSWithBase [Field][sort Base] to Matrix [Field][op n: Pos]=
     sorts
           Space |-> Matrix[Elem,n],
           Base |-> ElemMatrix[Elem,n]
end

spec
     FreeAlgebra [Field] =
     free{Algebra [Field] then op X:Space}
end

spec
     ExtFreeAlgebra [FreeAlgebra[Field]] given PreInt=
     ExtAlgebra [FreeAlgebra[Field]]
end

view
     FreeAlgebra_in_Polynomial [Field] given PreInt:
     FreeAlgebra[Field] to Polynomial [Field]=
     sort
          Space |-> Poly[Elem]
end

view
     Polynomial_in_ExtFreeAlgebra [Field] given PreInt:
     {Polynomial [Field]
         reveal sorts Elem, Poly[Elem], ops X, __ + __, __ * __} 
     to ExtFreeAlgebra [FreeAlgebra [Field]]=
     sort
          Poly[Elem] |-> Space
end


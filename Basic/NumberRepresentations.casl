library Basic/NumberRepresentations
version 0.4
%% authors: M.Roggenbach, T.Mossakowski, Lutz Schröder
%% copyright: 15.3.00

from
     Basic/RelationsAndOrders version 0.4 get SigOrder
from
     Basic/Numbers version 0.4 get Nat, Rat
from
     Basic/StructuredDatatypes version 0.4 get
     List, Array, Pair

spec
     DecimalFraction =
     Rat
then
     %%   operations for a representation of Rat as a decimal fraction:
     ops
           __ ::: __ : Nat × Nat -> Rat;
           __ E __ :   Rat × Int -> Rat
     %prec { __ E __ } < { __ ::: __ }
     %floating
          __:::__, __E__
then
     local
     op
          tenPower: Nat -> Nat
     vars
          n,m: Nat
     %%   tenPower(n):= min { 10k | k in N \{0}, 10k > n }:
     .
          %[tenPower_digit] tenPower(n)=10 if n < 10
     .
          %[tenPower_number]
          tenPower(n)= 10 * tenPower(n div 10) if n >= 10
within
     vars
          r:Rat; n,m: Nat; p: Pos; i:Int
     %%   represent the decimal fraction n.m as rational:
     .
          %[decfract_def] n:::m = n + (m/tenPower(m))
     %%   introduce an exponent:
     .
          %[exponent_Rat] r E i = r* (10 ^ i)
end

spec
     ExactFixedPointNumber
     [
      op    L:List[Nat]
      axioms%[EFPN_Param_Cond1] forall n:Nat · n eps L => n>1;
            %[EFPN_Param_Cond2] not isEmpty(L)
     ]
given
     List [Nat fit sort Elem |-> Nat ]
=
     op
           m:Nat = #(L); %% number of moduli
           n:Nat = m+1 %% number of components of an efp-number
sort
     IndexModulus = {i : Nat · 1<=i /\ i<=m }
then
     Array
     [ op n:Int fit ops min |-> 1, max |-> n ]
     [ Nat fit sort Elem |-> Nat ]
     with
      Index      |->  IndexEfpn,
      Array[Nat] |->  ArrayEfpn
then
     sorts
           IndexModulus < IndexEfpn;
           IndexModulus, IndexEfpn <
           Nat;
           PosEfpn =                  {  A: ArrayEfpn . def A!(n as
                                         IndexModulus) /\
                                         forall i:IndexModulus . A!i < L!i
                                         };
           Sign =                     {  z : Int . z = 1 \/ z = -1 }
then
     Pair
     [ sort Sign fit S |-> Sign ]
     [ sort PosEfpn fit T |-> PosEfpn ]
     with ops
      first |-> sgn,
      second |-> number
then
     sort
           Efpn = {  p: Pair[Sign,PosEfpn] . not
                     (sgn(p)= -1 /\ forall i:IndexEfpn . number(p)!i=0 )
                  }
     preds
           isZero, isPos, isNeg: Efpn;
           __ < __ :             Efpn × Efpn;
     ops
           0, 1 :               Efpn;
           proj:                IndexEfpn × Efpn -> Nat;
           sgn:                 Efpn -> Sign; 
           make:                IndexEfpn × Nat ->? Efpn;
           -__:                 Efpn -> Efpn;
           __ + __, __ - __ :   Efpn × Efpn -> Efpn;
           __ * __:             Int × Efpn -> Efpn;
           __ * __:             Efpn × Int -> Efpn;
     %prec { __+__, __-__, __*__, __div__, __mod__ } < {__!__}
     then
          local
     {
          ops
                efpnToInt: Efpn -> Int;
                intToEfpn: Int -> Efpn;
                prod:      Nat ->? Int;
                           %% computes PRODi=1k L!(k asIndexModulus)

                sum:       Efpn × Nat ->? Int;
                           %% computes SUMi=1k zi * prod(i-1)

          vars
               z: Int; x:Efpn; i: Nat
          .
               %[prod_0] prod(0)= 1
          .
               %[prod_Pos]
                prod(i)= prod(i-?1) * L!(i as IndexModulus) if i>0
          .
               %[intToEfpn_def]
                intToEfpn(z)=x <=>
                (( z >= 0 => sgn(x)=1 ) /\
                (z < 0 => sgn(x)= -1 ) /\
                ( number(x)!(n as IndexEfpn) = abs(z) div prod(m) ) /\
                ( (forall k:IndexModulus .
                ( number(x)!k = (abs(z) div prod(k-?1)) mod L!k)
                )))
          .
               %[sum_0] sum(x,0) = 0
          .
               %[sum_Pos]
                sum(x,i) = sum(x,i-?1) +
                           (number(x)!(i as IndexEfpn) * prod(i-?1))
                if i>0
          .
               %[efpnToInt_def]
               efpnToInt(x)= sgn(x) * sum(x,n)
     then
          %implies
          vars
               z: Int; x:Efpn; i: Nat
          .
               %[prod_domain] def prod(i) <=> i <= m
          .
               %[sum_domain] def sum(x,i) <=> i <= n
          .
               %[EfpnInt_bij1] efpnToInt(intToEfpn(z)) = z
          .
               %[EfpnInt_bij2] intToEfpn(efpnToInt(x)) = x
     }
     within
          vars
               x,y:Efpn
          .
               %[isZeroEfpn_def] isZero(x) <=> efpnToInt(x) = 0
          .
               %[isPosEfpn_def] isPos(x) <=> efpnToInt(x) > 0
          .
               %[isNegEfpn_def] isNeg(x) <=> efpnToInt(x) < 0
          .
               %[isLessEfpn_def] x < y <=> efpnToInt(x) < efpnToInt(y)
          axioms
                %[ZeroEfpn_def] 0 = efpnToInt(0);
                %[OneEfpn_def] 1 = efpnToInt(1)
          vars
               x,y:Efpn; i:IndexEfpn; k:Nat; z:Int
          .
               %[proj_def] proj(i,x) = number(x)!i
          .
               %[makeEfpn_def]
                make(i,k)=x <=> ( sgn(x)=1 /\ forall l:IndexEfpn .
                                (( not i=l => proj(i,x)=0) /\
                                ( i=l => proj(i,x)=k)))
          .
               %[MinusEpfn_def] - x = intToEfpn( - efpnToInt(x))
          .
               %[AddEfpn_def] x + y = intToEfpn( efpnToInt(x) + efpnToInt(y)
               )
          .
               %[SubEfpn_def] x - y = intToEfpn( efpnToInt(x) - efpnToInt(y)
               )
          .
               %[MultEfpn_def1] z * x = intToEfpn( z * efpnToInt(x) )
          .
               %[MultEfpn_def2] x * z = z * x
     then
          %implies
          vars
               i:IndexEfpn; k:Nat; z:Int
          .
               %[makeEfpn_domain]
               def make(i,k) <=>
               i=n \/ (i<n => k < L!(i as IndexModulus))
then
     SigOrder
     with
      sort Elem |-> Efpn,
      preds __<__, __>__, __ <= __, __ >= __
end


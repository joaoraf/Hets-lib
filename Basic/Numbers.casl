library Basic/Numbers
version 0.9
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 10.6.02

%display __<=__ %LATEX \leq
%display __>=__ %LATEX \geq

%prec( 
  { __ -? __ , __ - __, __ + __ } < 
  { __*__, __ /? __, __ / __, __div__, __mod__, __ quot __, __rem__ } 
)%

%prec( 
  { __*__, __ /? __, __ / __, __div__, __mod__, __ quot __, __rem__ } < 
  { __ ^ __} 
)%

%left_assoc __ + __, __ * __, __ @@ __

%number __@@__

spec Nat =

  free type Nat ::= 0 | suc(pre:? Nat)
 
  preds   __ <= __, __ >= __,
          __ <  __, __ > __: Nat * Nat;
          odd, even: Nat

  ops   __! :                       Nat -> Nat;
        __ + __, __ * __, __ ^ __,
        min, max:                   Nat * Nat ->  Nat;
        __ -?__, __ /? __,
        __ div __, __ mod __ :      Nat * Nat ->? Nat;

  %% Operations to represent natural numbers with digits:

  ops  1: Nat = suc (0);                      %(1_def_Nat)%
       2: Nat = suc (1);                      %(2_def_Nat)%
       3: Nat = suc (2);                      %(3_def_Nat)%
       4: Nat = suc (3);                      %(4_def_Nat)%
       5: Nat = suc (4);                      %(5_def_Nat)%
       6: Nat = suc (5);                      %(6_def_Nat)%
       7: Nat = suc (6);                      %(7_def_Nat)%
       8: Nat = suc (7);                      %(8_def_Nat)%
       9: Nat = suc (8);                      %(9_def_Nat)%

        __ @@ __ :         Nat * Nat -> Nat 

  %% implied operation attributes :

  ops __+__: Nat * Nat -> Nat, 
             comm, assoc, unit 0; %implied
      __*__: Nat * Nat -> Nat, 
             comm, assoc, unit 1; %implied
      min:   Nat * Nat -> Nat, 
             comm, assoc;         %implied
      max:   Nat * Nat -> Nat, 
             comm, assoc, unit 0; %implied

  forall m,n,r,s,t : Nat

  %% axioms concerning predicates

     . 0! = 1                           %(factorial_0)%
     . suc(n)! =suc(n)*n!               %(factorial_suc)%

     . 0 <= n                           %(leq_def1_Nat)%
     . not (suc(n) <= 0)                %(leq_def2_Nat)%
     . suc(m) <= suc(n) <=> m <= n      %(leq_def3_Nat)%

     . m >= n <=> n <= m                %(geq_def_Nat)%
     . m < n  <=> (m <= n /\ not (m=n)) %(less_def_Nat)%
     . m > n  <=> m < n                 %(greater_def_Nat)%
   
     . odd(m) <=> not even(m)           %(odd_def_Nat)%
     . even(0)                          %(even_0_Nat)%
     . even(suc(m)) <=> odd(m)          %(even_suc_Nat)%

  %% axioms concerning operations

     . 0 + m = m                        %(add_0_Nat)%
     . suc(n) + m = suc(n + m)          %(add_suc_Nat)%

     . 0 * m = 0                        %(mult_0_Nat)%
     . suc(n) * m = (n * m) + m         %(mult_suc_Nat)%

     . m ^ 0 = 1                        %(power_0_Nat)%
     . m ^ suc(n)  = m * m ^ n          %(power_suc_Nat)%

     . min(m,n) = m when m <= n else n  %(min_def_Nat)%
     . max(m,n) = n when m <= n else m  %(max_def_Nat)%

     . def(m-?n) <=> m >= n             %implied  %(sub_dom_Nat)% 
     . m -? n = r <=> m = r + n         %(sub_def_Nat)%

     . def(m /? n) <=> 
       not (n=0) /\ m mod n = 0             %implied %(divide_dom_Nat)%
     . not def(m /? 0)                      %(divide_0_Nat)%
     . ( m /? n = r <=> m = r * n ) if n>0  %(divide_Pos_Nat)%

     . def ( m div n ) <=> not (n=0)    %implied %(div_dom_Nat)%
     . m div n = r <=> 
       (exists s: Nat . m = n*r + s /\ s < n)  %(div_Nat)%

     . def ( m mod n ) <=> not (n=0)            %implied %(mod_dom_Nat)%
     . m mod n = s <=> 
       (exists r: Nat . m = n*r + s /\ s < n)  %(mod_Nat)%

  %% for number representation

     . m @@ n = (m * suc(9)) + n        %(decimal_def)%

  %% important laws

     . (r + s) * t = (r * t) + (s * t)  %implied %(distr_Nat)%

then %%mono
     sort Pos = { p: Nat . p > 0 }
     op    1: Pos = suc(0);             %(1_as_Pos_def)%
           __*__: Pos * Pos -> Pos;
           __+__: Pos * Nat -> Pos;
           __+__: Nat * Pos -> Pos;
	   suc: Nat -> Pos

then %implies

     forall x,m,n,r,s,t: Nat; p: Pos
     . min(m,0)=0                       %(min_0)% 

end

spec Int = 

  Nat 

then %%mono

     generated type Int ::= __ - __(Nat;Nat)

     forall a,b,c,d: Nat
     .  a - b = c - d <=> a + d = c + b    %(Int_equality)%

     sort  Nat < Int	
     forall a: Nat
     .  a = a - 0                     %(Int_Nat_embedding)%

then %def

     preds __ <= __, __ < __,
           __ >= __, __ > __: Int * Int;
           odd, even: Int

     ops  - __, sign: Int -> Int;
          abs:        Int -> Nat;
          __ + __,__ * __, __ - __,
          __ ^ __:                           Int * Nat -> Int;
          min, max:                          Int * Int -> Int;
          __ /? __, 
          __ div __, __ quot __, __ rem __ : Int * Int ->? Int;
	  __ mod __:                         Int * Int ->? Nat
        
  %% implied operation attributes :

     ops __+__:   Int * Int -> Int, 
                  comm, assoc, unit 0; %implied
         __*__:   Int * Int -> Int, 
                  comm, assoc, unit 1; %implied
         min,max: Int * Int -> Int, 
                  comm, assoc;         %implied

     forall  m,n,r,s: Int; a,b,c,d: Nat
     . (a - b) + (c - d) = (a + c) - (b + d)   %(Int_add_def)%
     . (a - b) * (c - d) = 
       (a * c + b * d) - (b * c + a * d)       %(Int_mult_def)%
     . m - n = m + ( - n )                     %(Int_sub_def)%
		
     . - (a - b) = b - a                       %(Int_neg_def)%
     . sign(m) = 0 when m = 0 
       else (1 when m > 0 else -1)             %(Int_sign_def)% 

     . m <= n <=> n - m in Nat                 %(Int_leq_def)%
     . m >= n <=> n <= m  	               %(Int_geq_def)%
     . m < n <=> (m <= n /\ not (m=n))         %(Int_less_def)%
     . m > n <=> m < n   	               %(Int_greater_def)%

     . min(m,n) = m when m <= n else n         %(Int_min_def)%
     . max(m,n) = n when m <= n else m         %(Int_max_def)%

     . abs(m) = - m if m < 0                   %(Int_abs_def)%

     . (- 1) ^ a = 1 when even(a) else - 1     %(Int_neg1_power_def)%
     . m ^ a = sign(m)^a * abs(m)^a            %(Int_power_def)%

     . even(m) <=> even(abs(m))                %(Int_even_def)%
     . odd(m) <=> not(even(m))                 %(Int_odd_def)%

     . m /? n = 
      sign(m) * sign(n) * (abs(m) /? abs(n))   %(Int_divide)%

     . m mod n < abs(n)  if not n = 0          %(Int_mod_range)%
     . m = (m div n) * n + (m mod n) if not n = 0
  					       %(Int_mod__div_def)%
     . not def m mod 0                         %(Int_mod_zero)%
     . not def m div 0                         %(Int_div_zero)%

     . m quot n = 
       sign(m) * sign(n) * (abs(m) quot abs(n))  %(Int_quot_def)%
     . m rem n = 
       sign(m) * sign(n) * (abs(m) rem abs(n))   %(Int_rem_def)%
				
then %implies

 %[ this is not legal, since -__:Nat->Int is not in the signature!
    generated type Int::= Nat | -__ (Nat) ]%

     forall m,n,r: Int; a,b: Nat
     . def(a -? b) => a -? b = a - b                %(Int_Nat_sub_compat)%
     . m = sign(m) * abs(m)                         %(Int_abs_decomp)%
     . odd(m) <=> odd(abs(m))                       %(Int_odd_alt)%
     . m /? n = r <=> not n = 0 /\ n * r = n        %(Int_divide_dom1)%
     . def (m /? n) <=> m mod n = 0                 %(Int_divide_dom2)%
     . def (m mod n) <=> not n = 0                  %(Int_mod_dom)%
     . m mod n = m mod abs(n) 			    %(Int_mod_abs)%
     . def (m div n) <=> not n = 0                  %(Int_div_dom)%
     . def (m quot n) <=> not n = 0                 %(Int_quot_dom)%
     . def (m rem n) <=> not n = 0                  %(Int_rem_dom)%
     . m = (m quot n) * n + (m rem n) if not n = 0  %(Int_quot_rem)%
end









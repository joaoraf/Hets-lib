library Basic/Numbers
version 0.7
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 16.3.01

%prec( 
  { __ -? __ , __ - __, __ + __ } < 
  { __*__, __ /? __, __ / __, __div__, __mod__, __ quot __, __rem__ } 
)%

%prec( 
  { __*__, __ /? __, __ / __, __div__, __mod__, __ quot __, __rem__ } < 
  { __ ^ __} 
)%

%prec( {+__} <> {__ ^ __} )%


%left_assoc __ + __, __ * __, __ @@ __

%number __@@__

spec Nat =

  free type Nat ::= 0 | suc(pre:? Nat)
 
  preds   __ <= __, __ < __,
          __ >= __, __ > __: Nat * Nat;
          odd, even: Nat

  ops   __ + __, __ * __: Nat * Nat -> Nat;
        __ ^ __: Nat * Nat -> Nat;
        min, max: Nat * Nat ->  Nat;
        +__: Nat -> Nat;
        abs: Nat -> Nat;
        __! :    Nat -> Nat;
        __ -?__: Nat * Nat ->? Nat;
        __ /? __: Nat * Nat ->? Nat;
        __ div __, __ mod __ , __ quot __, __ rem __ :Nat * Nat ->? Nat;

%%   Operations to represent natural numbers with digits:
           1,2,3,4,5,6,7,8,9: Nat;
           __ @@ __ :         Nat * Nat -> Nat 
     
     forall m,n,r,s: Nat

     . 0 <= n                           %(Nat_leq_def1)%
     . not (suc(n) <= 0)                %(Nat_leq_def2)%
     . suc(m) <= suc(n) <=> m <= n      %(Nat_leq_def3)%

     . m >= n <=> n <= m                %(Nat_geq_def)%
     . m < n <=> (m <= n /\ not (m=n))  %(Nat_less_def)%
     . m > n <=> m < n                  %(Nat_greater_def)%
   
     . 0 + m = m                        %(Nat_add_0)%
     . suc(n) + m = suc(n + m)          %(Nat_add_suc)%

     . 0 * m = 0                        %(Nat_mult_0)%
     . suc(n) * m = (n * m) + m         %(Nat_mult_suc)%

     . m ^ 0 = 1                        %(Nat_power_0)%
     . m ^ suc(n)  = m * m ^ n          %(Nat_power_suc)%

     . min(m,n) = m when m <= n else n  %(Nat_min_def)%
     . max(m,n) = n when m <= n else m  %(Nat_max_def)%

     . + m = m                          %(plus_def)%

     . abs(n) = n                       %(Nat_abs)%

     . odd(m) <=> not even(m)           %(Nat_odd_def)%
     . even(0)                          %(Nat_even_0)%
     . even(suc(m)) <=> odd(m)          %(Nat_even_suc)%

     . 0! = 1                           %(Nat_factorial_0)%
     . suc(n)! =suc(n)*n!               %(Nat_factorial_suc)%

     . m -? n = r <=> m = r + n         %(Nat_sub_def)%

     . not def(m /? 0)                      %(Nat_divide_0)%
     . ( m /? n = r <=> m = r * n ) if n>0  %(Nat_divide_Pos)%

     . m div n = r <=> 
       (exists s: Nat . m = n*r + s /\ s < n)  %(Nat_div)%
     . m mod n = s <=> 
       (exists r: Nat . m = n*r + s /\ s < n)  %(Nat_mod)%
     . m quot n = m div n                      %(Nat_quot)%
     . m rem n = m mod n                       %(Nat_rem)%

     . 1 = suc (0)                      %(Nat_1_def)%
     . 2 = suc (1)                      %(Nat_2_def)%
     . 3 = suc (2)                      %(Nat_3_def)%
     . 4 = suc (3)                      %(Nat_4_def)%
     . 5 = suc (4)                      %(Nat_5_def)%
     . 6 = suc (5)                      %(Nat_6_def)%
     . 7 = suc (6)                      %(Nat_7_def)%
     . 8 = suc (7)                      %(Nat_8_def)%
     . 9 = suc (8)                      %(Nat_9_def)%
     . m @@ n = (m * suc(9)) + n        %(Nat_decimal_def)%

then %def
     sort Pos = { p: Nat . p > 0 }
     op    1: Pos = suc(0) as Pos;      %(Nat_1_as_Pos_def)%
           __*__: Pos * Pos -> Pos;
           __+__: Pos * Nat -> Pos;
           __+__: Nat * Pos -> Pos;

then %implies

     ops min, max: Nat * Nat -> Nat, comm, assoc

     forall x,m,n,r,s,t: Nat; p: Pos
     . def(m-?n) <=> m >= n             %(Nat_sub_dom)%
     . def(m /? n) <=> m mod n = 0      %(Nat_divide_dom)%
     . def ( m div n ) <=> not (n=0)    %(Nat_div_dom)%
     . def ( m mod n ) <=> not (n=0)    %(Nat_mod_dom)%
     . def ( m quot n ) <=> not (n=0)   %(Nat_quot_dom)%
     . def ( m rem n ) <=> not (n=0)    %(Nat_rem_dom)%
     . (r + s) * t = (r * t) + (s * t)  %(Nat_distr)%
     . max(m,0)=m                       %(Nat_max_unit)%      
     . min(m,0)=0                       %(Nat_min_0)% 
end

spec Int =
     Nat 
then %def
     generated type Int ::= __ - __(Nat;Nat)
     forall a,b,c,d: Nat
     .  a - b = c - d <=> a + d = c + b    %(Int_equality)%
then
     sort  Nat < Int	
     forall a: Nat
     .  a = a - 0                     %(Int_Nat_embedding)%

     preds __ <= __, __ < __,
        __ >= __, __ > __: Int * Int;
        odd, even: Int

     ops 0,1: Int;
        __ + __, __ - __,__ * __: Int * Int -> Int;
        __ ^ __: Int * Nat -> Int;
        + __, - __, sign: Int -> Int;
        min, max: Int * Int ->  Int;
        abs: Int -> Nat;
	__ /? __, 
        __ div __, __ quot __, __ rem __ : Int * Int ->? Int;
	__ mod __: Int * Int ->? Nat
        

     forall  m,n,r,s: Int; a,b,c,d: Nat
     . (a - b) + (c - d) = (a + c) - (b + d)   %(Int_add_def)%
     . (a - b) * (c - d) = 
       (a * c + b * d) - (b * c + a * d)       %(Int_mult_def)%
     . m - n = m + ( - n )                     %(Int_sub_def)%
		
     . + m = m  %(Int_pos_def)%
     . - (a - b) = b - a                       %(Int_neg_def)%
     . sign(m) = 0 when m = 0 
       else (1 when m > 0 else -1)             %(Int_sign_def)% 

     . m <= n <=> n - m in Nat                 %(Int_leq_def)%
     . m >= n <=> n <= m  	               %(Int_geq_def)%
     . m < n <=> (m <= n /\ not (m=n))         %(Int_less_def)%
     . m > n <=> m < n   	               %(Int_greater_def)%

     . min(m,n) = m when m <= n else n         %(Int_min_def)%
     . max(m,n) = n when m <= n else m         %(Int_max_def)%

     . abs(m) = - m if m < 0                   %(Int_abs_def)%

     . (- 1) ^ a = 1 when even(a) else - 1     %(Int_neg1_power_def)%
     . m ^ a = sign(m)^a * abs(m)^a            %(Int_power_def)%

     . even(m) <=> even(abs(m))                %(Int_even_def)%
     . odd(m) <=> not(even(m))                 %(Int_odd_def)%

     . m /? n = 
      sign(m) * sign(n) * (abs(m) /? abs(n))   %(Int_divide)%

     . m mod n < abs(n)  if not n = 0          %(Int_mod_range)%
     . m = (m div n) * n + (m mod n) if not n = 0
  					       %(Int_mod__div_def)%
     . not def m mod 0                         %(Int_mod_zero)%
     . not def m div 0                         %(Int_div_zero)%

     . m quot n = 
       sign(m) * sign(n) * (abs(m) quot abs(n))  %(Int_quot_def)%
     . m rem n = 
       sign(m) * sign(n) * (abs(m) rem abs(n))   %(Int_rem_def)%
				
then %implies

     generated type Int::= Nat | -__ (Nat)

     forall m,n,r: Int; a,b: Nat
     . def(a -? b) => a -? b = a - b                %(Int_Nat_sub_compat)%
     . m = sign(m) * abs(m)                         %(Int_abs_decomp)%
     . odd(m) <=> odd(abs(m))                       %(Int_odd_alt)%
     . m /? n = r <=> not n = 0 /\ n * r = n        %(Int_divide_dom1)%
     . def (m /? n) <=> m mod n = 0                 %(Int_divide_dom2)%
     . def (m mod n) <=> not n = 0                  %(Int_mod_dom)%
     . m mod n = m mod abs(n) 			    %(Int_mod_abs)%
     . def (m div n) <=> not n = 0                  %(Int_div_dom)%
     . def (m quot n) <=> not n = 0                 %(Int_quot_dom)%
     . def (m rem n) <=> not n = 0                  %(Int_rem_dom)%
     . m = (m quot n) * n + (m rem n) if not n = 0  %(Int_quot_rem)%
end
	
spec Rat =
     Int
then %def

     generated type Rat ::= __ / __ (Int;Pos)

     forall i,j: Int; p,q: Pos
     . i / p = j / q <=> i*q = j*p              %(Rat_equality)%

     sort Int < Rat

     forall i:Int
     . i / 1 = i                                %(embeddingIntToRat)%

then

     preds    __ <= __, __ < __,
              __ >= __, __ > __: Rat * Rat;

     ops 0,1: Rat;
         __ + __,__ - __, __ * __ : Rat * Rat -> Rat;
         __ / __ : Rat * Rat ->? Rat;
         +__, -__, abs: Rat -> Rat;
         __ ^ __: Rat * Int -> Rat;
         min,max: Rat * Rat -> Rat;

     forall p,q:Pos; n:Nat; i,j: Int; x,y,z: Rat

     . (i / p <= j / q <=> i * q <= j * p ) %(Rat_leq_def)%
     . x >= y <=> y <= x                    %(Rat_geq_def)%
     . x < y <=> (x <= y /\ not (x=y))      %(Rat_less_def)%
     . x > y <=> y < x                      %(Rat_greater_def)%

     . (i / p) + (j / q) =	
       (i * q + j * p) / (p * q)        %(Rat_add_def)%

     . x-y = x + (-y)                   %(Rat_sub_def)%

     . (i / p) * (j / q) = 
       (i * j) / (p * q)                %(Rat_mult_def)%

     . not def x/0                      %(Rat_divide_def1)%
     . (x/y=z <=> z=x*y) 
       if not y = 0	              	%(Rat_divide_def2)%

     . + x = x                          %(Rat_plus_def)%
     . - (i/p) = (-i)/p                 %(Rat_minus_def)%

     . abs(i / p)= abs(i) / p           %(Rat_abs_def)%

     . x ^ 0 = 1                        %(Rat_power_0)%
     . x ^ suc(n) = x * x ^ n           %(Rat_power_suc)%
     . x ^ (-p) = 1 / (x ^ p)           %(Rat_power_neg)%

     . min(x,y) = x when x <= y else y  %(Rat_min_def)%
     . max(x,y) = y when x <= y else x  %(Rat_max_def)%

then %implies
   
     forall i,j: Int; p,q:Pos 
     . (i / p) - (j / q) = 
       (i * q - j * p) / (p * q)        %(Rat_sub_rule)%

     . (i / p) / (j / q) = 
       (i / p) * (q / j) if not j=0     %(Rat_divide_rule)%






library Basic/PreNumbers
version 0.4
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% copyright 5.5.00

from Basic/RelationsAndOrders version 0.4
get SigOrder, TotalOrder

spec
     SigPreNumbers[sort Elem][sort NonNeg] =
     SigOrder [sort Elem]
then
     ops
           0:                Elem;
           __ + __, __ * __: Elem × Elem -> Elem %left assoc;
           abs:              Elem -> NonNeg;
     %prec { __ + __ } < { __ * __ }
end

spec
     GenerateNat =
free
     types
      Nat ::= 0 | sort Pos;
      Pos ::= suc(pre: Nat)
end

spec
     PreNat =
     GenerateNat
and
     SigPreNumbers [sort Nat][sort Nat]
then
     %def
     op
          %[PreNat_1_def] 1: Pos = suc(0);
          1 : Nat
then
     vars
          m,n: Nat; p: Pos
     .
          %[Nat_leq_def1] 0 <= n
     .
          %[Nat_leq_def2] not (p <= 0)
     .
          %[Nat_leq_def3] suc(m) <= suc(n) <=> m <= n
     .
          %[Nat_add__0] 0 + m = m
     .
          %[Nat_add_suc] suc(n) + m = suc(n + m)
     .
          %[Nat_mult_0] 0 * m = 0
     .
          %[Nat_mult_suc] suc(n) * m = (n * m) + m
     .
          %[PreNat_abs] abs(m)=m
then
     %def
     ops
           __*__: Pos × Pos -> Pos;
           __+__: Pos × Nat -> Pos;
           __+__: Nat × Pos -> Pos;
           abs :  Pos -> Pos
end

view
     TotalOrder_in_PreNat: TotalOrder to PreNat
=
     sort Elem |-> Nat
end

spec
     GenerateInt =
     GenerateNat
then
     free
          types
           Int ::=  sort Nat | sort Neg;
           Neg ::=  minus (Pos)
     ops
           suc,
           pre: Int -> Int
     var
          p:Pos
     .
          %[Int_suc_minus_one] suc(minus(suc(0))) = 0
     .
          %[Int_suc_Neg] suc(minus(suc(p))) = minus(p)
     .
          %[Int_pre_def1] pre(0) = minus(suc(0))
     .
          %[Int_pre_def2] pre(minus(p)) = minus(suc(p))
end

spec
     PreInt =
     GenerateInt and PreNat
and
     SigPreNumbers [sort Int][sort Nat]
then
     %def
     op 1:Int = suc(0)
     vars
          m,n: Nat; p,q: Pos
     .
          %[Int_leq_def1] minus(p) <= n
     .
          %[Int_leq_def2] not (m <= minus(p))
     .
          %[Int_leq_def3] minus(p) <= minus(q) <=> q <= p
     .
          %[Int_add_def1] m + minus(p) = minus(p) + m
     .
          %[Int_add_def2] minus(p) + 0 = minus(p)
     .
          %[Int_add_def3] minus(p) + suc(m) = suc(minus(p)) + m
     .
          %[Int_add_def4] minus(p) + minus(q) = minus(p + q)
     .
          %[Int_mult_def1] m * minus(p) = minus(p) * m
     .
          %[Int_mult_def2] minus(p) * 0 = 0
     .
          %[Int_mult_def3] minus(p) * q = minus(p * q)
     .
          %[Int_mult_def4] minus(p) * minus(q) = p * q
     .
          %[PreInt_abs_Neg] abs(minus(p))=p
then
     %def
     ops
           __*__: Neg × Neg -> Pos;
           __*__: Neg × Pos -> Neg;
           __*__: Pos × Neg -> Neg;
           __+__: Neg × Neg -> Neg;
           abs :  Int -> Nat;
           abs :  Neg -> Pos;
end

view
     TotalOrder_in_PreInt: TotalOrder to PreInt
=
     sort Elem |-> Int
end

spec
     GenerateRat =
     PreInt
then
     generated
          type Rat ::= __ frac __ (Int;Pos)
     vars
          i,j: Int; p,q: Pos
     .
          %[Rat_equality] i frac p = j frac q <=> i*q = j*p
end

spec
     PreRat =
     GenerateRat
then
     sort NonNeg[Rat] < Rat
     generated type NonNeg[Rat]::= __ frac __ (Nat;Pos)
then
     SigPreNumbers [sort Rat fit sort Elem |-> Rat]
	[sort Rat fit sort NonNeg |-> NonNeg[Rat]]
then
     %def
     sort
          Int < Rat
     var
          i:Int
     .
          %[embeddingIntToRat] i frac 1 = i
then
     %prec {__ + __} < { __ frac __}
     vars
          n,m: Int; p,q:Pos
     .
          %[Rat_leq_def] (n frac p <= m frac q <=> n * q <= m * p )
     .
          %[Rat_add_def] n frac p + m frac q =	
		(n * q + m * p) frac (p * q)
     .
          %[Rat_mult_def] (n frac p) * (m frac q) = (n * m) frac (p * q)
     .
          %[Rat_abs_def] abs(n frac p)=abs(n) frac p
then
     %def
     op   1 : Rat
end

view
     TotalOrder_in_PreRat : TotalOrder to PreRat
=
     sort Elem |-> Rat
end


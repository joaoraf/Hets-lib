library Basic/StructuredDatatypes
version 0.7
%% authors: M.Roggenbach, T.Mossakowski, L.Schröder
%% date: 16.3.01

%left_assoc __ + __, __ - __, __ ++ __
%right_assoc __ :: __
%%list [__], [], __::__
%prec {__ ++ __} < {__ :: __}
%string [], __::__

from Basic/Numbers version 0.5 get Nat, Int

from Basic/RelationsAndOrders version 0.7
     get PartialOrder, BooleanAlgebra
from Basic/Algebra_I version 0.7 get Monoid
from Basic/SimpleDatatypes version 0.7 get Char

spec GenerateFiniteSet  [sort Elem] =
free {
          type
                FinSet[Elem]::=    {}
                                |  {__} (Elem)
                                |  __ union __ (FinSet[Elem];FinSet[Elem])
          op
                __ union __: FinSet[Elem] * FinSet[Elem] -> FinSet[Elem],
                             assoc, comm, idem, unit {}
     }
end

spec FiniteSet  [sort Elem] given Nat =
  GenerateFiniteSet [sort Elem]
then %def
  preds  isNonEmpty:       FinSet[Elem];
          __ eps__:        Elem * FinSet[Elem];
         __ isSubsetOf __: FinSet[Elem] * FinSet[Elem]
  ops
           __ + __ : Elem * FinSet[Elem] -> FinSet[Elem];
           __ + __, __ - __ : FinSet[Elem] * Elem -> FinSet[Elem];
           __ intersection __, __ -
           __,
           __ symmDiff __:            FinSet[Elem] * FinSet[Elem] ->
                                      FinSet[Elem];
           #__:                       FinSet[Elem] -> Nat;

  forall x,y : Elem; S,T,U,V:FinSet[Elem]

  . isNonEmpty(S) <=> not S = {}             %(isNonEmpty_def)%

  . not x eps {}                                  %(elemOf_empty)%
  . x eps {y} <=> (x=y)                           %(elemOf_set)%
  . x eps (S union T) <=> (x eps S) \/ (x eps T)  %(elemOf_union)%


  . {} isSubsetOf S                               %(subset_empty)%
  . {x} isSubsetOf S <=> x eps S                  %(subset_set)%
  . (S union T) isSubsetOf U <=> 
    S isSubsetOf U /\ T isSubsetOf U              %(subset_union)%

  . x + S = {x} union S             %(FinSet_add_def1)%
  . S + x = x + S                   %(FinSet_add_def2)%

  . {} - x = {}                              %(FinSet_sub_empty)%
  . {y} - x = {y} if not x = y               %(FinSet_sub_set1)%
  . {y} - x = {} if x = y                    %(FinSet_sub_set2)%
  . (S union T) - x = (S - x) union (T - x)  %(FinSet_sub_union)%

  . {} intersection S = {}                   %(intersect_empty)%
  . {x} intersection S = {} if not x eps S   %(intersect_set1)%
  . {x} intersection S = {x} if x eps S      %(intersect_set2)%
  . (S union T) intersection U = 
    (S intersection U) union (T intersection U)  %(intersect_union)%

  . {} - S = {}                               %(diff_empty)%
  . {x} - S = {x} if not x eps S              %(diff_set1)%
  . {x} - S = {} if x eps S                   %(diff_set2)%
  . (S union T) - U = (S - U ) union (T - U)  %(diff_union)%

  . S symmDiff T = (S - T) union (T - S)             %(symmDiff_def)%

  . #{} = 0                       %(FinSet_numberOf_empty)%
  . #{x} = 1                      %(numberOf_FinSet_set)%
  . #(S union T) = #S + #(T-S)    %(numberOf_FinSet_union)%

then %implies
     ops
           __ intersection __: FinSet[Elem] * FinSet[Elem] -> FinSet[Elem],
                               assoc, comm, idem;
           __ symmDiff __ :    FinSet[Elem] * FinSet[Elem] -> FinSet[Elem],
                               comm;
     forall x: Elem; S,T: FinSet[Elem]
     . S isSubsetOf T <=> 
       ( forall x: Elem . x eps S => x eps T )             
       %(subset_characterization)%
end

view PartialOrder_in_FiniteSet  [sort Elem] given Nat:
     PartialOrder to FiniteSet [sort Elem] =
     sort Elem     |-> FinSet[Elem] ,
     pred __ <= __ |-> __ isSubsetOf __
end

spec FinitePowerSet [FiniteSet[sort Elem] then op X: FinSet[Elem]]
= %def
     sorts
           FinPS[X]= { Y: FinSet[Elem] . Y isSubsetOf X };
           Elem[X] = {x : Elem . x eps X }
     preds

           __ eps__:         Elem[X] * FinPS[X];
           __ isSubsetOf __: FinPS[X] * FinPS[X];
     ops
           {}, X :                      FinPS[X];
           {__} :                       Elem[X] -> FinPS[X];
           __ union __:                 FinPS[X] * FinPS[X] -> FinPS[X];
           __ + __ : Elem[X] * FinPS[X] -> FinPS[X];
           __ + __, __ - __ : FinPS[X] * Elem[X] -> FinPS[X];
           __ intersection __, __ - __,
           __ symmDiff __:              FinPS[X] * FinPS[X] -> FinPS[X];
           #__:                         FinPS[X] -> Nat;
end

view BooleanAlgebra_in_FinitePowerSet
     [FiniteSet[sort Elem] then op X: FinSet[Elem]] :
     BooleanAlgebra to
     FinitePowerSet[FiniteSet[sort Elem] then op X: FinSet[Elem]]
=
     sort
          Elem |-> FinPS[X],
     ops
           0 |-> {},
           1 |-> X,
           __ cap __ |-> __ intersection __,
           __ cup __ |-> __ union __
end

spec GenerateList  [sort Elem] =
  free types 
  List[Elem] ::=  [] |  __ :: __ (first ? : Elem; rest ? : List[Elem])
end


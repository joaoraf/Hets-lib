library Calculi/Algebra/Auxiliary
version 0.1
%author: S. Wölfl
%date: 02-02-05

%( This library is just there to remove some "junk" from other libraries, 
   namely
	Basic/RelationsAndOrders#RichBooleanAlgebra
	Basic/StructuredDatatypes#Set
    Sorry, but that's sometimes helpful for a clear look on 
    signatures, morphisms, etc.
)%


from Basic/StructuredDatatypes get GenerateSet
from Basic/StructuredDatatypes get Set |-> SetFromBasicStructuredDatatypes 
from Basic/RelationsAndOrders version 0.7 get  
	PartialOrder,StrictOrder,RichPartialOrder,
	BooleanAlgebra, RichBooleanAlgebra
from Basic/Algebra_I version 1.0 get  
	Monoid
	

spec ExtBooleanAlgebraByCompl[BooleanAlgebra] = %def
 
     op compl: Elem -> Elem

     forall x,y:Elem
     . compl(x)=y <=> x cup y = 1 /\ x cap y = 0    
                                            %(compl_def_ExtBooleanAlgebra)%
then %implies
     forall x,y: Elem
     . compl(0) = 1
     . compl(1) = 0
     . compl(x cap y) = compl(x) cup compl(y)             %(de_Morgan1)%
     . compl(x cup y) = compl(x) cap compl(y)             %(de_Morgan2)%
     . compl(compl(x)) = x        %(involution_compl_ExtBooleanAlgebra)%
end

spec BooleanAlgebraWithCompl = ExtBooleanAlgebraByCompl[BooleanAlgebra]


spec ExtBooleanAlgebraByPartialOrder[BooleanAlgebra] = %def

     preds 
	   __<=__, __<__, __>=__, __>__: Elem * Elem;
	   Atom: Elem

     forall x,y:Elem
     . x <= y <=> x cap y = x           %(leq_def_ExtBooleanAlgebra)%
     . x >= y <=> y <= x                %(geq_def_ExtBooleanAlgebra)%
     . x < y <=> (x <= y /\ not (x=y))  %(less_def_ExtBooleanAlgebra)%
     . x > y <=> y < x                  %(greater_def_ExtBooleanAlgebra)%
     . Atom(x) <=> not x = 0 /\ (forall y:Elem . y < x => y = 0) %(def_Atom)%
end


spec BooleanAlgebraWithPartialOrder = 
	ExtBooleanAlgebraByPartialOrder[BooleanAlgebra]
end

view BooleanAlgebraWithPartialOrder_as_PartialOrder : 
     { RichPartialOrder hide ops sup,inf } to 
	BooleanAlgebraWithPartialOrder
end



spec AtomicBooleanAlgebra =
     { BooleanAlgebraWithPartialOrder hide pred Atom }
then
     sort AtomElem = {x: Elem . not x = 0 /\ (forall y:Elem . y < x => y = 0)}
     forall x:Elem
     . not x = 0 => (exists y:AtomElem . y <= x) 	
end

%[
spec SetNew [sort Elem] = 
     SetFromBasicStructuredDatatypes[sort Elem] 
	hide sorts Nat, Pos, op symDiff
end 
  ]%     


spec Set [sort Elem] = %mono
     GenerateSet [sort Elem]
then
     GenerateSet [sort Set[Elem]]
then %def
     preds  isNonEmpty:       Set[Elem];
          __ isSubsetOf __: Set[Elem] * Set[Elem]
     ops    {__}: Elem -> Set[Elem];
         __ + __ : Elem * Set[Elem] -> Set[Elem];
         __ - __ : Set[Elem] * Elem -> Set[Elem];
         __ intersection __, 
         __ union__,
         __ - __:  Set[Elem] * Set[Elem] -> Set[Elem];
         Union: Set[Set[Elem]] -> Set[Elem]

     %% implied operation attributes

     ops
         __ union __ : Set[Elem] * Set[Elem] -> Set[Elem], 
			assoc, comm, idem, unit {}; %implied
         __ intersection __ : Set[Elem] * Set[Elem] -> Set[Elem],
                       assoc, comm, idem;   %implied
     forall x,y: Elem; M,N,O: Set[Elem]; X:Set[Set[Elem]]
     %% axioms concerning predicates
     . isNonEmpty(M) <=> not M = {}             %(isNonEmpty_def)%
     . M isSubsetOf N <=> 
     forall x: Elem. x eps M => x eps N         %(isSubsetOf_def)%
     %% axioms concerning operations
     . { x } = {} + x                           %(singletonSet_def)%
     . x + M = M + x                            %(addElem_def_Set)%
     . {}      - y  = {}                        %(remElem_EmptySet)%
     . (M + x) - y  =  M-y   when x=y else
                   (M-y) + x                    %(remElem_NonEmptySet)%
     . M intersection {}    = {}                %(intersection_Emptyset)%
     . M intersection (N+x) = 
      (M intersection N) + x when x eps M else
       M intersection N                         %(intersection_NonEmptySet)%
     . M union {}    =  M                       %(union_EmptySet)%
     . M union (N+x) =  M union N      when x eps M else
                    (M union N) + x             %(union_NonEmptySet)%
     . M - {} = M                               %(dif_Emptyset)%
     . M - (N+x) = (M - N) - x                  %(dif_Emptyset)%
     %% important laws
     . (M union N) intersection O = 
        (M intersection O) union (N intersection O)
                                                %(distr1_Set)% %implied
     . O intersection (M union N) = 
         (O intersection M) union (O intersection N)
                                                %(distr2_Set)% %implied
     . x eps Union(X) <=> exists M:Set[Elem]. M eps X /\ x eps M 
then %implies
     forall x,y: Elem; M,N:Set[Elem]
     . M isSubsetOf (M union N)                 %(union_isSubsetOf)%
      . (M intersection N) isSubsetOf M         %(intersection_isSubsetOf)%
end




view Set_as_PartialOrder  [sort Elem] :
     PartialOrder to Set [sort Elem] 
=
     sort Elem     |-> Set[Elem] ,
     pred __ <= __ |-> __ isSubsetOf __
end



spec PowerSet [Set[sort Elem] then op X: Set[Elem]] = %mono
     sorts PowerSet[X]= { Y: Set[Elem] . Y isSubsetOf X };
           Elem[X] = { x : Elem . x eps X }
     preds __ eps__:         Elem[X] * PowerSet[X];
           __ isSubsetOf __: PowerSet[X] * PowerSet[X];
           isNonEmpty: PowerSet[X]
     ops   {}, X :           PowerSet[X];
      %%     #__:              PowerSet[X] -> Nat;
           __ + __ : Elem[X] * PowerSet[X] -> PowerSet[X];
           __ - __ : PowerSet[X] * Elem[X] -> PowerSet[X];
           __ intersection __, 
           __ union__,
           __ - __,
           __ symDiff __:  PowerSet[X] * PowerSet[X] ->   PowerSet[X];

     %% implied operation attributes

     ops  __ union __ : PowerSet[X] * PowerSet[X] -> PowerSet[X],
                        assoc, comm, idem, unit {}; %implied
          __ intersection __ : PowerSet[X] * PowerSet[X] -> PowerSet[X],
                              assoc, comm, idem;    %implied
     %% important laws
     
     forall M,N,O: PowerSet[X]
     . (M union N) intersection O = 
       (M intersection O) union (N intersection O) %(distr1_PowerSet)% %implied
     . O intersection (M union N) = 
      (O intersection M) union (O intersection N) %(distr2_PowerSet)% %implied
end



spec StrictPartialOrder =  StrictOrder

spec ExtStrictPartialOrderByRelations[StrictPartialOrder] = %def
     preds __>__,__<=__,__>=__,__cmp__: Elem * Elem		

     forall x,y:Elem
     . x > y <=> y < x					%(def_suc)%
     . x <= y <=> x < y \/ x = y			%(def_preE)%
     . x >= y <=> x > y \/ x = y			%(def_sucE)%
     . x cmp  y <=> x < y \/ x = y \/ y < x		%(def_cmp)%

then %implies
     forall x,y:Elem
     . x <= y <=> y >= x				%(equi_preE_sucE)%
     . x cmp y => y cmp x				%(cmp_sym)%     
end



from HasCASL/Set get Set |-> SetHasCASL

logic HasCASL

spec ExtStrictPartialOrderByConvexity[StrictPartialOrder] = 
     SetHasCASL

then %def
     pred
         Convex : Set(Elem)
     op
         convexhull : Set(Elem) -> Set(Elem) 

     forall x:Elem; X:Set(Elem)
     . Convex(X) <=> 
		(forall x,y,z:Elem . x < y /\ y < z /\ x isIn X /\ z isIn X => y isIn X)
										%(def_convex)%
     . x isIn convexhull(X) <=> x isIn X \/ 
	(exists x',x'':Elem . x isIn X /\ x' isIn X /\ x' < x /\ x < x'')
										%(def_convexhull)%  

then %implies
     forall X,Y:Set(Elem); XX:Set(Set(Elem))
     . Convex(emptySet)
     . Convex(X) /\ Convex(Y) => Convex(X intersection Y)
     . (forall X:Set(Elem) . X isIn XX => Convex(X)) /\
     	(forall X,X':Set(Elem) . X isIn XX /\ X' isIn XX => X subset X' \/ X' subset X) =>
	Convex(bigunion XX)
     . Convex(convexhull(X)) 
end 

logic HasCASL

spec ExtStrictPartialOrderBySetRelations[StrictPartialOrder] = 
     ExtStrictPartialOrderByRelations[StrictPartialOrder]
then
     SetHasCASL
then %def
     preds 
	__<__,__>__,__<=__,__>=__: Set(Elem) * Set(Elem);		
	__<__,__>__,__<=__,__>=__: Elem * Set(Elem);		
	__<__,__>__,__<=__,__>=__: Set(Elem) * Elem		

     forall x,y:Elem; X,Y:Set(Elem)
     . X < Y <=> (forall x,y:Elem . x isIn X /\ y isIn Y => x < y)
     . X <= Y <=> (forall x,y:Elem . x isIn X /\ y isIn Y => x <= y)
     . X > Y <=> Y < X
     . X >= Y <=> Y <=  X

     . X < y <=> X < {y}
     . X <= y <=> X <= {y}
     . X > y <=> X > {y}
     . X >= y <=> X >= {y}

     . x < Y <=> {x} < Y
     . x <= Y <=> {x} <= Y
     . x > Y <=> {x} > Y
     . x >= Y <=> {x} >= Y
end



logic CASL

spec SemiGroup =
     sort Elem
     op  __ * __: Elem * Elem -> Elem, assoc
end


spec InvolutedSemiGroup =
     SemiGroup
then 
     op inv:Elem -> Elem
     forall x,y:Elem
     . inv(x * y) = inv(y) * inv(x) 
     . inv(inv(x)) = x
end


spec InvolutedMonoid =
     Monoid
and  InvolutedSemiGroup
then 
     forall x:Elem
     . inv(e) = e
end




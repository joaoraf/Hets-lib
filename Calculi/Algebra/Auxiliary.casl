library Calculi/Algebra/Auxiliary
version 0.1
%author: S. Wölfl
%date: 02-02-05

%( This library is just there to remove some "junk" from other libraries, 
   namely
	Basic/RelationsAndOrders#RichBooleanAlgebra
	Basic/StructuredDatatypes#Set
    Sorry, but that's sometimes helpful for a clear look on 
    signatures, morphisms, etc.
)%


from Basic/StructuredDatatypes get GenerateSet
from Basic/RelationsAndOrders version 0.7 get  
	PartialOrder,StrictOrder, 
	BooleanAlgebra, RichBooleanAlgebra


spec ExtBooleanAlgebraByCompl[BooleanAlgebra] = %def
 
     op compl: Elem -> Elem

     forall x,y:Elem
     . compl(x)=y <=> x cup y = 1 /\ x cap y = 0    
                                            %(compl_def_ExtBooleanAlgebra)%
then %implies
     forall x,y: Elem
     . compl(0) = 1
     . compl(1) = 0
     . compl(x cap y) = compl(x) cup compl(y)             %(de_Morgan1)%
     . compl(x cup y) = compl(x) cap compl(y)             %(de_Morgan2)%
     . compl(compl(x)) = x        %(involution_compl_ExtBooleanAlgebra)%
end

spec BooleanAlgebraWithCompl = ExtBooleanAlgebraByCompl[BooleanAlgebra]


spec ExtBooleanAlgebraByPartialOrder[BooleanAlgebra] = %def

     preds 
	   __ <= __, __ < __,  __ >= __, __ > __: Elem * Elem;
	   Atom: Elem
     forall x,y:Elem
     . x <= y <=> x cap y = x           %(leq_def_ExtBooleanAlgebra)%
     . x >= y <=> y <= x                %(geq_def_ExtBooleanAlgebra)%
     . x < y <=> (x <= y /\ not (x=y))  %(less_def_ExtBooleanAlgebra)%
     . x > y <=> y < x                  %(greater_def_ExtBooleanAlgebra)%
     . Atom(x) <=> not x = 0 /\ (forall y:Elem . y < x => y = 0) %(def_Atom)%
end


spec BooleanAlgebraWithPartialOrder = 
	ExtBooleanAlgebraByPartialOrder[BooleanAlgebra]
end


spec AtomicBooleanAlgebra =
     { BooleanAlgebraWithPartialOrder hide pred Atom }
then
     sort Atom = {x: Elem . not x = 0 /\ (forall y:Elem . y < x => y = 0)}
     forall x:Elem
     . not x = 0 => (exists y:Atom . y <= x) 	
end


spec Set [sort Elem] = %mono
     GenerateSet [sort Elem]
then %def
     preds  isNonEmpty:       Set[Elem];
          __ isSubsetOf __: Set[Elem] * Set[Elem]
     ops    {__}: Elem -> Set[Elem];
         __ + __ : Elem * Set[Elem] -> Set[Elem];
         __ - __ : Set[Elem] * Elem -> Set[Elem];
         __ intersection __, 
         __ union__,
         __ - __:  Set[Elem] * Set[Elem] -> Set[Elem];

     %% implied operation attributes

     ops
         __ union __ : Set[Elem] * Set[Elem] -> Set[Elem], 
			assoc, comm, idem, unit {}; %implied
         __ intersection __ : Set[Elem] * Set[Elem] -> Set[Elem],
                       assoc, comm, idem;   %implied
     forall x,y: Elem; M,N,O: Set[Elem]
     %% axioms concerning predicates
     . isNonEmpty(M) <=> not M = {}             %(isNonEmpty_def)%
     . M isSubsetOf N <=> 
     forall x: Elem. x eps M => x eps N         %(isSubsetOf_def)%
     %% axioms concerning operations
     . { x } = {} + x                           %(singletonSet_def)%
     . x + M = M + x                            %(addElem_def_Set)%
     . {}      - y  = {}                        %(remElem_EmptySet)%
     . (M + x) - y  =  M-y   when x=y else
                   (M-y) + x                    %(remElem_NonEmptySet)%
     . M intersection {}    = {}                %(intersection_Emptyset)%
     . M intersection (N+x) = 
      (M intersection N) + x when x eps M else
       M intersection N                         %(intersection_NonEmptySet)%
     . M union {}    =  M                       %(union_EmptySet)%
     . M union (N+x) =  M union N      when x eps M else
                    (M union N) + x             %(union_NonEmptySet)%
     . M - {} = M                               %(dif_Emptyset)%
     . M - (N+x) = (M - N) - x                  %(dif_Emptyset)%
     %% important laws
     . (M union N) intersection O = 
        (M intersection O) union (N intersection O)
                                                %(distr1_Set)% %implied
     . O intersection (M union N) = 
         (O intersection M) union (O intersection N)
                                                %(distr2_Set)% %implied
then %implies
     forall x,y: Elem; M,N:Set[Elem]
     . M isSubsetOf (M union N)                 %(union_isSubsetOf)%
      . (M intersection N) isSubsetOf M         %(intersection_isSubsetOf)%
end




view Set_as_PartialOrder  [sort Elem] :
     PartialOrder to Set [sort Elem] 
=
     sort Elem     |-> Set[Elem] ,
     pred __ <= __ |-> __ isSubsetOf __
end





spec StrictPartialOrder =  StrictOrder

spec ExtStrictPartialOrderByRelations[StrictPartialOrder] = %def
     preds __>__,__<=__,__>=__,__cmp__: Elem * Elem		

     forall x,y:Elem
     . x > y <=> y < x					%(def_suc)%
     . x <= y <=> x < y \/ x = y			%(def_preE)%
     . x >= y <=> x > y \/ x = y			%(def_sucE)%
     . x cmp  y <=> x < y \/ x = y \/ y < x		%(def_cmp)%

then %implies
     forall x,y:Elem
     . x <= y <=> y >= x				%(equi_preE_sucE)%
     . x cmp y => y cmp x				%(cmp_sym)%     
end



from HasCASL/Set get Set |-> SetHasCASL

logic HasCASL

spec ExtStrictPartialOrderByConvexity[StrictPartialOrder] = 
     SetHasCASL

then %def
     pred
         Convex : Set(Elem)
     op
         convexhull : Set(Elem) -> Set(Elem) 

     forall x:Elem; X:Set(Elem)
     . Convex(X) <=> 
		(forall x,y,z:Elem . x < y /\ y < z /\ x isIn X /\ z isIn X => y isIn X)
										%(def_convex)%
     . x isIn convexhull(X) <=> x isIn X \/ 
	(exists x',x'':Elem . x isIn X /\ x' isIn X /\ x' < x /\ x < x'')
										%(def_convexhull)%  

then %implies
     forall X,Y:Set(Elem); XX:Set(Set(Elem))
     . Convex(emptySet)
     . Convex(X) /\ Convex(Y) => Convex(X intersection Y)
     . (forall X:Set(Elem) . X isIn XX => Convex(X)) /\
     	(forall X,X':Set(Elem) . X isIn XX /\ X' isIn XX => X subset X' \/ X' subset X) =>
	Convex(bigunion XX)
     . Convex(convexhull(X)) 
end 


spec ExtStrictPartialOrderBySetRelations[StrictPartialOrder] = 
     ExtStrictPartialOrderByRelations[StrictPartialOrder]
then
     SetHasCASL
then %def
     preds 
	__<__,__>__,__<=__,__>=__: Set(Elem) * Set(Elem);		
	__<__,__>__,__<=__,__>=__: Elem * Set(Elem);		
	__<__,__>__,__<=__,__>=__: Set(Elem) * Elem		

     forall x,y:Elem; X,Y:Set(Elem)
     . X < Y <=> (forall x,y:Elem . x isIn X /\ y isIn Y => x < y)
     . X <= Y <=> (forall x,y:Elem . x isIn X /\ y isIn Y => x <= y)
     . X > Y <=> Y < X
     . X >= Y <=> Y <=  X

     . X < y <=> X < {y}
     . X <= y <=> X <= {y}
     . X > y <=> X > {y}
     . X >= y <=> X >= {y}

     . x < Y <=> {x} < Y
     . x <= Y <=> {x} <= Y
     . x > Y <=> {x} > Y
     . x >= Y <=> {x} >= Y
end






library Calculi/Algebra/Auxiliary
version 0.1
%author: S. Wölfl
%date: 02-02-05

%( This library is just there to remove some "junk" from other libraries, 
   namely
	Basic/RelationsAndOrders#RichBooleanAlgebra
	Basic/StructuredDatatypes#Set
    Sorry, but that's sometimes helpful for a clear look on 
    signatures, morphisms, etc.
)%


from Basic/StructuredDatatypes get GenerateSet
from Basic/RelationsAndOrders version 0.7 get  PartialOrder, 
	BooleanAlgebra, RichBooleanAlgebra


spec ExtBooleanAlgebraByCompl[BooleanAlgebra] = %def
 
     op compl: Elem -> Elem

     forall x,y:Elem
     . compl(x)=y <=> x cup y = 1 /\ x cap y = 0    
                                            %(compl_def_ExtBooleanAlgebra)%
then %implies
     forall x,y: Elem
     . compl(0) = 1
     . compl(1) = 0
     . compl(x cap y) = compl(x) cup compl(y)             %(de_Morgan1)%
     . compl(x cup y) = compl(x) cap compl(y)             %(de_Morgan2)%
     . compl(compl(x)) = x        %(involution_compl_ExtBooleanAlgebra)%
end

spec BooleanAlgebraWithCompl = ExtBooleanAlgebraByCompl[BooleanAlgebra]


spec ExtBooleanAlgebraByPartialOrder[BooleanAlgebra] = %def

     preds 
	   __ <= __, __ < __,  __ >= __, __ > __: Elem * Elem;
	   Atom: Elem
     forall x,y:Elem
     . x <= y <=> x cap y = x           %(leq_def_ExtBooleanAlgebra)%
     . x >= y <=> y <= x                %(geq_def_ExtBooleanAlgebra)%
     . x < y <=> (x <= y /\ not (x=y))  %(less_def_ExtBooleanAlgebra)%
     . x > y <=> y < x                  %(greater_def_ExtBooleanAlgebra)%
     . Atom(x) <=> not x = 0 /\ (forall y:Elem . y < x => y = 0) %(def_Atom)%
end


spec BooleanAlgebraWithPartialOrder = 
	ExtBooleanAlgebraByPartialOrder[BooleanAlgebra]
end


spec AtomicBooleanAlgebra =
     { BooleanAlgebraWithPartialOrder hide pred Atom }
then
     sort Atom = {x: Elem . not x = 0 /\ (forall y:Elem . y < x => y = 0)}
     forall x:Elem
     . not x = 0 => (exists y:Atom . y <= x) 	
end


spec Set [sort Elem] = %mono
     GenerateSet [sort Elem]
then %def
     preds  isNonEmpty:       Set[Elem];
          __ isSubsetOf __: Set[Elem] * Set[Elem]
     ops    {__}: Elem -> Set[Elem];
         __ + __ : Elem * Set[Elem] -> Set[Elem];
         __ - __ : Set[Elem] * Elem -> Set[Elem];
         __ intersection __, 
         __ union__,
         __ - __:  Set[Elem] * Set[Elem] -> Set[Elem];

     %% implied operation attributes

     ops
         __ union __ : Set[Elem] * Set[Elem] -> Set[Elem], 
			assoc, comm, idem, unit {}; %implied
         __ intersection __ : Set[Elem] * Set[Elem] -> Set[Elem],
                       assoc, comm, idem;   %implied
     forall x,y: Elem; M,N,O: Set[Elem]
     %% axioms concerning predicates
     . isNonEmpty(M) <=> not M = {}             %(isNonEmpty_def)%
     . M isSubsetOf N <=> 
     forall x: Elem. x eps M => x eps N         %(isSubsetOf_def)%
     %% axioms concerning operations
     . { x } = {} + x                           %(singletonSet_def)%
     . x + M = M + x                            %(addElem_def_Set)%
     . {}      - y  = {}                        %(remElem_EmptySet)%
     . (M + x) - y  =  M-y   when x=y else
                   (M-y) + x                    %(remElem_NonEmptySet)%
     . M intersection {}    = {}                %(intersection_Emptyset)%
     . M intersection (N+x) = 
      (M intersection N) + x when x eps M else
       M intersection N                         %(intersection_NonEmptySet)%
     . M union {}    =  M                       %(union_EmptySet)%
     . M union (N+x) =  M union N      when x eps M else
                    (M union N) + x             %(union_NonEmptySet)%
     . M - {} = M                               %(dif_Emptyset)%
     . M - (N+x) = (M - N) - x                  %(dif_Emptyset)%
     %% important laws
     . (M union N) intersection O = 
        (M intersection O) union (N intersection O)
                                                %(distr1_Set)% %implied
     . O intersection (M union N) = 
         (O intersection M) union (O intersection N)
                                                %(distr2_Set)% %implied
then %implies
     forall x,y: Elem; M,N:Set[Elem]
     . M isSubsetOf (M union N)                 %(union_isSubsetOf)%
      . (M intersection N) isSubsetOf M         %(intersection_isSubsetOf)%
end




view Set_as_PartialOrder  [sort Elem] :
     PartialOrder to Set [sort Elem] 
=
     sort Elem     |-> Set[Elem] ,
     pred __ <= __ |-> __ isSubsetOf __
end


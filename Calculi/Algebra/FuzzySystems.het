library Calculi/Algebra/FuzzySystems
version 0.1
%authors: Regivan Hugo Nunes Santiago, Christian Maeder
%date: 2008-06-24
%email: Christian.Maeder@dfki.de

%{
    This library defines some basic concepts for fuzzy systems
}%

%display  __intersection__ %LATEX __\cap__
%display  __union__        %LATEX __\cup__
%display  __subseteq__     %LATEX __\subseteq__
%display  __subset__       %LATEX __\subset__

from Basic/RelationsAndOrders get TotalOrder, ExtTotalOrder

%{ an underspecified unit interval with a total order plus 0 and 1
   as minimum resp. maximum }%
spec UnitInterval = TotalOrder with Elem |-> UnitInterval
then
     ops 0 : UnitInterval; 1 : UnitInterval
     var x : UnitInterval
     . 0 <= x %(ge_0)%
     . x <= 1 %(le_1)%

%{ any monotone, symmetric and associative, binary junctor called J
   as basis to define t-norms and t-conorms }%
spec MonotoneJunctor[UnitInterval] =
     op J : UnitInterval * UnitInterval -> UnitInterval, comm, assoc
     vars x, y, z, w : UnitInterval
     . x <= y /\ w <= z => J(x, w) <= J(y, z) %(monotonicity)%

%% a t-norm has the boundary 1 and is called T
spec TNorm[UnitInterval] = MonotoneJunctor[UnitInterval] with J |-> T
then
     forall x : UnitInterval . T(x, 1) = x %(boundary_1)%

%% a t-conorm has the boundary 0 and is called C
spec TConorm[UnitInterval] = MonotoneJunctor[UnitInterval] with J |-> C
then
     forall x : UnitInterval . C(x, 0) = x %(boundary_0)%

%% an underspecified complement over a unit interval
spec Complement[UnitInterval] =
     op compl __ : UnitInterval -> UnitInterval
     . compl 0 = 1
     . compl 1 = 0

%% putting t-norm and t-conorm together
spec Junctors[UnitInterval] = TNorm[UnitInterval]
and  TConorm[UnitInterval]
%% if the complement and further properties are needed here is open
and  Complement[UnitInterval]

%% abstract total functions with application and extensionality
spec Function[sort Domain][sort Codomain] =
     sort Function
     %% application operation
     op __@__ : Function * Domain -> Codomain
     vars A, B: Function
     . A = B <=> forall x : Domain . A @ x = B @ x %(extensionality)%

%% type-1 fuzzy sets over a universe and an underspecified unit interval
spec FuzzySet[Junctors[UnitInterval]][sort Universe] =
     ExtTotalOrder[UnitInterval fit Elem |-> UnitInterval]
     with min : UnitInterval * UnitInterval -> UnitInterval
and  Function[sort Universe][sort UnitInterval]
     with Function |-> FuzzySet
then
     ops __intersection__, __union__, minimum : FuzzySet * FuzzySet -> FuzzySet,
         comm, assoc %implied
     preds __subseteq__, __subset__ : FuzzySet * FuzzySet
     op complement __ : FuzzySet -> FuzzySet
     vars x : Universe; A, B: FuzzySet
     . A subseteq B <=> forall x : Universe . A @ x <= B @ x
     . A subset B <=> not A = B /\ A subseteq B
     . (A intersection B) @ x = T(A @ x, B @ x)
     . (A union B) @ x = C(A @ x, B @ x)
     . minimum(A, B) @ x = min(A @ x, B @ x)
     . complement A @ x = compl (A @ x)

%% now fix the unit interval for more concrete fuzzy sets
from Basic/Numbers get Rat

spec ConcretUnitInterval = Rat
then sort UnitInterval = { x : Rat . 0 <= x /\ x <= 1 }

%% only the sort Universe is a formal parameter now
spec ConcretFuzzySet [sort Universe] given ConcretUnitInterval =
     FuzzySet[Junctors[UnitInterval]][sort Universe]

%% get the maximal confidence over the range
spec MaxOnRange[sort Universe] given ConcretUnitInterval =
     ConcretFuzzySet[sort Universe]
then op maxOnRange : FuzzySet -> UnitInterval
     var P : FuzzySet; m : UnitInterval
     . maxOnRange(P) = m <=> exists y : Universe . forall x : Universe .
       P @ x <= m /\ P @ y = m

%% define various subsorts of functions from Rat
spec PreFuzzyNumber = ConcretFuzzySet[sort Rat] with FuzzySet |-> PreFuzzyNumber

spec QuasiFuzzyNumber = PreFuzzyNumber
then sort QuasiFuzzyNumber =
     { x : PreFuzzyNumber
       . true %(convex)%
       /\ true %(piecewise_continuous)% }

spec FuzzyNumber = QuasiFuzzyNumber
and  MaxOnRange[sort Rat] with FuzzySet |-> PreFuzzyNumber
then sort FuzzyNumber =
     { x : QuasiFuzzyNumber
       . maxOnRange(x) = 1 %(normalized)% }

%%--------------------- Singletons -------------------------
spec Sing[sort Universe] given ConcretUnitInterval =
     ConcretFuzzySet[sort Universe]
then op Sing __ : Universe -> FuzzySet
     var r, s : Universe
     . Sing r @ s = 1 when r = s else 0
     sort Sing =
     { x : FuzzySet
       . exists r: Universe . Sing r = x }

%%--------------- Trapezoidal Fuzzy Numbers ----------------
spec Trapez = FuzzyNumber
then op trapez : Rat * Rat * Rat * Rat ->? FuzzyNumber
     vars x, a, b, c, d : Rat; t : FuzzyNumber
     . a <= b /\ b <= c /\ c <= d => def trapez(a, b, c, d)
     . x <= a /\ t = trapez(a, b, c, d)
       => t @ x = 0
     . a < x /\ x <= b /\ t = trapez(a, b, c, d)
       => t @ x = (x - a) / (b - a)
     . b <= x /\ x <= c /\ t = trapez(a, b, c, d)
       => t @ x = 1
     . c < x /\ x <= d /\ t = trapez(a, b, c, d)
       => t @ x = (d - x) / (d - c)
     . d <= x /\ t = trapez(a, b, c, d)
       => t @ x = 0

%%------------- Triangular Fuzzy Numbers ----------------
spec Triange = Trapez
then op triangle : Rat * Rat * Rat ->? FuzzyNumber
     vars a, b, c : Rat
     . triangle (a, b, c) = trapez(a, b, b, c)

%%------------- Piecewise Quadratic Fuzzy Numbers ------------

%%------------- Normal Quadratic Fuzzy Numbers ------------


%%--------------------- Linguistic Variables ---------------

%% values of a universe sort with a confidence
spec Value [sort Universe] given ConcretUnitInterval =
     free type Value ::=
          ConfValue (rawValue : Universe; cf : UnitInterval)

from Basic/StructuredDatatypes get String, Set, Bag, Map

%% strings within terms
spec TS = String
then free type TS ::= TS(String)

%% strings for hedges
spec HS = String
then free type HS ::= HS(String)

%% strings for concepts
spec CS = String
then free type CS ::= CS(String)

%% terms constructed from basic term strings and hedge applications
spec Term = TS and HS
then free type Term ::= Leaf(TS) | Cons(HS; Term)

%% instantiate values with terms
spec LinguisticTerm = Term
then Value[sort Term]

%% sets of linguistic terms
spec LinguisticTerms = LinguisticTerm
then Set[sort Value] with pred __eps__ : Value * Set[Value]

%% map term strings to fuzzy sets
spec ConfidenceMap[sort Universe] given ConcretUnitInterval = TS
and  ConcretFuzzySet[sort Universe]
then Map[sort TS][sort FuzzySet]
     with op lookup : TS * Map[TS, FuzzySet] ->? FuzzySet

%% --------------------- Hedges ---------------------------
spec Hedge = ConcretUnitInterval
then Function[sort UnitInterval][sort UnitInterval] with Function |-> Hedge

%% examples are ^2 for "very" or ^1/3 for "slightly"

%% associating hedge names to functions
spec HedgeMap = HS and Hedge
then Map[sort HS][sort Hedge]

%% a linguistic variables over a universe
spec LinguisticVariable[sort Universe] given ConcretUnitInterval = CS
and  LinguisticTerms and HedgeMap
and  ConfidenceMap[sort Universe]
then generated type LVar ::= LVar(
       name : CS;
       Set[Value];
       Map[HS, Hedge];
       Map[TS, FuzzySet])?
     %% function composition for fuzzy sets with hedges
     op __o__ : Hedge * FuzzySet -> FuzzySet
     vars h : Hedge; f : FuzzySet; x : Universe
     . (h o f) @ x = h @ (f @ x)

     %% lookup and compose the fuzzy set for a term
     op eval : Term * Map[HS, Hedge] * Map[TS, FuzzySet] -> FuzzySet
     vars ts : TS; hs : HS; t : Term;
          HM : Map[HS, Hedge]; CM : Map[TS, FuzzySet]
     . eval (Leaf(ts), HM, CM) = lookup(ts, CM)
     . eval (Cons(hs, t), HM, CM)
       = lookup(hs, HM) o eval(t, HM, CM)

%%--------------------- Fuzzification ----------------------

spec Fuzzify[sort Universe] given ConcretUnitInterval =
     LinguisticVariable[sort Universe]
     with op __intersection__ : FuzzySet * FuzzySet -> FuzzySet
and  MaxOnRange[sort Universe]
then %% only changes the confidence of the terms in the linguistic variables
     op fuzzify : FuzzySet * LVar -> LVar
     vars cname : CS; %% unchanged concept name
          A : FuzzySet; %% input
          HM : Map[HS, Hedge]; %% fixed hedge map
          CM : Map[TS, FuzzySet]; %% confidence map
          S, Ta : Set[Value]; %% terms before and after fuzzification
     %% for a term string t take the minimum of the input A and
     %% the corresponding fuzzy set looked up in the confidence map CM
     %% from the minimum fuzzy set choose the maximum over the Range
     %% consider all linguistic terms in the sets
     . fuzzify(A, LVar(cname, S, HM, CM)) = LVar(cname, Ta, HM, CM)
       <=> forall t : Term .
            (exists v : UnitInterval . ConfValue(t, v) eps S)
            <=> ConfValue(t, maxOnRange(A intersection eval(t, HM, CM))) eps Ta

%%--------------------- Defuzzification ----------------------

%% create a constant fuzzy set from a value between 0 and 1
spec Const[sort Universe] given ConcretUnitInterval =
     ConcretFuzzySet[sort Universe]
then op Const __ : UnitInterval -> FuzzySet
     var x : Universe; v : UnitInterval
     . Const v @ x = v

%% constraining a linguistic variable wrt. its terms
spec Constrain[sort Universe] given ConcretUnitInterval =
     LinguisticVariable[sort Universe] and Const[sort Universe]
then op constrain : LVar -> LVar
     vars cname : CS; %% unchanged concept name
          S : Set[Value]; %% unchanged terms
          %% avoid the letter T because that's the T-Norm
          HM : Map[HS, Hedge]; %% fixed hedge map
          CM, CCM : Map[TS, FuzzySet]; %% (constrained) confidence map
     . constrain(LVar(cname, S, HM, CM)) = LVar(cname, S, HM, CCM)
       <=> forall t : Term; v : UnitInterval .
            eval(t, HM, CCM)
            = Const v intersection eval(t, HM, CM)
              when ConfValue(t, v) eps S else eval(t, HM, CM)

%% aggregation functions are symmetric as bags
spec AggregationFunction = ConcretUnitInterval
then Bag[sort UnitInterval]
then op h : Bag[UnitInterval] -> UnitInterval
     var S : Bag[UnitInterval]; v, v0 : UnitInterval
     . not v = v0 /\  freq(S, v) = 0 /\ freq(S, v0) > 0
       => h(S) = v0 %(idempotent)%
     . v > 0 /\ freq(S, v) = 0 /\ freq(S, 0 as UnitInterval) > 0
       => h(S) = 0  %(all_zero)%  %% implied
     . v < 1 /\ freq(S, v) = 0 /\ freq(S, 1 as UnitInterval) > 0
       => h(S) = 1  %(all_one)%   %% implied
     . v0 <= v
       => h(S + v0) <= h(S + v) %(monotonic)%
     . true %(continuous)%

%% aggregate a linguistic variable using a suitable aggregation function
spec Aggregation[sort Universe] given ConcretUnitInterval =
     AggregationFunction
and  LinguisticVariable[sort Universe]
and  Bag[sort Term]
and  Bag[sort FuzzySet]
then %% convert a set of terms to a bag of term names
     op setToBag : Set[Value] -> Bag[Term]
     . setToBag({}) = {}
     vars S : Set[Value]; t : Term; v : UnitInterval
     . setToBag(S + ConfValue(t, v)) = setToBag(S) + t

     %% create a bag of quasi fuzzy number from a confidence map
     op mapToCBag : Map[HS, Hedge] * Map[TS, FuzzySet] * Bag[Term]
          -> Bag[FuzzySet]
     vars HM : Map[HS, Hedge]; CM : Map[TS, FuzzySet]
     . mapToCBag(HM, CM, {}) = {}
     var B : Bag[Term]
     . mapToCBag(HM, CM, B + t) = mapToCBag(HM, CM, B) + eval(t, HM, CM)

     %% extract a bag of confidences for a point
     op mapToUBag : Universe * Bag[FuzzySet] -> Bag[UnitInterval]
     var r : Universe
     . mapToUBag (r, {}) = {}
     vars NB : Bag[FuzzySet]; A : FuzzySet
     . mapToUBag (r, NB + A) = mapToUBag (r, NB) + (A @ r)

     %% construct a fuzzy number from a bag of fuzzy numbers using h
     op aggregate : Bag[FuzzySet] -> FuzzySet
     . aggregate(NB) @ r = h(mapToUBag(r, NB))

     %% putting the above together
     op aggreg : LVar -> FuzzySet
     vars cname : CS; HM : Map[HS, Hedge]
     . aggreg (LVar(cname, S, HM, CM))
       = aggregate(mapToCBag(HM, CM, setToBag(S)))

%% any function that extracts a number from a fuzzy set
%% possibly taking the range into account
spec Projection[sort Universe] given ConcretUnitInterval =
     ConcretFuzzySet[sort Universe]
then op project : FuzzySet -> Universe

%% defuzzification is aggregation followed by projection
spec Defuzz[sort Universe] given ConcretUnitInterval =
     Aggregation[sort Universe] and Projection[sort Universe]
then op defuzz : LVar -> Universe
     var L : LVar
     . defuzz(L) = project(aggreg(L))

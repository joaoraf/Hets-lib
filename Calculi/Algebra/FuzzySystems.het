library Calculi/Algebra/FuzzySystems
version 0.1
%authors: Regivan Hugo Nunes Santiago, Christian Maeder
%date: 2008-06-24
%email: Christian.Maeder@dfki.de

%{
    This library defines some basic concepts for fuzzy systems
}%

%display  __intersection__ %LATEX __\cap__
%display  __union__        %LATEX __\cup__
%display  __subseteq__     %LATEX __\subseteq__
%display  __subset__       %LATEX __\subset__

from Basic/RelationsAndOrders get TotalOrder, ExtTotalOrder

spec UnitInterval = TotalOrder with Elem |-> UnitInterval
then
     ops 0 : UnitInterval; 1 : UnitInterval
     var x : UnitInterval
     . 0 <= x %(ge_0)%
     . x <= 1 %(le_1)%

spec MonotoneJunctor[UnitInterval] =
     op J : UnitInterval * UnitInterval -> UnitInterval, comm, assoc
     vars x, y, z, w : UnitInterval
     . x <= y /\ w <= z => J(x, w) <= J(y, z) %(monotonicity)%

spec TNorm[UnitInterval] = MonotoneJunctor[UnitInterval] with J |-> T
then
     forall x : UnitInterval . T(x, 1) = x %(boundary_1)%

spec TConorm[UnitInterval] = MonotoneJunctor[UnitInterval] with J |-> C
then
     forall x : UnitInterval . C(x, 0) = x %(boundary_0)%

spec Complement[UnitInterval] =
     op compl __ : UnitInterval -> UnitInterval
     . compl 0 = 1
     . compl 1 = 0

spec Junctors[UnitInterval] = TNorm[UnitInterval]
and TConorm[UnitInterval]
and Complement[UnitInterval]
then vars x, y : UnitInterval
     %% de Morgan ??
     . compl T(x, y) = C(compl x, compl y)
     . compl C(x, y) = T(compl x, compl y)

spec FuzzySet[Junctors[UnitInterval]][sort Universe] =
     ExtTotalOrder[UnitInterval fit Elem |-> UnitInterval]
     with min : UnitInterval * UnitInterval -> UnitInterval
then sort FuzzySet
     %% application
     op __@__ : FuzzySet * Universe -> UnitInterval
     ops __intersection__, __union__, minimum : FuzzySet * FuzzySet -> FuzzySet,
         comm, assoc %implied
     preds __subseteq__, __subset__ : FuzzySet * FuzzySet
     op complement __ : FuzzySet -> FuzzySet
     vars x : Universe; A, B: FuzzySet
     . A = B <=> forall x : Universe . A @ x = B @ x %(extensionality)%
     . A subseteq B <=> forall x : Universe . A @ x <= B @ x
     . A subset B <=> not A = B /\ A subseteq B
     . (A intersection B) @ x = T(A @ x, B @ x)
     . (A union B) @ x = C(A @ x, B @ x)
     . minimum(A, B) @ x = min(A @ x, B @ x)
     . complement A @ x = compl (A @ x)

%% now fix the unit interval for more concrete fuzzy sets
from Basic/Numbers get Rat

spec ConcretUnitInterval = Rat
then sort UnitInterval = { x : Rat . 0 <= x /\ x <= 1 }

%% only the sort Universe is a formal parameter now
spec ConcretFuzzySet [sort Universe] given ConcretUnitInterval =
     FuzzySet[Junctors[UnitInterval]][sort Universe]

%% define various subsorts of functions from Rat
spec PreFuzzyNumber = ConcretFuzzySet[sort Rat] with FuzzySet |-> PreFuzzyNumber

spec QuasiFuzzyNumber = PreFuzzyNumber
then sort QuasiFuzzyNumber =
     { x : PreFuzzyNumber
       . true %(convex)%
       /\ true %(piecewise_continuous)% }

spec FuzzyNumber = QuasiFuzzyNumber
then sort FuzzyNumber =
     { x : QuasiFuzzyNumber
       . exists r : Rat . x @ r = 1 %(normalized)% }

%%--------------------- Singletons -------------------------
spec Sing = PreFuzzyNumber
then op Sing __ : Rat -> PreFuzzyNumber
     var r, s : Rat
     . Sing r @ s = 1 when r = s else 0
     sort Sing =
     { x : PreFuzzyNumber
       . exists r: Rat . Sing r = x }

%%--------------------- Singletons or quasi fuzzy numbers
spec SingOrQuasiFuzzyNumber = QuasiFuzzyNumber and Sing
then sort SingOrQuasiFuzzyNumber =
     { x : PreFuzzyNumber . x in QuasiFuzzyNumber \/ x in Sing }

%%--------------- Trapezoidal Fuzzy Numbers ----------------
spec Trapez = FuzzyNumber
then op trapez : Rat * Rat * Rat * Rat ->? FuzzyNumber
     vars x, a, b, c, d : Rat; t : FuzzyNumber
     . a <= b /\ b <= c /\ c <= d => def trapez(a, b, c, d)
     . x <= a /\ t = trapez(a, b, c, d)
       => t @ x = 0
     . a < x /\ x <= b /\ t = trapez(a, b, c, d)
       => t @ x = (x - a) / (b - a)
     . b <= x /\ x <= c /\ t = trapez(a, b, c, d)
       => t @ x = 1
     . c < x /\ x <= d /\ t = trapez(a, b, c, d)
       => t @ x = (d - x) / (d - c)
     . d <= x /\ t = trapez(a, b, c, d)
       => t @ x = 0

%%------------- Triangular Fuzzy Numbers ----------------
spec Triange = Trapez
then op triangle : Rat * Rat * Rat ->? FuzzyNumber
     vars a, b, c : Rat
     . triangle (a, b, c) = trapez(a, b, b, c)

%%------------- Piecewise Quadratic Fuzzy Numbers ------------

%%------------- Normal Quadratic Fuzzy Numbers ------------


%%--------------------- Linguistic Variables ---------------

%% values of a universe sort with a confidence
spec Value [sort Universe] given ConcretUnitInterval =
     free type Value ::=
          ConfValue (rawValue : Universe; cf : UnitInterval)

from Basic/StructuredDatatypes get String, Set, Map

%% strings within terms
spec TS = String
then free type TS ::= TS(String)

%% strings for concepts
spec CS = String
then free type CS ::= CS(String)

%% instantiate values with strings for terms
spec LinguisticTerm = TS
then Value[sort TS]

%% sets of linguistic terms
spec LinguisticTerms = LinguisticTerm
then Set[sort Value] with pred __eps__ : Value * Set[Value]

%% map term strings to quasi fuzzy number
spec ConfidenceMap = TS and QuasiFuzzyNumber
then Map[sort TS][sort QuasiFuzzyNumber]
     with op lookup : TS * Map[TS, QuasiFuzzyNumber] ->? QuasiFuzzyNumber

%% only consider subsorts of Rat as Range for linguistic variables
spec LinguisticVariable[sort Range] = CS
and LinguisticTerms
and ConfidenceMap
then sort Range < Rat
     generated type LVar ::= LVar(
       name : CS;
       Set[Value];
       Map[TS, QuasiFuzzyNumber])?

%%--------------------- Fuzzification ----------------------

spec Fuzzify[sort Range] = 
    SingOrQuasiFuzzyNumber 
    with op minimum : PreFuzzyNumber * PreFuzzyNumber -> PreFuzzyNumber
and LinguisticVariable[sort Range]
then %% get the maximal confidence over the range
     op maxOnRange : PreFuzzyNumber -> UnitInterval
     var P : PreFuzzyNumber; m : UnitInterval
     . maxOnRange(P) = m <=> exists y : Range . forall x : Range .
       P @ x <= m /\ P @ y = m
     %% only changes the confidence of the terms in the linguistic variables
     op fuzzify : SingOrQuasiFuzzyNumber * LVar -> LVar
     vars cname : CS; %% unchanged concept name
          A : SingOrQuasiFuzzyNumber; %% input
          CM : Map[TS, QuasiFuzzyNumber]; %% confidence map
          S, Ta : Set[Value]; %% terms before and after fuzzification
     %% for a term string t take the minimum of the input A and
     %% the corresponding quasi fuzzy number looked up in the confidence map CM
     %% from the minimum PreFuzzyNumber choose the maximum over the Range
     %% consider all linguistic terms in the sets
     . fuzzify(A, LVar(cname, S, CM)) = LVar(cname, Ta, CM)
       <=> forall t : TS . 
            (exists v : UnitInterval . ConfValue(t, v) eps S)
            <=> ConfValue(t, maxOnRange(minimum(A, lookup(t, CM)))) eps Ta

%%--------------------- Defuzzification ----------------------

library Calculi/Algebra/RelationAlgebra
version 0.2
%author: T. Mossakowski, K. Lüttich, S. Wölfl
%date: 07-02-2005

%( 
    This library defines some basic concepts from the 
    theory of relation algebras 
)%


%left_assoc __cup__,__cap__
%prec {__cup__} < {__cmps__} 
%prec {__cmps__} < {__cmpl__} 


from Basic/Numbers get Nat
%% from Basic/StructuredDatatypes get Set
from Calculi/Algebra/Auxiliary get Set
from Calculi/Algebra/Auxiliary get BooleanAlgebraWithCompl,
		ExtBooleanAlgebraByPartialOrder,AtomicBooleanAlgebra 
from Basic/RelationsAndOrders version 0.7 get BooleanAlgebra,RichBooleanAlgebra


%( 
    First we define the concept of a relation algebra,
    according to I. Hodkinson, Atom structures of relation algebras, 1995.  
)%




spec RelationAlgebra  =
     BooleanAlgebraWithCompl with sort Elem |-> Rel 
then
     ops
	        id: Rel;
	    conv__: Rel -> Rel;
	  __cmps__: Rel * Rel -> Rel, assoc, unit id;
	
     forall x,y,z: Rel
%%     . (x cmps y) cmps z = x cmps (y cmps z)            	%(cmps_assoc)%
%%     . x cmps id = x /\ id cmps x = x				%(cmps_unit_id)%
     . conv(conv(x)) = x					%(conv_idempot)%
     . conv(x cup y) = conv(x) cup conv(y)			%(conv_cup)%
     . conv(compl(x)) = compl(conv(x))				%(conv_compl)%
     . conv(x cmps y) = conv(y) cmps conv(x)			%(conv_cmps)%
     . (x cmps y) cap conv(z) = 0 => (y cmps z) cap conv(x) = 0 %(triangle)% 

then %implies
     forall x,y,z: Rel
     . (x cup y) cmps z = (x cmps z) cup (y cmps z)		%(cmps_cup_rdistrib)%
     . z cmps (x cup y) = (z cmps x) cup (z cmps y)	  	%(cmps_cup_ldistrib)%
     . conv(x) cmps (compl(x cmps y) cup compl(y)) = compl(y)   %(RelAlg)%
     . (x cmps y) cap z = 0 => (conv(x) cmps z) cap y = 0 	%(lPeircean)%
     . (x cmps y) cap z = 0 => (z cmps conv(y)) cap x = 0 	%(rPeircean)%
end


spec ExtRelationAlgebraByPartialOrder[RelationAlgebra] = %def
     ExtBooleanAlgebraByPartialOrder[BooleanAlgebra] with sort Elem |-> Rel

then %implies
    forall x,y,z,x',y': Rel
    . x <= x' /\ y <= y' => x cmps y <= x' cmps y'    		%(cmps_monotonic)%
    . x <= id => conv(x) = x					%(conv_below_id)%
    . conv(id) = id						%(conv_id)%
end


spec RelationAlgebraWithPartialOrder = ExtRelationAlgebraByPartialOrder[RelationAlgebra]


spec IntegralRelationAlgebra =
     RelationAlgebraWithPartialOrder
then 
     . Atom(id)
then %implies
     forall x,y:Rel
     . x cmps y = 0 => x=0 \/ y = 0
end


spec SymmetricRelationAlgebra =
     RelationAlgebra
then 
     forall x:Rel
     . conv(x) = x
end


spec CommutativeRelationAlgebra =
     RelationAlgebra
then 
     op
	  __cmps__: Rel * Rel -> Rel, assoc, comm, unit id
end

	

spec AtomicRelationAlgebra = 
     { RelationAlgebraWithPartialOrder hide pred Atom }
and
     AtomicBooleanAlgebra with sort Elem |-> Rel, Atom |-> AtomRel
end



%(
    If the set of base relations is JEPD, i.e., is the base relations are 
    pairwise disjoint and jointly exhaustive, unions of base relations can be
    represented as sets of base relations.
)%


spec RelationRep[sort BaseRel] = %mono
     { Set[sort BaseRel fit Elem |-> BaseRel] 
	    with Set[BaseRel] |-> Rel,
	            __union__ |-> __cup__, 
             __intersection__ |-> __cap__ }
then %def
     sort BaseRel < Rel
     ops 
	    0,1 : Rel;
	 compl__: Rel -> Rel; 

     forall x:BaseRel; y:Rel
     . x = {x}
     . x eps 1
     . not x eps 0
     . compl(y) = 1 - y

then %implies
     forall x,y:BaseRel; r:Rel
     . not x = y => x cap y = 0		
     . r isSubsetOf 1
then
     ops	 	 
         id      : BaseRel;
	 conv__  : BaseRel -> BaseRel; 
         __cmps__: BaseRel * BaseRel -> Rel
     forall x:BaseRel
     . x cmps id = x
     . id cmps x = x
     . conv(id) = id
     . conv(conv(x)) = x
end



view RelationRep_as_BoolenAlgebraWithCompl:
     BooleanAlgebraWithCompl to RelationRep[sort BaseRel]
= 
     Elem |-> Rel
end



spec GenerateRelationAlgebra[RelationRep[sort BaseRel]] = %mono
     ops 
    %%      id      : Rel;
          conv__  : Rel -> Rel;
	  __cmps__: Rel * Rel -> Rel, assoc, unit id;       
						 %% composition of relations
     forall x,y:BaseRel; u,v:Rel
     . (u cup x) cmps (v cup y) =
	  (u cmps v) cup (u cmps y) cup (x cmps v) cup (x cmps y)      
     . conv(u cup x) = conv(u) cup conv(x)
end


spec GeneratedRelationAlgebra = 
     GenerateRelationAlgebra[RelationRep[sort BaseRel]]


view GeneratedRelationAlgebra_as_RelationAlgebra:
     RelationAlgebra to GeneratedRelationAlgebra 
end 


view GeneratedRelationAlgebra_as_AtomicRelationAlgebra:
     AtomicRelationAlgebra 
to
     { GeneratedRelationAlgebra  
	then %def
	preds 
		__<__,__<=__,__>__,__>=__:Rel*Rel
	forall x,y:Rel
	. x < y  <=> x isSubsetOf y /\ not x = y
	. x <= y <=> x isSubsetOf y
	. x > y  <=> y isSubsetOf x /\ not x = y
	. x >= y <=> y isSubsetOf x
     }
=
     sort Rel |-> Rel, sort AtomRel |-> BaseRel
end 



spec CompositionTable =
     sorts BaseRel < Rel
     ops 
	 id,0,1:Rel;
	 conv__:   BaseRel -> Rel;
         compl__:   Rel -> Rel;
	 __cmps__: BaseRel * BaseRel -> Rel;
	 __cup__:  Rel * Rel -> Rel, assoc, idem, comm, unit 1;
	 __cap__:  Rel * Rel -> Rel, assoc, idem, comm, unit 0;  
end








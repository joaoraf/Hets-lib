library Calculi/Algebra/RelationAlgebraModel

version 0.4
%author: S. Wölfl
%date: 20-06-2005

%( 
    This library defines some basic higher order concepts from the 
    theory of relation algebras (cf., for example, I. Hodkinson, Atom
    structures of relation algebras, 1995).
)%

from HasCASL/Set get Set
from Calculi/Algebra/RelationAlgebra get 
	RelationAlgebra,
	NonAssocRelationAlgebra,
	ExtPseudoRelationAlgebraByOrderRelations, 
	RelationAlgebraWithOrderRelations,
	AtomicRelationAlgebra,
	AtomicNonAssocRelationAlgebra
from Calculi/Algebra/RelationAlgebraSymbolic get CompositionTable
from Calculi/Algebra/BooleanAlgebra get BooleanAlgebraWithCompl


logic HasCASL


%( Part I: Set Algebras of Binary Relations and Algebras of Binary Relations
)% 




spec BinaryRelations[sort Elem] = 
     Set	
then %def
     type Relation ::= abs(rep:Set(Elem*Elem))
end


spec FullAlgebraOfBinaryRelations[sort Elem] =
	BinaryRelations[sort Elem] 
then %def
     ops
	 0,1,id:Relation;
         __cup__,__cap__,__cmps__: Relation * Relation -> Relation;
         compl__,inv__: Relation -> Relation

     forall r,s:Relation; x,y:Elem
     . rep(0) = emptySet
     . rep(1) = allSet
     . rep(r cup s) = rep(r) union rep(s)
     . rep(r cap s) = rep(r) intersection rep(s)
     . rep(compl(r)) = rep(1) \\ rep(r)
     . (x,y) isIn rep(id) <=> x = y
     . (x,y) isIn rep(r cmps s) <=> exists z:Elem . (x,z) isIn rep(r) /\ (z,y) isIn rep(s) 
     . (x,y) isIn rep(inv(r)) <=> (y,x) isIn rep(r)

then %implies 
     ops
         __cup__:  Relation * Relation -> Relation, assoc, comm, idem, unit 0;
	 __cap__:  Relation * Relation -> Relation, assoc, comm, idem, unit 1;
         __cmps__: Relation * Relation -> Relation, assoc, unit id;

     forall x:Relation
     . compl(compl(x)) = x 
     . inv(inv(x)) = x 
     . inv(id) = id
end



spec SetAlgebraOfBinaryRelations1[sort Elem] =
     FullAlgebraOfBinaryRelations[sort Elem] 
then
     sort Rel < Relation
     ops
	 0,1:Rel;
         __cup__,__cap__: Rel * Rel -> Rel;
         compl__: Rel -> Rel
	%% hide sort Relation 
then %implies 
     ops
         __cup__:  Rel * Rel -> Rel, assoc, comm, idem, unit 0;
	 __cap__:  Rel * Rel -> Rel, assoc, comm, idem, unit 1;
     forall x:Rel
     . compl(compl(x)) = x 
end


spec SetAlgebraOfBinaryRelations[sort Elem] =
local  FullAlgebraOfBinaryRelations[sort Elem] 
within
     sort Rel < Relation
     ops
	 0,1:Rel;
         __cup__,__cap__: Rel * Rel -> Rel;
         compl__: Rel -> Rel

then %implies 
     ops
         __cup__:  Rel * Rel -> Rel, assoc, comm, idem, unit 0;
	 __cap__:  Rel * Rel -> Rel, assoc, comm, idem, unit 1;
     forall x:Rel
     . compl(compl(x)) = x 
end



spec AlgebraOfBinaryRelations1[sort Elem] =
     SetAlgebraOfBinaryRelations[sort Elem] 
then  
     ops
	 id:Rel;
         __cmps__:  Rel * Rel -> Rel;
         inv__: Rel -> Rel
end



spec AlgebraOfBinaryRelations[sort Elem] =
local FullAlgebraOfBinaryRelations[sort Elem] 
within
     sort Rel < Relation
     ops
	 0,1,id:Rel;
         __cup__,__cap__,__cmps__: Rel * Rel -> Rel;
         compl__,inv__: Rel -> Rel;
then %implies 
     ops
         __cup__ :  Rel * Rel -> Rel, assoc, comm, idem, unit 0;
	 __cap__ :  Rel * Rel -> Rel, assoc, comm, idem, unit 1;
	 __cmps__:  Rel * Rel -> Rel, assoc, unit id;
     forall x:Rel
     . compl(compl(x)) = x 
     . inv(inv(x)) = x 
end



view SetAlgebraOfBinaryRelations_as_BooleanAlgebraWithCompl[sort Elem]:
     BooleanAlgebraWithCompl to SetAlgebraOfBinaryRelations[sort Elem]
=
     sort Elem |-> Rel 
end


view AlgebraOfBinaryRelations_as_RelationAlgebra[sort Elem]:
     RelationAlgebra to AlgebraOfBinaryRelations[sort Elem]
=
     sort Rel |-> Rel
end



%( Part II: Models of Syntatic (Abstract) Relation Algebras 
)%


spec ElemStructure =
     sort Elem
end


spec BaseRelationModel[ElemStructure] =
     BinaryRelations[sort Elem]
then 
     type BaseRel < Relation   
     forall r:BaseRel 
     . not rep(r) = emptySet
end


spec JEPDBaseRelationModel[ElemStructure] =
     BaseRelationModel[ElemStructure] 
then 
     forall x,y:Elem; r,s:BaseRel
     . exists r:BaseRel . (x,y) isIn rep(r)			%(JointlyExhaustive)%
     . not r = s => rep(r) intersection rep(s) = emptySet	%(PairwiseDisjoint)%
end



spec GeneratePseudoModelFromBaseRelationModel[BaseRelationModel[ElemStructure]] = %def
     type Rel = {x:Relation . exists X:Set(BaseRel) .  
			(forall y,z:Elem . (y,z) isIn rep(x) <=> 
		(exists r:BaseRel . r isIn X /\ (y,z) isIn rep(r)))}
and
     AlgebraOfBinaryRelations[sort Elem]

then %implies
     type BaseRel < Rel
end


view BooleanAlgebra_from_JEPDBaseRelationModel[JEPDBaseRelationModel[ElemStructure]] :
     BooleanAlgebraWithCompl
to   GeneratePseudoModelFromBaseRelationModel[JEPDBaseRelationModel[ElemStructure]]
=    Elem |-> Rel 
end




%[
spec GenerateBooleanAlgebraModel[JEPDBaseRelationModel[ElemStructure]] = %def
     type Rel = {x:Relation . exists X:Set(BaseRel) .  
			(forall y,z:Elem . (y,z) isIn rep(x) <=> 
		(exists r:BaseRel . r isIn X /\ (y,z) isIn rep(r)))}
and
     SetAlgebraOfBinaryRelations[sort Elem]

then %implies
     type BaseRel < Rel
end


spec GenerateModelFromBaseRelationModel1[JEPDBaseRelationModel[ElemStructure]] = %def
     GenerateBooleanAlgebraModel[JEPDBaseRelationModel[ElemStructure]] 
then %def
     ops
         id:Rel;
	 inv__: Rel -> Rel;
	 __cmps__: Rel * Rel -> Rel

     forall r,s:Rel; x,y:Elem
     . (x,y) isIn rep(id)  <=> x = y
     . (x,y) isIn rep(inv(r)) <=> (y,x) isIn rep(r)
     . (x,y) isIn rep(r cmps s) <=> exists z:Elem . (x,z) isIn rep(r) /\ (z,y) isIn rep(s)
end
]%

library Calculi/Algebra/RelationAlgebraSymbolic
version 0.2
%author: T. Mossakowski, K. Lüttich, S. Wölfl
%date: 12-05-2005

%( 
    This library contains specifications that describe how a relation
    algebra can be built from a finite set of base relations and a composition 
    table.
)%


%left_assoc __cup__,__cap__
%prec {__cup__} < {__cmps__} 
%prec {__cmps__} < {__cmpl__} 


from Basic/Numbers get Nat
%% from Basic/StructuredDatatypes get Set
from Calculi/Algebra/Set get Set
from Calculi/Algebra/BooleanAlgebra get 
	BooleanAlgebra,
	AtomicBooleanAlgebra, 	
	ExtBooleanAlgebraByOrderRelations
from Calculi/Algebra/RelationAlgebra get 
	AtomicRelationAlgebra



%(
    If the set of base relations is JEPD, i.e., is the base relations are 
    pairwise disjoint and jointly exhaustive, unions of base relations can be
    represented as sets of base relations.
)%



%( GenerateBooleanAlgebra introduces relations as sets of base relations.
   The result is atomic Boolean Algebra.
)%

spec GenerateBooleanAlgebra[sort BaseRel] = %mono
     { Set[sort BaseRel fit Elem |-> BaseRel] 
	    with Set[BaseRel] |-> Rel,
	            __union__ |-> __cup__, 
             __intersection__ |-> __cap__ }
then %mono
     sort BaseRel < Rel
     ops 
	    0,1 : Rel;
	  compl__: Rel -> Rel; 

     forall x:BaseRel; r:Rel
     . x = {x}
     . x eps 1
     . not x eps 0
     . compl(r) = 1 - r

then %implies
     ops
	  __cup__: Rel * Rel -> Rel, assoc, idem, comm, unit 0;
          __cap__: Rel * Rel -> Rel, assoc, idem, comm, unit 1;
 
     forall x,y:BaseRel; r:Rel
	     . not x = y => x cap y = 0		
     . exists z:BaseRel . z eps r
     . r isSubsetOf 1
end



view AtomicBooleanAlgebra_from_GenerateBooleanAlgebra[sort BaseRel] :
     AtomicBooleanAlgebra to 
	GenerateBooleanAlgebra[sort BaseRel]
= 
     Elem |-> Rel, AtomElem |-> BaseRel
end


%(
    Spec CompositionTable provides the signature of composition tables,
    and introduces some operations that may be helpful for specifyng	
    new algebras.  
)%


spec CompositionTable =
     sorts BaseRel < Rel
     ops 
         id	 : BaseRel;	 	 
   	   inv__ : BaseRel -> BaseRel;
         __cmps__: BaseRel * BaseRel -> Rel;
     forall x:BaseRel
     . x cmps id = x
     . id cmps x = x
     . inv(id) = id
then ops  
     0,1      : Rel;
     __cup__: Rel * Rel -> Rel, assoc, idem, comm, unit 1;
     compl__: Rel -> Rel	
end




%( Not each composition table is suitable for building an abstract relation algebra.
   The axioms that need to be fullfilled are specified in GroundingCompositionTable.
)%


spec GroundingCompositionTable =
     sort BaseRel
and  CompositionTable
then local  GenerateBooleanAlgebra[sort BaseRel]

within
     forall x,y,z:BaseRel
     . inv(x) eps (y cmps z) <=> inv(z) eps (x cmps y)
%% etc.
end




spec GeneratePseudoRelationAlgebra[sort BaseRel][CompositionTable] = %def
     GenerateBooleanAlgebra[sort BaseRel]
then %def
     ops 
	  id	  : Rel;
          inv__   : Rel -> Rel;
	  __cmps__: Rel * Rel -> Rel       

     forall x,y:BaseRel; r,s:Rel
     . x eps inv(r) <=> inv(x) eps r
     . x eps (r cmps s) <=> 
	  exists y,z:BaseRel .y eps r /\ z eps s /\ x eps (y cmps z) 

then %implies
     op __cmps__: Rel * Rel -> Rel, unit id;       
     forall x,y,z:BaseRel; r,s:Rel
     . inv(0) = 0
     . inv(r cup x) = inv(r) cup inv(x)
     . inv(inv(r)) = r
     . r cmps 0 = 0 /\ 0 cmps r = 0
     . (r cup x) cmps (s cup y) =
	  (r cmps s) cup (r cmps y) cup (x cmps s) cup (x cmps y)
end


spec GeneratedPseudoRelationAlgebra =  
     GeneratePseudoRelationAlgebra[sort BaseRel][CompositionTable]


spec GenerateExtPseudoRelationAlgebra[sort BaseRel][CompositionTable] = %def
     GeneratePseudoRelationAlgebra[sort BaseRel][CompositionTable] 
and
     ExtBooleanAlgebraByOrderRelations[BooleanAlgebra with sort Elem |-> Rel]

then %implies
     forall x,y:Rel
     . x < y  <=> x isSubsetOf y /\ not x = y
     . x <= y <=> x isSubsetOf y
     . x > y  <=> y isSubsetOf x /\ not x = y
     . x >= y <=> y isSubsetOf x		
end


spec RichGeneratedPseudoRelationAlgebra =  
     GenerateExtPseudoRelationAlgebra[sort BaseRel][CompositionTable]


view PseudoRelationAlgebra_as_AtomicRelationAlgebra[sort BaseRel][GroundingCompositionTable]:
     AtomicRelationAlgebra 
to
     GenerateExtPseudoRelationAlgebra[sort BaseRel][GroundingCompositionTable]
=
     Rel |-> Rel, AtomRel |-> BaseRel
end 




%(  Combinations Of Syntactically Defined  Relation Algebras)%



spec GenerateProductOfBaseRelations
	[sort BaseRel1][sort BaseRel2]
= %mono
     free type BaseRel ::= <__-__> (first:BaseRel1;second:BaseRel2)
     forall x,y:BaseRel
     . x = y <=> first(x) = first(y) /\ second(x) = second(y)
end


spec GenerateProductOfCompositionTables
	[CompositionTable  with BaseRel |-> BaseRel1, Rel |-> Rel1]
	[CompositionTable  with BaseRel |-> BaseRel2, Rel |-> Rel2]
= %def 
     GenerateProductOfBaseRelations
	[sort BaseRel1][sort BaseRel2] 
then CompositionTable 
then local
     { GenerateBooleanAlgebra[sort BaseRel] }
      and
      closed { GenerateBooleanAlgebra[sort BaseRel1] with sort Rel |-> Rel1 }
      and
      closed { GenerateBooleanAlgebra[sort BaseRel2] with sort Rel |-> Rel2 } 		
within
     forall x,y,z:BaseRel
     . id = <id - id>
     . inv(x) = <inv(first(x)) - inv(second(x))>
     . x eps (y cmps z) <=> first(x) eps (first(y) cmps first(z)) /\ 
			second(x) eps (second(y) cmps second(z))
end




spec GenerateProductOfPseudoRelationAlgebras
     	[sort BaseRel1][CompositionTable  with BaseRel |-> BaseRel1, Rel |-> Rel1]
     	[sort BaseRel2][CompositionTable  with BaseRel |-> BaseRel2, Rel |-> Rel2]
= %def
     GeneratePseudoRelationAlgebra
	[GenerateProductOfBaseRelations
		[sort BaseRel1][sort BaseRel2]]
	[GenerateProductOfCompositionTables
		[sorts BaseRel1	< Rel1
		 ops  id : BaseRel1;  inv__ : BaseRel1 -> BaseRel1;  __cmps__:BaseRel1 * BaseRel1 -> Rel1; 
          		0,1  : Rel1;  __cup__: Rel1 * Rel1 -> Rel1;  compl__: Rel1 -> Rel1]
		[sorts BaseRel2	< Rel2
		 ops  id : BaseRel2;  inv__ : BaseRel2 -> BaseRel2;  __cmps__:BaseRel2 * BaseRel2 -> Rel2; 
          		0,1  : Rel2;  __cup__: Rel2 * Rel2 -> Rel2;  compl__: Rel2 -> Rel2]]
end


spec ProdOfGeneratedPseudoRelationAlgebras
	[GeneratedPseudoRelationAlgebra with BaseRel |-> BaseRel1, Rel |-> Rel1]
	[GeneratedPseudoRelationAlgebra with BaseRel |-> BaseRel2, Rel |-> Rel2] 
= %mono
     free type BaseRelP ::= __-__ (first:BaseRel1;second:BaseRel2)
     forall x,y:BaseRelP
     . x = y <=> first(x) = first(y) /\ second(x) = second(y)
then %def
     GenerateBooleanAlgebra[sort BaseRelP] with sort Rel |-> RelP
then %def
     ops 
         id	 : BaseRelP;	 	 
   	   inv__ : BaseRelP -> BaseRelP;
         __cmps__: BaseRelP * BaseRelP -> RelP
     forall x,y,z:BaseRelP
     . id = (id:BaseRel1)-(id:BaseRel2)
     . inv(x)=inv(first(x))-inv(second(x))
     . x eps (y cmps z) <=> first(x) eps (first(y) cmps first(z)) /\ 
			second(x) eps (second(y) cmps second(z))
then %def
     GeneratePseudoRelationAlgebra[sort BaseRelP][
	sorts BaseRelP < RelP
	ops 
	  id : BaseRelP;
	  inv__ : BaseRelP -> BaseRelP; 
	__cmps__:BaseRelP * BaseRelP -> RelP; 
          0,1      : RelP;
	  __cup__: RelP * RelP -> RelP;
	  compl__: RelP -> RelP	
] 
end




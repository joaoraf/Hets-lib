library DRA
version 0.1
%author: T. Soller, some fundamental parts by T. Mossakowski / S. Woerfl
%date: 25-10-04
%% Dipol Calculus DRAfp

%left_assoc __cup__
%prec {__cup__} < {__cmps__}

from Basic/StructuredDatatypes get Set

from Basic/Numbers get Nat


spec GeneratedDRA =

     Set[free type BaseRel ::= rrrrp | rrrrA | rrrrn | rrllp | rrllP | rrlln |
			       llrrp | llrrP | llrrn | llllp | llllA | lllln |
			       rrrln | rrlrp | rlrrp | rllrp | rlllp | lrrrn |
			       lrrln | lrlln | llrln | lllrp | ellsp | errsn |
			       leren | relep | slsrp | srsln | lseln | rserp |
			       seseP | esesA | ffbbP | efbsP | ifbiP | bfiiP |
			       sfsiP | beieP | bbffP | bsefP | biifP | iibfP |
			       sisfP | iebeP | ffffA | fefeA | fifiA | fbiiA |
			       fseiA | ebisA | iifbA | eifsA | isebA | bbbbA |
			       sbsbA | ibibA | lllbp | llfln | llbrp | llrfn |
			       lirlp | lfrrn | lriln | lrrip | blrrn | irrln |
			       frrrp | rbrrp | lblln | flllp | brlln | rfllp |
			       rllin | rrlfp | illrp | rilrn | rrblp | rlirp |
			       rrfrn | rrrbn;
	    fit Elem |-> BaseRel]
	 with Set[BaseRel] |-> GenRel, __union__ |-> __cup__
	 
then %def	 
	 
	sort BaseRel < GenRel
	op 0:GenRel = {}
	forall x:BaseRel
	. x = {x}
	 
then %def
	ops
      		1 : GenRel;
	 __ cap __: GenRel * GenRel -> GenRel, assoc, comm, idem, unit 1; 
				       %% intersection
                              
	        id: GenRel;            %% identity relation
	      conv: GenRel -> GenRel;  %% converse of relation
	__ cmps __: GenRel * GenRel -> GenRel, assoc, unit seseP; 
				       %% composition of relations 
                             
then
	
%% base relations are non-void
forall x:BaseRel . not (x = 0)

%% jointly exhaustive ...
. (rrrrp cup (rrrrA cup (rrrrn cup (rrllp cup (rrllP cup (rrlln cup (llrrp cup
	     (llrrP cup (llrrn cup (llllp cup (llllA cup (lllln cup (rrrln cup
	     (rrlrp cup (rlrrp cup (rllrp cup (rlllp cup (lrrrn cup (lrrln cup
	     (lrlln cup (llrln cup (lllrp cup (ellsp cup (errsn cup (leren cup
	     (relep cup (slsrp cup (srsln cup (lseln cup (rserp cup (seseP cup
	     (esesA cup (ffbbP cup (efbsP cup (ifbiP cup (bfiiP cup (sfsiP cup
	     (beieP cup (bbffP cup (bsefP cup (biifP cup (iibfP cup (sisfP cup
	     (iebeP cup (ffffA cup (fefeA cup (fifiA cup (fbiiA cup (fseiA cup
	     (ebisA cup (iifbA cup (eifsA cup (isebA cup (bbbbA cup (sbsbA cup
	     (ibibA cup (lllbp cup (llfln cup (llbrp cup (llrfn cup (lirlp cup
	     (lfrrn cup (lriln cup (lrrip cup (blrrn cup (irrln cup (frrrp cup
	     (rbrrp cup (lblln cup (flllp cup (brlln cup (rfllp cup (rllin cup
	     (rrlfp cup	(illrp cup (rilrn cup (rrblp cup (rlirp cup (rrfrn cup
	     (rrrbn)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
	     = 1

%% ... and pairwise disjoint
. forall x,y:BaseRel . ( not(x=y) => x cap y = 0 )


%% some converses

. ffbbP = conv(bbffP);
. efbsP = conv(bsefP); 

%% seseP equals identity
. seseP = id

%% transitive relations

%% symmetric relations

. ffffA = conv(ffffA);
. esesA = conv(esesA);
 
%% some stuff from compostion table


end 




spec Set1[sort BaseRel] given Nat =
  Set[sort BaseRel fit Elem |-> BaseRel] with Set[BaseRel] |-> GenRel,
      __union__ |-> __cup__, __intersection__ |-> __cap__
then
  sort BaseRel < GenRel
   ops id : BaseRel;
       1  : GenRel;		   %% how to specify this ???
       conv: BaseRel -> GenRel;                %% converse of relation
       __cmps__ : BaseRel * BaseRel -> GenRel
  forall x:BaseRel
  . x = {x}
end


spec GenerateRelationAlgebra
     [Set1[sort BaseRel]] = %mono
  op 0:GenRel = {}
then %def 

  ops conv : GenRel -> GenRel;
       __ cmps __: GenRel * GenRel -> GenRel, assoc, unit id; 
					      %% composition of relations
                                   
  forall x,y:GenRel; u,v:BaseRel

  . not x = y => x cap y = 0
  . (x cup u) cap (y cup v) = ((((x cap y) cup (x cap v)) cup (u cap y)) cup
			      (u cap v)) 
  . (x cup u) cmps (y cup v) = (((x cmps y cup (x cmps v)) cup (u cmps y)) cup
			       (u cmps v))  			      
  . conv(x cup u) = conv(x) cup conv(u)	

end		     




spec DRABase =

     Set1[free type BaseRel ::= rrrrp | rrrrA | rrrrn | rrllp | rrllP | rrlln 
			      | llrrp | llrrP | llrrn | llllp | llllA | lllln 
			      | rrrln | rrlrp | rlrrp | rllrp | rlllp | lrrrn 
			      | lrrln | lrlln | llrln | lllrp | ellsp | errsn
			      | leren | relep | slsrp | srsln | lseln | rserp
			      | seseP | esesA | ffbbP | efbsP | ifbiP | bfiiP
			      | sfsiP | beieP | bbffP | bsefP | biifP | iibfP
			      | sisfP | iebeP | ffffA | fefeA | fifiA | fbiiA
			      | fseiA | ebisA | iifbA | eifsA | isebA | bbbbA
			      | sbsbA | ibibA | lllbp | llfln | llbrp | llrfn
			      | lirlp | lfrrn | lriln | lrrip | blrrn | irrln
			      | frrrp | rbrrp | lblln | flllp | brlln | rfllp
			      | rllin | rrlfp | illrp | rilrn | rrblp | rlirp
			      | rrfrn | rrrbn  ]
						
then

%% universal relation
. 1 = (rrrrp cup (rrrrA cup (rrrrn cup (rrllp cup (rrllP cup (rrlln cup (llrrp
	     cup (llrrP cup (llrrn cup (llllp cup (llllA cup (lllln cup (rrrln
	     cup (rrlrp cup (rlrrp cup (rllrp cup (rlllp cup (lrrrn cup (lrrln
	     cup (lrlln cup (llrln cup (lllrp cup (ellsp cup (errsn cup (leren
	     cup (relep cup (slsrp cup (srsln cup (lseln cup (rserp cup (seseP
	     cup (esesA cup (ffbbP cup (efbsP cup (ifbiP cup (bfiiP cup (sfsiP
	     cup (beieP cup (bbffP cup (bsefP cup (biifP cup (iibfP cup (sisfP
	     cup (iebeP cup (ffffA cup (fefeA cup (fifiA cup (fbiiA cup (fseiA
	     cup (ebisA cup (iifbA cup (eifsA cup (isebA cup (bbbbA cup (sbsbA
	     cup (ibibA cup (lllbp cup (llfln cup (llbrp cup (llrfn cup (lirlp
	     cup (lfrrn cup (lriln cup (lrrip cup (blrrn cup (irrln cup (frrrp
	     cup (rbrrp cup (lblln cup (flllp cup (brlln cup (rfllp cup (rllin
	     cup (rrlfp cup (illrp cup (rilrn cup (rrblp cup (rlirp cup (rrfrn
	     cup (rrrbn)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 

%% the converses
  %% the reverse case could be got by idempotency

. conv(rrrrp) = rrrrn
. conv(rrrrn) = rrrrp

. conv(rrllp) = llrrn
. conv(rrllP) = llrrP
. conv(rrlln) = llrrp

. conv(llrrp) = rrlln
. conv(llrrP) = rrllP
. conv(llrrn) = rrllp

. conv(llllp) = lllln
. conv(lllln) = llllp

. conv(rrrln) = rlrrp
. conv(rrlrp) = lrrrn 
. conv(rlrrp) = rrrln
. conv(rllrp) = lrrln
. conv(rlllp) = llrln
. conv(lrrrn) = rrlrp
. conv(lrrln) = rllrp
. conv(lrlln) = lllrp
. conv(llrln) = rlllp
. conv(lllrp) = lrlln

. conv(ellsp) = lseln
. conv(errsn) = rserp
. conv(leren) = relep
. conv(relep) = leren
. conv(slsrp) = srsln
. conv(srsln) = slsrp
. conv(lseln) = ellsp
. conv(rserp) = errsn

. conv(ffbbP) = bbffP
. conv(efbsP) = bsefP
. conv(ifbiP) = biifP
. conv(bfiiP) = iibfP
. conv(sfsiP) = sisfP
. conv(beieP) = iebeP 
. conv(bbffP) = ffbbP
. conv(bsefP) = efbsP
. conv(biifP) = ifbiP
. conv(iibfP) = bfiiP
. conv(sisfP) = sfsiP
. conv(iebeP) = beieP

. conv(fbiiA) = iifbA
. conv(fseiA) = eifsA
. conv(ebisA) = isebA
. conv(iifbA) = fbiiA
. conv(eifsA) = fseiA
. conv(isebA) = ebisA

. conv(lllbp) = lblln
. conv(llfln) = flllp
. conv(llbrp) = brlln
. conv(llrfn) = rfllp
. conv(lirlp) = rllin
. conv(lfrrn) = rrlfp
. conv(lriln) = illrp
. conv(lrrip) = rilrn
. conv(blrrn) = rrblp
. conv(irrln) = rlirp
. conv(frrrp) = rrfrn
. conv(rbrrp) = rrrbn

. conv(lblln) = lllbp 
. conv(flllp) = llfln
. conv(brlln) = llbrp
. conv(rfllp) = llrfn
. conv(rllin) = lirlp
. conv(rrlfp) = lfrrn
. conv(illrp) = lriln
. conv(rilrn) = lrrip
. conv(rrblp) = blrrn
. conv(rlirp) = irrln
. conv(rrfrn) = frrrp
. conv(rrrbn) = rbrrp

  %% symmetric relations
. conv(rrrrA) = rrrrA
. conv(llllA) = llllA

. conv(esesA) = esesA

. conv(ffffA) = ffffA
. conv(fefeA) = fefeA
. conv(fifiA) = fifiA
. conv(bbbbA) = bbbbA
. conv(sbsbA) = sbsbA
. conv(ibibA) = ibibA 


%% seseP equals identity
. seseP = id
%% better to rename id?


%% some stuff from compostion table - external from semantics!

  %% transitive relations
. (ffbbP cmps ffbbP) = ffbbP
. (bbffP cmps bbffP) = bbffP
. (rrllP cmps rrllP) = rrllP
. (llrrP cmps llrrP) = llrrP

. (ellsp cmps srsln) = (ellsp cup errsn)
. (ellsp cmps errsn) = ((((lrrrn cup llrrp) cup llrrP) cup llrrn) cup lllrp)
. (ellsp cmps relep) = ((((rlllp cup llrln) cup llllp) cup llllA) cup lllln)
. (srsln cmps srsln) = (slsrp cup srsln)
. (slsrp cmps srsln) = ((seseP cup slsrp) cup srsln)
. (relep cmps srsln) = ((((rrrln cup rrllp) cup rrllP) cup rrlln) cup rlllp)
. (relep cmps errsn) = (ellsp cup errsn)
. (esesA cmps lllrp) = rrrln
. (esesA cmps llrln) = rrlrp
%% ... there are many more ;-(

 
%%forall u,v: GenRel; x,y:BaseRel
%%
%%. x = conv(y) <=> y = conv(x) 
%% could be shown by case distiction for constructors 
%% -- but easily by idempotency of conversion too ;-)

end 



%% Generates Relation Algebra with the DRAfp relations 
spec DRA = GenerateRelationAlgebra [DRABase]
end


library Calculi/Space/DRA_X
version 0.1

from Basic/StructuredDatatypes get Set

%author: Dominik Luecke
%date: 2007-04-30
%% Dipol Calculus with 72 relations (DRA 72)

%% General relations are sets of BaseRelations... 
spec SetOfBaseRels[sort BaseRel] = 
     Set[sort BaseRel fit Elem |-> BaseRel] with Set[BaseRel] |-> GenRel,
      __union__ |-> __union__
     then
     sort BaseRel < GenRel
     ops id : BaseRel;
	  1  : GenRel;
	  0  : GenRel = {};
	  compl: GenRel -> GenRel;
	  conv: BaseRel -> BaseRel;
	  __cmps__ : BaseRel * BaseRel -> GenRel
     forall x:BaseRel; u:GenRel
     . x = {x}
     . x eps 1
     . not x eps 0
     . compl(u) = 1 - u

     . x cmps id = x
     . id cmps x = x

     . conv(id) = id
     . conv(conv(x)) = x
then %implies
  forall x,y:BaseRel; u:GenRel
  . not x = y => x intersection y = 0	        %(PairwiseDisjoint)%
  . not u=0 => exists z:BaseRel . z eps u	%(JointlyExhaustive)%
end

%% Definitions for the 24 relations of DRA 24.
spec DipolRelations24[sort Point] =
     type Dipol ::= [__ __](sp : Point; ep : Point)
     free type DipolPointRelation24 ::= r | l | e | s
     free type DipolRelation24 ::= <<__ __ __ __>>(fst:DipolPointRelation24; 
					       snd:DipolPointRelation24; 
					       trd: DipolPointRelation24; 
					       frt: DipolPointRelation24)
     pred >__ __ __< : Dipol * DipolRelation24 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelation24 * Point  
     %% DRA 24 Relations
     sort BaseRelation24 = {x : DipolRelation24 .
			    x = <<r r r r>> \/ x = <<r r r l>> \/
			    x = <<r r l r>> \/ x = <<r r l l>> \/
			    x = <<r l r r>> \/ x = <<r l l r>> \/
			    x = <<r l l l>> \/ x = <<l r r r>> \/
			    x = <<l r r l>> \/ x = <<l r l l>> \/
			    x = <<l l r r>> \/ x = <<l l r l>> \/
			    x = <<l l l r>> \/ x = <<l l l l>> \/
			    x = <<e l l s>> \/ x = <<e s e s>> \/
			    x = <<e r r s>> \/ x = <<l e r e>> \/
			    x = <<r e l e>> \/ x = <<s l s r>> \/
			    x = <<s r s l>> \/ x = <<l s e l>> \/
			    x = <<r s e r>> \/ x = <<s e s e>> 
			   }
     %% Definition of Dipol Relations by Dipol point relations
     forall Dp1,Dp2 : Dipol; rel : BaseRelation24
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       ) 
     op rrrr, rrrl, rrlr, rrll, rlrr, rllr,
	rlll, lrrr, lrrl, lrll, llrr, llrl,
	lllr, llll, ells, eses, errs, lere,
	rele, slsr, srsl, lsel, rser, sese,
	ffbb, efbs : BaseRelation24
     . rrrr = <<r r r r>>
     . rrrl = <<r r r l>>
     . rrlr = <<r r l r>>
     . rrll = <<r r l l>>
     . rlrr = <<r l r r>>
     . rllr = <<r l l r>>
     . rlll = <<r l l l>>
     . lrrr = <<l r r r>>
     . lrrl = <<l r r l>>
     . lrll = <<l r l l>>
     . llrr = <<l l r r>>
     . llrl = <<l l r l>>
     . lllr = <<l l l r>>
     . llll = <<l l l l>>
     . ells = <<e l l s>>
     . eses = <<e s e s>>
     . errs = <<e r r s>>
     . lere = <<l e r e>>
     . rele = <<r e l e>>
     . slsr = <<s l s r>>
     . srsl = <<s r s l>>
     . lsel = <<l s e l>>
     . rser = <<r s e r>>
     . sese = <<s e s e>>
end

%% Definitions for 72 relations of DRA 72.
%% Subsorting is used extensively
spec DipolRelations[sort Point] =
     DipolRelations24 [sort Point]
     then %cons
     free type DipolPointRelation72 ::= r | l | e | s | b | i | f
     sort DipolPointRelation24 < DipolPointRelation72
     free type DipolRelation72 ::= <<__ __ __ __>>(fst:DipolPointRelation72; 
					       snd:DipolPointRelation72; 
					       trd: DipolPointRelation72; 
					       frt: DipolPointRelation72)
     sort DipolRelation24 < DipolRelation72
     pred >__ __ __< : Dipol * DipolRelation72 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelation72 * Point
     %% DRA 72 Relations
     sort BaseRelation72 = {x : DipolRelation72 .
			    x in BaseRelation24 \/
			    x = <<f f b b>> \/ x = <<e f b s>> \/
			    x = <<i f b i>> \/ x = <<b f i i>> \/
			    x = <<s f s i>> \/ x = <<b e i e>> \/
			    x = <<b b f f>> \/ x = <<b s e f>> \/
			    x = <<b i i f>> \/ x = <<i i b f>> \/
			    x = <<s i s f>> \/ x = <<i e b e>> \/
			    x = <<f f f f>> \/ x = <<f e f e>> \/
			    x = <<f i f i>> \/ x = <<f b i i>> \/
			    x = <<f s e i>> \/ x = <<e b i s>> \/
			    x = <<i i f b>> \/ x = <<e i f s>> \/
			    x = <<i s e b>> \/ x = <<b b b b>> \/
			    x = <<s b s b>> \/ x = <<i b i b>> \/
			    x = <<l l l b>> \/ x = <<l l f l>> \/
			    x = <<l l b r>> \/ x = <<l l r f>> \/
			    x = <<l i r l>> \/ x = <<l f r r>> \/
			    x = <<l r i l>> \/ x = <<l r r i>> \/
			    x = <<b l r r>> \/ x = <<i r r l>> \/
			    x = <<f r r r>> \/ x = <<r b r r>> \/
			    x = <<l b l l>> \/ x = <<f l l l>> \/
			    x = <<b r l l>> \/ x = <<r f l l>> \/ 
			    x = <<r l l i>> \/ x = <<r r l f>> \/
			    x = <<i l l r>> \/ x = <<r i l r>> \/
			    x = <<r r b l>> \/ x = <<r l i r>> \/
			    x = <<r r f r>> \/ x = <<r r r b>>
			    }
     %% Definition of Dipol Relations by Dipol point relations
     forall Dp1,Dp2 : Dipol; rel : BaseRelation72
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     %% Shortcuts for the relations... just for your convenience
     op rrrr, rrrl, rrlr, rrll, rlrr, rllr,
	rlll, lrrr, lrrl, lrll, llrr, llrl,
	lllr, llll, ells, eses, errs, lere,
	rele, slsr, srsl, lsel, rser, sese,
	ffbb, efbs, ifbi, bfii, sfsi, beie,
	bbff, bsef, biif, iibf, sisf, iebe, 
	ffff, fefe, fifi, fbii, fsei, ebis,
	iifb, eifs, iseb, bbbb, sbsb, ibib,
	lllb, llfl, llbr, llrf, lirl, lfrr,
	lril, lrri, blrr, irrl, frrr, rbrr,
	lbll, flll, brll, rfll, rlli, rrlf,
	illr, rilr, rrbl, rlir, rrfr, rrrb : BaseRelation72
     . rrrr = <<r r r r>>
     . rrrl = <<r r r l>>
     . rrlr = <<r r l r>>
     . rrll = <<r r l l>>
     . rlrr = <<r l r r>>
     . rllr = <<r l l r>>
     . rlll = <<r l l l>>
     . lrrr = <<l r r r>>
     . lrrl = <<l r r l>>
     . lrll = <<l r l l>>
     . llrr = <<l l r r>>
     . llrl = <<l l r l>>
     . lllr = <<l l l r>>
     . llll = <<l l l l>>
     . ells = <<e l l s>>
     . eses = <<e s e s>>
     . errs = <<e r r s>>
     . lere = <<l e r e>>
     . rele = <<r e l e>>
     . slsr = <<s l s r>>
     . srsl = <<s r s l>>
     . lsel = <<l s e l>>
     . rser = <<r s e r>>
     . sese = <<s e s e>>
     . ffbb = <<f f b b>>
     . efbs = <<e f b s>>
     . ifbi = <<i f b i>>
     . bfii = <<b f i i>>
     . sfsi = <<s f s i>>
     . beie = <<b e i e>>
     . bbff = <<b b f f>>
     . bsef = <<b s e f>>
     . biif = <<b i i f>>
     . iibf = <<i i b f>>
     . sisf = <<s i s f>>
     . iebe = <<i e b e>>
     . ffff = <<f f f f>>
     . fefe = <<f e f e>>
     . fifi = <<f i f i>>
     . fbii = <<f b i i>>
     . fsei = <<f s e i>>
     . ebis = <<e b i s>>
     . iifb = <<i i f b>>
     . eifs = <<e i f s>>
     . iseb = <<i s e b>>
     . bbbb = <<b b b b>>
     . sbsb = <<s b s b>>
     . ibib = <<i b i b>>
     . lllb = <<l l l b>>
     . llfl = <<l l f l>>
     . llbr = <<l l b r>>
     . llrf = <<l l r f>>
     . lirl = <<l i r l>>
     . lfrr = <<l f r r>>
     . lril = <<l r i l>>
     . lrri = <<l r r i>>
     . blrr = <<b l r r>>
     . irrl = <<i r r l>>
     . frrr = <<f r r r>>
     . rbrr = <<r b r r>>
     . lbll = <<l b l l>>
     . flll = <<f l l l>>
     . brll = <<b r l l>>
     . rfll = <<r f l l>>
     . rlli = <<r l l i>>
     . rrlf = <<r r l f>>
     . illr = <<i l l r>>
     . rilr = <<r i l r>>
     . rrbl = <<r r b l>>
     . rlir = <<r l i r>>
     . rrfr = <<r r f r>>
     . rrrb = <<r r r b>>
end

spec DRA24Composition[sort Point] = 
     DipolRelations24[sort Point]
     then
     SetOfBaseRels[sort BaseRelation24]
     then 
     %% universal relation
     . 1 = (rrrr union (rrll union (llrr union (llll union (rrrl union (rrlr union (rlrr union
		(rllr union (rlll union (lrrr union (lrrl union (lrll union (llrl union
		(lllr union (ells union (errs union (lere union (rele union (slsr union
		(srsl union (lsel union (rser union (sese union
		eses)))))))))))))))))))))))
     %% the converses
     . conv(rrll) = llrr
     . conv(llrr) = rrll

     . conv(rrrl) = rlrr
     . conv(rrlr) = lrrr 
     . conv(rlrr) = rrrl
     . conv(rllr) = lrrl
     . conv(rlll) = llrl
     . conv(lrrr) = rrlr
     . conv(lrrl) = rllr
     . conv(lrll) = lllr
     . conv(llrl) = rlll
     . conv(lllr) = lrll

     . conv(ells) = lsel
     . conv(errs) = rser
     . conv(lere) = rele
     . conv(rele) = lere
     . conv(slsr) = srsl
     . conv(srsl) = slsr
     . conv(lsel) = ells
     . conv(rser) = errs     

     %% symmetric relations
     . conv(rrrr) = rrrr
     . conv(llll) = llll
       
     . conv(eses) = eses
     . conv(sese) = sese
end

spec DRA72Composition[sort Point] =
     DipolRelations[sort Point]
     then 
     SetOfBaseRels[sort BaseRelation72]
     then 
     %% universal relation
     . 1 = (rrrr union (rrll union (llrr union (llll union (rrrl union (rrlr union (rlrr union
		(rllr union (rlll union (lrrr union (lrrl union (lrll union (llrl union
		(lllr union (ells union (errs union (lere union (rele union (slsr union
		(srsl union (lsel union (rser union (sese union (eses union (ffbb union
		(efbs union (ifbi union (bfii union (sfsi union (beie union (bbff union
		(bsef union (biif union (iibf union (sisf union (iebe union (ffff union
		(fefe union (fifi union (fbii union (fsei union (ebis union (iifb union
		(eifs union (iseb union (bbbb union (sbsb union (ibib union (lllb union
		(llfl union (llbr union (llrf union (lirl union (lfrr union (lril union
		(lrri union (blrr union (irrl union (frrr union (rbrr union (lbll union
		(flll union (brll union (rfll union (rlli union (rrlf union (illr union
		(rilr union (rrbl union (rlir union (rrfr union rrrb)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


     . conv(ffbb) = bbff
     . conv(efbs) = bsef
     . conv(ifbi) = biif
     . conv(bfii) = iibf
     . conv(sfsi) = sisf
     . conv(beie) = iebe 
     . conv(bbff) = ffbb
     . conv(bsef) = efbs
     . conv(biif) = ifbi
     . conv(iibf) = bfii
     . conv(sisf) = sfsi
     . conv(iebe) = beie

     . conv(fbii) = iifb
     . conv(fsei) = eifs
     . conv(ebis) = iseb
     . conv(iifb) = fbii
     . conv(eifs) = fsei
     . conv(iseb) = ebis

     . conv(lllb) = lbll
     . conv(llfl) = flll
     . conv(llbr) = brll
     . conv(llrf) = rfll
     . conv(lirl) = rlli
     . conv(lfrr) = rrlf
     . conv(lril) = illr
     . conv(lrri) = rilr
     . conv(blrr) = rrbl
     . conv(irrl) = rlir
     . conv(frrr) = rrfr
     . conv(rbrr) = rrrb

     . conv(lbll) = lllb 
     . conv(flll) = llfl
     . conv(brll) = llbr
     . conv(rfll) = llrf
     . conv(rlli) = lirl
     . conv(rrlf) = lfrr
     . conv(illr) = lril
     . conv(rilr) = lrri
     . conv(rrbl) = blrr
     . conv(rlir) = irrl
     . conv(rrfr) = frrr
     . conv(rrrb) = rbrr
       
     %% symmetric relations

     . conv(fifi) = fifi
     . conv(bbbb) = bbbb
     . conv(sbsb) = sbsb
     . conv(ibib) = ibib 

     . conv(ffff) = ffff
     . conv(fefe) = fefe

     %% compostion table - automatically generated


end

%%Domain for the DRA calculi

%%We consider a normed vector space over a totally ordered field

spec Field =
     sort Elem
     ops 0     : Elem;
	 1     : Elem;
	 __+__ : Elem * Elem -> Elem, assoc, comm, unit 0;
	 __*__ : Elem * Elem -> Elem, assoc, comm, unit 1;
	 -__   : Elem -> Elem
     forall a,b,c : Elem
     . a * ( a + c ) = ( a * b ) + ( a * c )           %(distribution)%
     forall a : Elem 
     . exists b : Elem . a + b = 0                     %(additive_inverse)%
     . not ( a = 0 ) => (exists b : Elem . not ( b = 0 ) => a * b = 1)    %(mult_inverse)%
     then %implies
     forall a, b : Elem
     . ((- a ) + a = 0 )  /\ (forall c : Elem . (a + c = 0) => (c = - a))    %(thm_inverse)%
     . a * 0 = 0                                                           %(thm_mult_with_inverse)%
     . (- 0 ) = 0                                                          %(0_is_self_inverse)%
     . - ( - a ) = a                                                       %(double_inverse)%
     . - ( a + b ) = ( - a ) + ( - b )                                     %(distri_inverse)%
end

%% as the name says it... A total order 
spec TotalOrder = 
     sort Elem
     pred __ <= __ : Elem * Elem;
	  __<__    : Elem * Elem
     forall a, b, c : Elem
     . a <= a                                %(order_reflex)%
     . a <= b /\ b <= a => a = b             %(order_antisymmetric)%
     . a <=b /\ b <= c => a <= c             %(order_transitive)%
     . a <= b \/ b <= a                      %(order_total)%
     . a < b <=> a <= b /\ not ( a = b )     %(def_<)%
end

spec TotallyOrderedField = 
     Field and TotalOrder
     then
     forall a : Elem
     . 0 <= 1
     . a <= 0 <=> 0 <= ( - a )
     then %implies
     forall a,b,c,d : Elem
     . ( - a ) <= 0 <=> 0 <= a               %(thm_order)%
     . a <= b /\ c <= d => a + c <= c + d    %(thm_order_+)%
end 

%% Spec for points
spec Point[sort Elem] =
     free type Point ::= /__ __\ (x : Elem; y : Elem)
end

%% We need to consider points over a totally ordered field
spec PointsOverField =
     Point[TotallyOrderedField]
     then %cons 
     pred __<=__ : Point * Point
     forall a,b : Point
     . (a <= b) <=> ((x(a) <= x(b)) /\ (y(a) <= y(b)))
end

spec VectorSpace[sort Space] = 
     Field
     then
     ops __+__ : Space * Space -> Space;
	 __*__ : Elem * Space -> Space;
	 -__   : Space -> Space;
	 0     : Space
     forall a, b, c : Space; e, f : Elem
     . a + ( b + c ) = ( a + b ) + c                 %(ax_asoc)%
     . a + b = b + a                                 %(ax_commut)%
     . a + 0 = a                                     %(ax_0)%
     . exists d : Space . a + d = 0                  %(ax_inverse)%
     . e * ( a + b ) = e * a + e * b                 %(ax_distri_1)%
     . ( e + f ) * a = e * a + f * a                 %(ax_distri_2)%
     . e * ( f * a) = ( e * f ) * a                  %(ax_mult)%
     . 1 * a = a
     then %implies
     forall a, b : Space
     . ((- a ) + a = 0 )  /\ (forall c : Space . ( a + c = 0) => (c = - a))    %(thm_inverse)%
end

spec Vector =
     TotallyOrderedField
     then %cons
     free type Vector ::= [[__ __]](xc : Elem; yc : Elem) 
     then
     VectorSpace[sort Vector]
     then
     ops <__||__> : Vector * Vector -> Elem;
	 ||__||   : Vector -> Elem
     forall a, b : Vector
     . <a||b> = xc(a) * xc(b) + yc(a) * yc(b)      %(def_inner_prod)%
     . ||a|| * ||a|| = <a||a>                      %(def_norm)%
     then %implies
     forall a,b : Vector
     . <0||0> = 0                                  %(thm_zero)%
     . 0 <= ||a||                                  %(thm_norm>=0)%
     . <a||b> = <b||a>                             %(thm_commut)%
     . <a || a> = 0 => a = 0                       %(thm_x=0)%
end 

%% This spec is intended to be part of the interface from DRA to 
%% its domain
spec PointsToVector =
     Vector 
     then PointsOverField
     then
     type Dipol ::= [<__ __>] (sp : Point; ep : Point)
     %% we consider s_a, e_a and a point pt in the 
     %% terminology of Moratz, Renz, Wolter:
     %% Qualitative Spatial Reasoing about Line Segments
     %% We are using a dipol and a point to calculate a 
     %% orthogonal coordinate system with basis in the 
     %% start point of the dipol
     ops A  : Dipol -> Vector;
     ops Ap : Dipol -> Vector;
     ops P  : Dipol * Point -> Vector;
     var pt  : Point;
     var Dp : Dipol; 
     var s_A : Point;
     var e_A : Point;
     . s_A = sp(Dp)
     . e_A = ep(Dp)
     . not ( s_A = e_A) => A(Dp)      = [[x(e_A)+(-x(s_A)) y(e_A)+(-y(s_A))]]
     . not ( s_A = e_A) => Ap(Dp)     = [[y(e_A)+(-y(s_A)) x(s_A)+(-x(e_A))]]
     . not ( s_A = e_A) => P (Dp, pt) = [[x(pt)+(-x(s_A))   y(pt)+(-y(s_A))]]
     . < A(Dp) || Ap(Dp) > = 0                    %(thm_orthogonal)% %implied
end

%% The definition of the 7 Dipol-Point relations via vectors
%% we are stating this under the assumption, that
%% < A || B > = || A || * || B || * cos \phi which is known to be 
%% true for the 2D-Vector space over real numbers
spec Vector_Vector_Relations72 =
     PointsToVector
     then
     TotallyOrderedField
     then 
     DipolRelations[Point[TotallyOrderedField]]
     then %cons
     var pt  : Point;
     var Dp : Dipol; 
     var s_A : Point;
     var e_A : Point;
     free type DipolPointRelation24 ::= r | l | s | e
     sort DipolPointRelation24 < DipolPointRelation72
     free type DipolPointRelation72 ::= r | l | s | e | b | i | f
     pred __vr__ : Vector * Vector;
	  __vl__ : Vector * Vector;
	  __vs__ : Vector * Vector;	  
	  __ve__ : Vector * Vector;
	  __vb__ : Vector * Vector;
	  __vi__ : Vector * Vector;
	  __vf__ : Vector * Vector;
	  __dpr__ : Dipol * Point;
	  __dpl__ : Dipol * Point;
	  __dps__ : Dipol * Point;	  
	  __dpe__ : Dipol * Point;
	  __dpb__ : Dipol * Point;
	  __dpi__ : Dipol * Point;
	  __dpf__ : Dipol * Point 	  
     . A (Dp) vr P (Dp, pt) <=> 0 < < Ap (Dp)|| P (Dp, pt) > 
     . A (Dp) vl P (Dp, pt) <=> < Ap (Dp)|| P (Dp, pt) > < 0 
     . A (Dp) vb P (Dp, pt) <=> < A (Dp)|| P (Dp, pt) > = -(||A (Dp)|| * ||P (Dp, pt)||)
     . A (Dp) ve P (Dp, pt) <=> (< A (Dp)|| P (Dp, pt) > = ||A(Dp)|| * ||P (Dp, pt)||) /\ (||A (Dp)|| = ||P (Dp, pt)||)
     . A (Dp) vf P (Dp, pt) <=> (< A (Dp)|| P (Dp, pt) > = ||A(Dp)|| * ||P (Dp, pt)||) /\ (||A (Dp)|| < ||P (Dp, pt)||)
     . A (Dp) vi P (Dp, pt) <=> (< A (Dp)|| P (Dp, pt) > = ||A(Dp)|| * ||P (Dp, pt)||) /\ (||P (Dp, pt)|| < ||A (Dp)||)
     . A (Dp) vs P (Dp, pt) <=> (0 = ||P (Dp, pt)||)
     . Dp dpr pt <=> A (Dp)vr P (Dp, pt) 
     . Dp dpl pt <=> A (Dp)vl P (Dp, pt) 
     . Dp dps pt <=> A (Dp)vs P (Dp, pt) 
     . Dp dpe pt <=> A (Dp)ve P (Dp, pt) 
     . Dp dpb pt <=> A (Dp)vb P (Dp, pt) 
     . Dp dpi pt <=> A (Dp)vi P (Dp, pt) 
     . Dp dpf pt <=> A (Dp)vf P (Dp, pt) 
     forall Dp1, Dp2 : Dipol; rel : DipolRelation72; ptp : Point
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     . Dp1 dpr ptp <=> >> Dp1 r ptp <<
     . Dp1 dpl ptp <=> >> Dp1 l ptp <<     
     . Dp1 dps ptp <=> >> Dp1 s ptp <<     
     . Dp1 dpe ptp <=> >> Dp1 e ptp <<
     . Dp1 dpb ptp <=> >> Dp1 b ptp <<
     . Dp1 dpi ptp <=> >> Dp1 i ptp <<     
     . Dp1 dpf ptp <=> >> Dp1 f ptp <<    
end

%% The definition of the 7 Dipol-Point relations via vectors
%% we are stating this under the assumption, that
%% < A || B > = || A || * || B || * cos \phi which is known to be 
%% true for the 2D-Vector space over real numbers
%% In DRA24 not more than 2 different points are allowed to be on 
%% a line
spec Vector_Vector_Relations24 =
     PointsToVector
     then
     TotallyOrderedField
     then
     DipolRelations24[Point[TotallyOrderedField]] 
     then %cons
     var pt  : Point;
     var Dp : Dipol; 
     var s_A : Point;
     var e_A : Point;
     pred __vr__ : Vector * Vector;
	  __vl__ : Vector * Vector;
	  __vs__ : Vector * Vector;	  
	  __ve__ : Vector * Vector;
	  __dpr__ : Dipol * Point;
	  __dpl__ : Dipol * Point;
	  __dps__ : Dipol * Point;	  
	  __dpe__ : Dipol * Point	  
     pred >__ __ __< : Dipol * DipolRelation24 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelation24 * Point
     %% Assure that not more than 3 differnt points are on a single line
     . not (< A (Dp)|| P (Dp, pt) > = ||A (Dp)|| * ||P (Dp, pt)||) /\ (not (||A (Dp)|| = ||P (Dp, pt)||) \/ not (||P (Dp, pt)|| = 0))
     . A (Dp) vr P (Dp, pt) <=> 0 < < Ap (Dp)|| P (Dp, pt) > 
     . A (Dp) vl P (Dp, pt) <=> < Ap (Dp)|| P (Dp, pt) > < 0 
     . A (Dp) ve P (Dp, pt) <=> (< A (Dp)|| P (Dp, pt) > = ||A (Dp)|| * ||P (Dp, pt)||) /\ (||A (Dp)|| = ||P (Dp, pt)||)
     . A (Dp) vs P (Dp, pt) <=> (0 = ||P (Dp, pt)||)
     . Dp dpr pt <=> A (Dp)vr P (Dp, pt) 
     . Dp dpl pt <=> A (Dp)vl P (Dp, pt) 
     . Dp dps pt <=> A (Dp)vs P (Dp, pt) 
     . Dp dpe pt <=> A (Dp)ve P (Dp, pt) 
     forall Dp1, Dp2 : Dipol; rel : DipolRelation24; ptp : Point
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     . Dp1 dpr ptp <=> >> Dp1 r ptp <<
     . Dp1 dpl ptp <=> >> Dp1 l ptp <<     
     . Dp1 dps ptp <=> >> Dp1 s ptp <<     
     . Dp1 dpe ptp <=> >> Dp1 e ptp <<
end

%% We are considering all relations as sets of
%% base relations

spec Vector_Vector_Relation_Sets24 =
     Vector_Vector_Relations24
     then 
     SetOfBaseRels[sort BaseRelation24]
     then %cons
     ops 0 : GenRel = {}
end


spec Vector_Vector_Relation_Sets72 =
     Vector_Vector_Relations72
     then 
     SetOfBaseRels[sort BaseRelation72]
     then %cons
     ops 0 : GenRel = {}
end

%% Our two interesting views

view DRA72_In_Domain : DRA72Composition[sort Point] to
     Vector_Vector_Relation_Sets72 = [__ __] |-> [<__ __>] 
end

view DRA24_In_Domain : DRA24Composition[sort Point] to
     Vector_Vector_Relation_Sets24
end

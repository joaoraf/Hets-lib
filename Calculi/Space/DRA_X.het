library Calculi/Space/DRA_X
version 0.0

from Basic/StructuredDatatypes get Set

%author: Dominik Luecke
%date: 2007-04-30
%% Dipol Calculus with 72 relations (DRA 72)

%% General relations are sets of BaseRelations... 
spec SetOfBaseRels[sort BaseRel] = 
     Set[sort BaseRel fit Elem |-> BaseRel] with Set[BaseRel] |-> GenRel,
      __union__ |-> __union__
     then
     sort BaseRel < GenRel
     ops id : BaseRel;
	  1  : GenRel;
	  0  : GenRel = {};
	  compl: GenRel -> GenRel;
	  conv: BaseRel -> BaseRel;
	  __cmps__ : BaseRel * BaseRel -> GenRel
     forall x:BaseRel; u:GenRel
     . x = {x}
     . x eps 1
     . not x eps 0
     . compl(u) = 1 - u

     . x cmps id = x
     . id cmps x = x

     . conv(id) = id
     . conv(conv(x)) = x
then %implies
  forall x,y:BaseRel; u:GenRel
  . not x = y => x intersection y = 0	        %(PairwiseDisjoint)%
  . not u=0 => exists z:BaseRel . z eps u	%(JointlyExhaustive)%
end

%% Definitions of the relations between point and dipoles as basis for
%% DRA 24 and DRA 72
spec DipolPointRelation[sort Point] =
     type Dipol ::= [__ __](sp : Point; ep : Point)
     free type DipolPointRelation72 ::= r | l | e | s | b | i | f
     sort DipolPointRelation24 < DipolPointRelation72
     free type DipolPointRelation24 ::= r | l | e | s
end  

%% Definitions of the 24 relations of DRA 24 and 72 relations of
%% DRA 72. Subsorting is used extensively
spec DipolRelations[sort Point] =
     DipolPointRelation [sort Point]
     then %cons
     free type DipolRelation72 ::= <<__ __ __ __>>(fst:DipolPointRelation72; 
					       snd:DipolPointRelation72; 
					       trd: DipolPointRelation72; 
					       frt: DipolPointRelation72)
     sort DipolRelation24 < DipolRelation72
     free type DipolRelation24 ::= <<__ __ __ __>>(fst:DipolPointRelation24; 
					       snd:DipolPointRelation24; 
					       trd: DipolPointRelation24; 
					       frt: DipolPointRelation24)     
     pred >__ __ __< : Dipol * DipolRelation72 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelation72 * Point
     %% DRA 24 Relations
     sort BaseRelation24 = {x : DipolRelation24 .
			    x = <<r r r r>> \/ x = <<r r r l>> \/
			    x = <<r r l r>> \/ x = <<r r l l>> \/
			    x = <<r l r r>> \/ x = <<r l l r>> \/
			    x = <<r l l l>> \/ x = <<l r r r>> \/
			    x = <<l r r l>> \/ x = <<l r l l>> \/
			    x = <<l l r r>> \/ x = <<l l r l>> \/
			    x = <<l l l r>> \/ x = <<l l l l>> \/
			    x = <<e l l s>> \/ x = <<e s e s>> \/
			    x = <<e r r s>> \/ x = <<l e r e>> \/
			    x = <<r e l e>> \/ x = <<s l s r>> \/
			    x = <<s r s l>> \/ x = <<l s e l>> \/
			    x = <<r s e r>> \/ x = <<s e s e>> 
			   }
     %% DRA 72 Relations
     sort BaseRelation72 = {x : DipolRelation72 .
			    x in BaseRelation24 \/
			    x = <<f f b b>> \/ x = <<e f b s>> \/
			    x = <<i f b i>> \/ x = <<b f i i>> \/
			    x = <<s f s i>> \/ x = <<b e i e>> \/
			    x = <<b b f f>> \/ x = <<b s e f>> \/
			    x = <<b i i f>> \/ x = <<i i b f>> \/
			    x = <<s i s f>> \/ x = <<i e b e>> \/
			    x = <<f f f f>> \/ x = <<f e f e>> \/
			    x = <<f i f i>> \/ x = <<f b i i>> \/
			    x = <<f s e i>> \/ x = <<e b i s>> \/
			    x = <<i i f b>> \/ x = <<e i f s>> \/
			    x = <<i s e b>> \/ x = <<b b b b>> \/
			    x = <<s b s b>> \/ x = <<i b i b>> \/
			    x = <<l l l b>> \/ x = <<l l f l>> \/
			    x = <<l l b r>> \/ x = <<l l r f>> \/
			    x = <<l i r l>> \/ x = <<l f r r>> \/
			    x = <<l r i l>> \/ x = <<l r r i>> \/
			    x = <<b l r r>> \/ x = <<i r r l>> \/
			    x = <<f r r r>> \/ x = <<r b r r>> \/
			    x = <<l b l l>> \/ x = <<f l l l>> \/
			    x = <<b r l l>> \/ x = <<r f l l>> \/ 
			    x = <<r l l i>> \/ x = <<r r l f>> \/
			    x = <<i l l r>> \/ x = <<r i l r>> \/
			    x = <<r r b l>> \/ x = <<r l i r>> \/
			    x = <<r r f r>> \/ x = <<r r r b>>
			    }
     %% Shortcuts for the relations... just for your convenience
     op rrrr, rrrl, rrlr, rrll, rlrr, rllr,
	rlll, lrrr, lrrl, lrll, llrr, llrl,
	lllr, llll, ells, eses, errs, lere,
	rele, slsr, srsl, lsel, rser, sese,
	ffbb, efbs, ifbi, bfii, sfsi, beie,
	bbff, bsef, biif, iibf, sisf, iebe, 
	ffff, fefe, fifi, fbii, fsei, ebis,
	iifb, eifs, iseb, bbbb, sbsb, ibib,
	lllb, llfl, llbr, llrf, lirl, lfrr,
	lril, lrri, blrr, irrl, frrr, rbrr,
	lbll, flll, brll, rfll, rlli, rrlf,
	illr, rilr, rrbl, rlir, rrfr, rrrb : BaseRelation72
     . rrrr = <<r r r r>>
     . rrrl = <<r r r l>>
     . rrlr = <<r r l r>>
     . rrll = <<r r l l>>
     . rlrr = <<r l r r>>
     . rllr = <<r l l r>>
     . rlll = <<r l l l>>
     . lrrr = <<l r r r>>
     . lrrl = <<l r r l>>
     . lrll = <<l r l l>>
     . llrr = <<l l r r>>
     . llrl = <<l l r l>>
     . lllr = <<l l l r>>
     . llll = <<l l l l>>
     . ells = <<e l l s>>
     . eses = <<e s e s>>
     . errs = <<e r r s>>
     . lere = <<l e r e>>
     . rele = <<r e l e>>
     . slsr = <<s l s r>>
     . srsl = <<s r s l>>
     . lsel = <<l s e l>>
     . rser = <<r s e r>>
     . sese = <<s e s e>>
     . ffbb = <<f f b b>>
     . efbs = <<e f b s>>
     . ifbi = <<i f b i>>
     . bfii = <<b f i i>>
     . sfsi = <<s f s i>>
     . beie = <<b e i e>>
     . bbff = <<b b f f>>
     . bsef = <<b s e f>>
     . biif = <<b i i f>>
     . iibf = <<i i b f>>
     . sisf = <<s i s f>>
     . iebe = <<i e b e>>
     . ffff = <<f f f f>>
     . fefe = <<f e f e>>
     . fifi = <<f i f i>>
     . fbii = <<f b i i>>
     . fsei = <<f s e i>>
     . ebis = <<e b i s>>
     . iifb = <<i i f b>>
     . eifs = <<e i f s>>
     . iseb = <<i s e b>>
     . bbbb = <<b b b b>>
     . sbsb = <<s b s b>>
     . ibib = <<i b i b>>
     . lllb = <<l l l b>>
     . llfl = <<l l f l>>
     . llbr = <<l l b r>>
     . llrf = <<l l r f>>
     . lirl = <<l i r l>>
     . lfrr = <<l f r r>>
     . lril = <<l r i l>>
     . lrri = <<l r r i>>
     . blrr = <<b l r r>>
     . irrl = <<i r r l>>
     . frrr = <<f r r r>>
     . rbrr = <<r b r r>>
     . lbll = <<l b l l>>
     . flll = <<f l l l>>
     . brll = <<b r l l>>
     . rfll = <<r f l l>>
     . rlli = <<r l l i>>
     . rrlf = <<r r l f>>
     . illr = <<i l l r>>
     . rilr = <<r i l r>>
     . rrbl = <<r r b l>>
     . rlir = <<r l i r>>
     . rrfr = <<r r f r>>
     . rrrb = <<r r r b>>
     %% Definition of Dipol Relations by Dipol point relations
     forall Dp1,Dp2 : Dipol; rel : BaseRelation72
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
end

spec DRA24Composition[sort Point] = 
     DipolRelations[sort Point] hide BaseRelation72, DipolPointRelation72, 
			 DipolRelation
     then
     SetOfBaseRels[sort BaseRelation24]
     then 
     op rrrr, rrrl, rrlr, rrll, rlrr, rllr,
	rlll, lrrr, lrrl, lrll, llrr, llrl,
	lllr, llll, ells, eses, errs, lere,
	rele, slsr, srsl, lsel, rser, sese,
	ffbb, efbs : BaseRelation24
     . rrrr = <<r r r r>>
     . rrrl = <<r r r l>>
     . rrlr = <<r r l r>>
     . rrll = <<r r l l>>
     . rlrr = <<r l r r>>
     . rllr = <<r l l r>>
     . rlll = <<r l l l>>
     . lrrr = <<l r r r>>
     . lrrl = <<l r r l>>
     . lrll = <<l r l l>>
     . llrr = <<l l r r>>
     . llrl = <<l l r l>>
     . lllr = <<l l l r>>
     . llll = <<l l l l>>
     . ells = <<e l l s>>
     . eses = <<e s e s>>
     . errs = <<e r r s>>
     . lere = <<l e r e>>
     . rele = <<r e l e>>
     . slsr = <<s l s r>>
     . srsl = <<s r s l>>
     . lsel = <<l s e l>>
     . rser = <<r s e r>>
     . sese = <<s e s e>>
     %% universal relation
     . 1 = (rrrr union (rrll union (llrr union (llll union (rrrl union (rrlr union (rlrr union
		(rllr union (rlll union (lrrr union (lrrl union (lrll union (llrl union
		(lllr union (ells union (errs union (lere union (rele union (slsr union
		(srsl union (lsel union (rser union (sese union
		eses)))))))))))))))))))))))
     
end

spec DRA72Composition[sort Point] =
     DipolRelations[sort Point]
     then 
     SetOfBaseRels[sort BaseRelation72]
     then 
     %% universal relation
     . 1 = (rrrr union (rrll union (llrr union (llll union (rrrl union (rrlr union (rlrr union
		(rllr union (rlll union (lrrr union (lrrl union (lrll union (llrl union
		(lllr union (ells union (errs union (lere union (rele union (slsr union
		(srsl union (lsel union (rser union (sese union (eses union (ffbb union
		(efbs union (ifbi union (bfii union (sfsi union (beie union (bbff union
		(bsef union (biif union (iibf union (sisf union (iebe union (ffff union
		(fefe union (fifi union (fbii union (fsei union (ebis union (iifb union
		(eifs union (iseb union (bbbb union (sbsb union (ibib union (lllb union
		(llfl union (llbr union (llrf union (lirl union (lfrr union (lril union
		(lrri union (blrr union (irrl union (frrr union (rbrr union (lbll union
		(flll union (brll union (rfll union (rlli union (rrlf union (illr union
		(rilr union (rrbl union (rlir union (rrfr union rrrb)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

     %% the converses
     . conv(rrll) = llrr
     . conv(llrr) = rrll

     . conv(rrrl) = rlrr
     . conv(rrlr) = lrrr 
     . conv(rlrr) = rrrl
     . conv(rllr) = lrrl
     . conv(rlll) = llrl
     . conv(lrrr) = rrlr
     . conv(lrrl) = rllr
     . conv(lrll) = lllr
     . conv(llrl) = rlll
     . conv(lllr) = lrll

     . conv(ells) = lsel
     . conv(errs) = rser
     . conv(lere) = rele
     . conv(rele) = lere
     . conv(slsr) = srsl
     . conv(srsl) = slsr
     . conv(lsel) = ells
     . conv(rser) = errs

     . conv(ffbb) = bbff
     . conv(efbs) = bsef
     . conv(ifbi) = biif
     . conv(bfii) = iibf
     . conv(sfsi) = sisf
     . conv(beie) = iebe 
     . conv(bbff) = ffbb
     . conv(bsef) = efbs
     . conv(biif) = ifbi
     . conv(iibf) = bfii
     . conv(sisf) = sfsi
     . conv(iebe) = beie

     . conv(fbii) = iifb
     . conv(fsei) = eifs
     . conv(ebis) = iseb
     . conv(iifb) = fbii
     . conv(eifs) = fsei
     . conv(iseb) = ebis

     . conv(lllb) = lbll
     . conv(llfl) = flll
     . conv(llbr) = brll
     . conv(llrf) = rfll
     . conv(lirl) = rlli
     . conv(lfrr) = rrlf
     . conv(lril) = illr
     . conv(lrri) = rilr
     . conv(blrr) = rrbl
     . conv(irrl) = rlir
     . conv(frrr) = rrfr
     . conv(rbrr) = rrrb

     . conv(lbll) = lllb 
     . conv(flll) = llfl
     . conv(brll) = llbr
     . conv(rfll) = llrf
     . conv(rlli) = lirl
     . conv(rrlf) = lfrr
     . conv(illr) = lril
     . conv(rilr) = lrri
     . conv(rrbl) = blrr
     . conv(rlir) = irrl
     . conv(rrfr) = frrr
     . conv(rrrb) = rbrr

     %% symmetric relations
     . conv(rrrr) = rrrr
     . conv(llll) = llll
       
     . conv(eses) = eses
		  
     . conv(ffff) = ffff
     . conv(fefe) = fefe
     . conv(fifi) = fifi
     . conv(bbbb) = bbbb
     . conv(sbsb) = sbsb
     . conv(ibib) = ibib 

     %% compostion table - automatically generated


end

%%Domain for the DRA calculi

%%We consider a normed vector space over a totally ordered field

spec Field =
     sort Elem
     ops 0     : Elem;
	 1     : Elem;
	 __+__ : Elem * Elem -> Elem, assoc, comm, unit 0;
	 __*__ : Elem * Elem -> Elem, assoc, comm, unit 1;
	 -__   : Elem -> Elem
     forall a,b,c : Elem
     . a * ( a + c ) = ( a * b ) + ( a * c )           %(distribution)%
     forall a : Elem 
     . exists b : Elem . a + b = 0                     %(additive_inverse)%
     . not ( a = 0 ) => (exists b : Elem . not ( b = 0 ) => a * b = 1)    %(mult_inverse)%
     then %implies
     forall a, b : Elem
     . ((- a ) + a = 0 )  /\ (forall c : Elem . (a + c = 0) => (c = - a))    %(thm_inverse)%
     . a * 0 = 0                                                           %(thm_mult_with_inverse)%
     . (- 0 ) = 0                                                          %(0_is_self_inverse)%
     . - ( - a ) = a                                                       %(double_inverse)%
     . - ( a + b ) = ( - a ) + ( - b )                                     %(distri_inverse)%
end

spec TotalOrder = 
     sort Elem
     pred __ <= __ : Elem * Elem;
	  __<__    : Elem * Elem
     forall a, b, c : Elem
     . a <= a                                %(order_reflex)%
     . a <= b /\ b <= a => a = b             %(order_antisymmetric)%
     . a <=b /\ b <= c => a <= c             %(order_transitive)%
     . a <= b \/ b <= a                      %(order_total)%
     . a < b <=> a <= b /\ not ( a = b )     %(def_<)%
end

spec TotallyOrderedField = 
     Field and TotalOrder
     then
     forall a : Elem
     . 0 <= 1
     . a <= 0 <=> 0 <= ( - a )
     then %implies
     forall a,b,c,d : Elem
     . ( - a ) <= 0 <=> 0 <= a               %(thm_order)%
     . a <= b /\ c <= d => a + c <= c + d    %(thm_order_+)%
end 

spec Point[sort Elem] =
     free type Point ::= /__ __\ (x : Elem; y : Elem)
end

spec PointsOverField =
     Point[TotallyOrderedField]
     then %cons 
     pred __<=__ : Point * Point
     forall a,b : Point
     . (a <= b) <=> ((x(a) <= x(b)) /\ (y(a) <= y(b)))
end

spec VectorSpace[sort Space] = 
     Field
     then
     ops __+__ : Space * Space -> Space;
	 __*__ : Elem * Space -> Space;
	 -__   : Space -> Space;
	 0     : Space
     forall a, b, c : Space; e, f : Elem
     . a + ( b + c ) = ( a + b ) + c                 %(ax_asoc)%
     . a + b = b + a                                 %(ax_commut)%
     . a + 0 = a                                     %(ax_0)%
     . exists d : Space . a + d = 0                  %(ax_inverse)%
     . e * ( a + b ) = e * a + e * b                 %(ax_distri_1)%
     . ( e + f ) * a = e * a + f * a                 %(ax_distri_2)%
     . e * ( f * a) = ( e * f ) * a                  %(ax_mult)%
     . 1 * a = a
     then %implies
     forall a, b : Space
     . ((- a ) + a = 0 )  /\ (forall c : Space . ( a + c = 0) => (c = - a))    %(thm_inverse)%
end

spec Vector =
     TotallyOrderedField
     then %cons
     free type Vector ::= [[__ __]](xc : Elem; yc : Elem) 
     then
     VectorSpace[sort Vector]
     then
     ops <__||__> : Vector * Vector -> Elem;
	 ||__||   : Vector -> Elem
     forall a, b : Vector
     . <a||b> = xc(a) * xc(b) + yc(a) * yc(b)      %(def_inner_prod)%
     . ||a|| * ||a|| = <a||a>                      %(def_norm)%
     then %implies
     forall a,b : Vector
     . <0||0> = 0                                  %(thm_zero)%
     . 0 <= ||a||                                  %(thm_norm>=0)%
     . <a||b> = <b||a>                             %(thm_commut)%
     . <a || a> = 0 => a = 0                       %(thm_x=0)%
end 

%% This spec is intended to be part of the interface from DRA to 
%% its domain
spec PointsToVector =
     Vector 
     then PointsOverField
     then
     type Dipol ::= [<__ __>] (sp : Point; ep : Point)
     %% we consider s_a, e_a and a point pt in the 
     %% terminology of Moratz, Renz, Wolter:
     %% Qualitative Spatial Reasoing about Line Segments
     %% We are using a dipol and a point to calculate a 
     %% orthogonal coordinate system with basis in the 
     %% start point of the dipol
     ops A  : Vector;
     ops Ap : Vector;
     ops P  : Vector;
     ops pt  : Point;
     ops Dp : Dipol; 
     ops s_A : Point;
     ops e_A : Point;
     forall Dpt : Dipol; ptt : Point
     . pt = ptt
     . Dp = Dpt
     . s_A = sp(Dp)
     . e_A = ep(Dp)
     . not ( s_A = e_A) => A  = [[x(e_A)+(-x(s_A)) y(e_A)+(-y(s_A))]]
     . not ( s_A = e_A) => Ap = [[y(e_A)+(-y(s_A)) x(s_A)+(-x(e_A))]]
     . not ( s_A = e_A) => P  = [[x(pt)+(-x(s_A))   y(pt)+(-y(s_A))]]
     . < A || Ap > = 0                       %(thm_orthogonal)% %implied
end

%% The definition of the 7 Dipol-Point relations via vectors
%% we are stating this under the assumption, that
%% < A || B > = || A || * || B || * cos \phi which is known to be 
%% true for the 2D-Vector space over real numbers
spec Vector_Vector_Relations72 =
     PointsToVector
     then
     TotallyOrderedField
     then %cons
     free type DipolPointRelations ::= dr | dl | ds | de | db | di | df
     pred __vr__ : Vector * Vector;
	  __vl__ : Vector * Vector;
	  __vs__ : Vector * Vector;	  
	  __ve__ : Vector * Vector;
	  __vb__ : Vector * Vector;
	  __vi__ : Vector * Vector;
	  __vf__ : Vector * Vector;
	  __dpr__ : Dipol * Point;
	  __dpl__ : Dipol * Point;
	  __dps__ : Dipol * Point;	  
	  __dpe__ : Dipol * Point;
	  __dpb__ : Dipol * Point;
	  __dpi__ : Dipol * Point;
	  __dpf__ : Dipol * Point 	  
     free type DipolDipolRelation72 ::= <<__ __ __ __>> (fst: DipolPointRelations;
							    snd: DipolPointRelations;
							    trd: DipolPointRelations; 
							    frt: DipolPointRelations)
     pred >__ __ __< : Dipol * DipolDipolRelation72 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelations * Point
     . A vr P <=> 0 < < Ap || P > 
     . A vl P <=> < Ap || P > < 0 
     . A vb P <=> < A || P > = -(||A|| * ||P||)
     . A ve P <=> (< A || P > = ||A|| * ||P||) /\ (||A|| = ||P||)
     . A vf P <=> (< A || P > = ||A|| * ||P||) /\ (||A|| < ||P||)
     . A vi P <=> (< A || P > = ||A|| * ||P||) /\ (||P|| < ||A||)
     . A vs P <=> (0 = ||P||)
     . Dp dpr pt <=> A vr P
     . Dp dpl pt <=> A vl P 
     . Dp dps pt <=> A vs P
     . Dp dpe pt <=> A ve P
     . Dp dpb pt <=> A vb P
     . Dp dpi pt <=> A vi P
     . Dp dpf pt <=> A vf P
     forall Dp1, Dp2 : Dipol; rel : DipolDipolRelation72; ptp : Point
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     . Dp1 dpr ptp <=> >> Dp1 dr ptp <<
     . Dp1 dpl ptp <=> >> Dp1 dl ptp <<     
     . Dp1 dps ptp <=> >> Dp1 ds ptp <<     
     . Dp1 dpe ptp <=> >> Dp1 de ptp <<
     . Dp1 dpb ptp <=> >> Dp1 db ptp <<
     . Dp1 dpi ptp <=> >> Dp1 di ptp <<     
     . Dp1 dpf ptp <=> >> Dp1 df ptp <<    
end

%% The definition of the 7 Dipol-Point relations via vectors
%% we are stating this under the assumption, that
%% < A || B > = || A || * || B || * cos \phi which is known to be 
%% true for the 2D-Vector space over real numbers
spec Vector_Vector_Relations24 =
     PointsToVector
     then
     TotallyOrderedField
     then %cons
     free type DipolPointRelations ::= dr | dl | ds | de 
     pred __vr__ : Vector * Vector;
	  __vl__ : Vector * Vector;
	  __vs__ : Vector * Vector;	  
	  __ve__ : Vector * Vector;
	  __dpr__ : Dipol * Point;
	  __dpl__ : Dipol * Point;
	  __dps__ : Dipol * Point;	  
	  __dpe__ : Dipol * Point	  
     free type DipolDipolRelation24 ::= <<__ __ __ __>> (fst: DipolPointRelations;
							    snd: DipolPointRelations;
							    trd: DipolPointRelations; 
							    frt: DipolPointRelations)
     pred >__ __ __< : Dipol * DipolDipolRelation24 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelations * Point
     %% Assure that not more than 3 differnt points are on a single line
     . not (< A || P > = ||A|| * ||P||) /\ (not (||A|| = ||P||) \/ not (||P|| = 0))
     . A vr P <=> 0 < < Ap || P > 
     . A vl P <=> < Ap || P > < 0 
     . A ve P <=> (< A || P > = ||A|| * ||P||) /\ (||A|| = ||P||)
     . A vs P <=> (0 = ||P||)
     . Dp dpr pt <=> A vr P
     . Dp dpl pt <=> A vl P 
     . Dp dps pt <=> A vs P
     . Dp dpe pt <=> A ve P
     forall Dp1, Dp2 : Dipol; rel : DipolDipolRelation24; ptp : Point
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     . Dp1 dpr ptp <=> >> Dp1 dr ptp <<
     . Dp1 dpl ptp <=> >> Dp1 dl ptp <<     
     . Dp1 dps ptp <=> >> Dp1 ds ptp <<     
     . Dp1 dpe ptp <=> >> Dp1 de ptp <<
end

spec Vector_Vector_Relation_Sets24 =
     Vector_Vector_Relations24
     then 
     Set[sort DipolDipolRelation24 fit Elem |-> DipolDipolRelation24] with
     Set[DipolDipolRelation24] |-> GenRel,
      __union__ |-> __union__
     then %cons
     ops 0 : GenRel = {}
end


spec Vector_Vector_Relation_Sets72 =
     Vector_Vector_Relations72
     then 
     Set[sort DipolDipolRelation72 fit Elem |-> DipolDipolRelation72] with
     Set[DipolDipolRelation72] |-> GenRel,
      __union__ |-> __union__
     then %cons
     ops 0 : GenRel = {}
end


%% We need to make the signatures compatible. Let's hope that we
%% are not hiding too much. 
spec DRA24CompositionHiding[sort Point] =
     DRA24Composition[sort Point] hide BaseRelation72, 
			   DipolRelation72, DipolPointRelation72,
			   rrrr, rrrl, rrlr, rrll, rlrr, rllr,
			   rlll, lrrr, lrrl, lrll, llrr, llrl,
			   lllr, llll, ells, eses, errs, lere,
			   rele, slsr, srsl, lsel, rser, sese,
			   BaseRelation24, 1, compl
end

spec VectorVectorRelationsHiding24 =
     Vector_Vector_Relation_Sets24 hide Vector, Elem
end

%% We need to make the signatures compatible. Let's hope that we
%% are not hiding too much. 
spec DRA72CompositionHiding[sort Point] =
     DRA72Composition[sort Point] hide BaseRelation24, 
			   DipolRelation24, DipolPointRelation24,
			   rrrr, rrrl, rrlr, rrll, rlrr, rllr,
			   rlll, lrrr, lrrl, lrll, llrr, llrl,
			   lllr, llll, ells, eses, errs, lere,
			   rele, slsr, srsl, lsel, rser, sese,
			   ffbb, efbs, ifbi, bfii, sfsi, beie,
			   bbff, bsef, biif, iibf, sisf, iebe, 
			   ffff, fefe, fifi, fbii, fsei, ebis,
			   iifb, eifs, iseb, bbbb, sbsb, ibib,
			   lllb, llfl, llbr, llrf, lirl, lfrr,
			   lril, lrri, blrr, irrl, frrr, rbrr,
			   lbll, flll, brll, rfll, rlli, rrlf,
			   illr, rilr, rrbl, rlir, rrfr, rrrb,
			   BaseRelation72, 1, compl
end

spec VectorVectorRelationsHiding72 =
     Vector_Vector_Relation_Sets72 hide Vector, Elem
end

view DRA72_In_Domain : DRA72CompositionHiding[sort Point] to
     VectorVectorRelationsHiding72 = r |-> dr, l |-> dl, s |-> ds,
     e |-> de, b |-> db, i |-> di, f |-> df
end

view DRA24_In_Domain : DRA24CompositionHiding[sort Point] to
     VectorVectorRelationsHiding24 = r |-> dr, l |-> dl, s |-> ds,
     e |-> de
end
library Calculi/Space/Domain_of_DRA
version 0.0

%author: Dominik Luecke
%date: 2007-05-07

%prec {__ * __} < {__ ^ __}
%prec {__ + __, __ - __} < {__ / __, __ * __}
%left_assoc __ + __, __ * __, __ ^ __

%%Domain for the DRA calculi

%%We consider a normed vector space over a totally ordered field

logic CASL

spec Field =
     sort Elem
     ops 0     : Elem;
	 1     : Elem;
	 __+__ : Elem * Elem -> Elem, assoc, comm, unit 0;
	 __*__ : Elem * Elem -> Elem, assoc, comm, unit 1;
	 -__   : Elem -> Elem
     forall a,b,c : Elem
     . a * ( a + c ) = ( a * b ) + ( a * c )           %(distribution)%
     forall a : Elem 
     . exists b : Elem . a + b = 0                     %(additive_inverse)%
     . exists b : Elem . not ( b = 0 ) => a * b = 1    %(mult_inverse)%
     then %implies
     forall a, b : Elem
     . ((- a ) + a = 0 )  /\ (exists b : Elem . a + b = 0) => (b = - a)    %(thm_inverse)%
     . a * 0 = 0                                                           %(thm_mult_with_inverse)%
     . (- 0 ) = 0                                                          %(0_is_self_inverse)%
     . - ( - a ) = a                                                       %(double_inverse)%
     . - ( a + b ) = ( - a ) + ( - b )                                     %(distri_inverse)%
end

spec TotalOrder = 
     sort Elem
     pred __ <= __ : Elem * Elem;
	  __<__    : Elem * Elem
     forall a, b, c : Elem
     . a <= a                                %(order_reflex)%
     . a <= b /\ b <= a => a = b             %(order_antisymmetric)%
     . a <=b /\ b <= c => a <= c             %(order_transitive)%
     . a <= b \/ b <= a                      %(order_total)%
     . a < b <=> a <= b /\ not ( a = b )     %(def_<)%
end

spec TotallyOrderedField = 
     Field and TotalOrder
     then
     forall a : Elem
     . 0 <= 1
     . a <= 0 <=> 0 <= ( - a )
     then %implies
     forall a : Elem
     . ( - a ) <= 0 <=> 0 <= a               %(thm_order)%
end 

spec Point[sort Elem] =
     free type Point ::= /__ __\ (x : Elem; y : Elem)
end

spec PointsOverField =
     Point[TotallyOrderedField]
     then 
     pred __<=__ : Point * Point
     forall a,b : Point
     . (a <= b) <=> ((x(a) <= x(b)) /\ (y(a) <= y(b)))
     %{
     then %implies
     . exists c, d : Point . not (c <= d) /\ not (d <= c)
     }%
end

spec VectorSpace[sort Space] = 
     Field
     then
     ops __+__ : Space * Space -> Space;
	 __*__ : Elem * Space -> Space;
	 -__   : Space -> Space;
	 0     : Space
     forall a, b, c : Space; e, f : Elem
     . a + ( b + c ) = ( a + b ) + c                 %(ax_asoc)%
     . a + b = b + a                                 %(ax_commut)%
     . a + 0 = a                                     %(ax_0)%
     . exists d : Space . a + d = 0                  %(ax_inverse)%
     . e * ( a + b ) = e * a + e * b                 %(ax_distri_1)%
     . ( e + f ) * a = e * a + f * a                 %(ax_distri_2)%
     . e * ( f * a) = ( e * f ) * a                  %(ax_mult)%
     . 1 * a = a
     then %implies
     forall a, b : Space
     . ((- a ) + a = 0 )  /\ (exists b : Space . a + b = 0) => (b = - a)    %(thm_inverse)%
end

spec Vector =
     TotallyOrderedField
     then
     free type Vector ::= [[__ __]](xc : Elem; yc : Elem) 
     then
     VectorSpace[sort Vector]
     then
     ops <__||__> : Vector * Vector -> Elem;
	 ||__||   : Vector -> Elem
     forall a, b : Vector
     . <a||b> = xc(a) * xc(b) + yc(a) * yc(b)      %(def_inner_prod)%
     . ||a|| * ||a|| = <a||a>                      %(def_norm)%
     then %implies
     forall a,b : Vector
     . <0||0> = 0                                  %(thm_zero)%
     . 0 <= ||a||                                  %(thm_norm>=0)%
     . <a||b> = <b||a>                             %(thm_commut)%
     . <a || a> = 0 => a = 0                       %(thm_x=0)%
end 

spec PointToVector =
     Vector 
     then PointsOverField
     then
     forall a,b : Point
     . exists c : Vector . c = [[x(a)+(-x(b)) y(a)+(-y(b))]]
end

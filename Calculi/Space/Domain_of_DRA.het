library Calculi/Space/Domain_of_DRA
version 0.0

from Basic/StructuredDatatypes get Set

%author: Dominik Luecke
%date: 2007-05-07

%prec {__ * __} < {__ ^ __}
%prec {__ + __, __ - __} < {__ / __, __ * __}
%left_assoc __ + __, __ * __, __ ^ __

%%Domain for the DRA calculi

%%We consider a normed vector space over a totally ordered field

logic CASL

spec Field =
     sort Elem
     ops 0     : Elem;
	 1     : Elem;
	 __+__ : Elem * Elem -> Elem, assoc, comm, unit 0;
	 __*__ : Elem * Elem -> Elem, assoc, comm, unit 1;
	 -__   : Elem -> Elem
     forall a,b,c : Elem
     . a * ( a + c ) = ( a * b ) + ( a * c )           %(distribution)%
     forall a : Elem 
     . exists b : Elem . a + b = 0                     %(additive_inverse)%
     . not ( a = 0 ) => (exists b : Elem . not ( b = 0 ) => a * b = 1)    %(mult_inverse)%
     then %implies
     forall a, b : Elem
     . ((- a ) + a = 0 )  /\ (forall c : Elem . (a + c = 0) => (c = - a))    %(thm_inverse)%
     . a * 0 = 0                                                           %(thm_mult_with_inverse)%
     . (- 0 ) = 0                                                          %(0_is_self_inverse)%
     . - ( - a ) = a                                                       %(double_inverse)%
     . - ( a + b ) = ( - a ) + ( - b )                                     %(distri_inverse)%
end

spec TotalOrder = 
     sort Elem
     pred __ <= __ : Elem * Elem;
	  __<__    : Elem * Elem
     forall a, b, c : Elem
     . a <= a                                %(order_reflex)%
     . a <= b /\ b <= a => a = b             %(order_antisymmetric)%
     . a <=b /\ b <= c => a <= c             %(order_transitive)%
     . a <= b \/ b <= a                      %(order_total)%
     . a < b <=> a <= b /\ not ( a = b )     %(def_<)%
end

spec TotallyOrderedField = 
     Field and TotalOrder
     then
     forall a : Elem
     . 0 <= 1
     . a <= 0 <=> 0 <= ( - a )
     then %implies
     forall a,b,c,d : Elem
     . ( - a ) <= 0 <=> 0 <= a               %(thm_order)%
     . a <= b /\ c <= d => a + c <= c + d    %(thm_order_+)%
end 

spec Point[sort Elem] =
     free type Point ::= /__ __\ (x : Elem; y : Elem)
end

spec PointsOverField =
     Point[TotallyOrderedField]
     then 
     pred __<=__ : Point * Point
     forall a,b : Point
     . (a <= b) <=> ((x(a) <= x(b)) /\ (y(a) <= y(b)))
end

spec VectorSpace[sort Space] = 
     Field
     then
     ops __+__ : Space * Space -> Space;
	 __*__ : Elem * Space -> Space;
	 -__   : Space -> Space;
	 0     : Space
     forall a, b, c : Space; e, f : Elem
     . a + ( b + c ) = ( a + b ) + c                 %(ax_asoc)%
     . a + b = b + a                                 %(ax_commut)%
     . a + 0 = a                                     %(ax_0)%
     . exists d : Space . a + d = 0                  %(ax_inverse)%
     . e * ( a + b ) = e * a + e * b                 %(ax_distri_1)%
     . ( e + f ) * a = e * a + f * a                 %(ax_distri_2)%
     . e * ( f * a) = ( e * f ) * a                  %(ax_mult)%
     . 1 * a = a
     then %implies
     forall a, b : Space
     . ((- a ) + a = 0 )  /\ (forall c : Space . ( a + c = 0) => (c = - a))    %(thm_inverse)%
end

spec Vector =
     TotallyOrderedField
     then
     free type Vector ::= [[__ __]](xc : Elem; yc : Elem) 
     then
     VectorSpace[sort Vector]
     then
     ops <__||__> : Vector * Vector -> Elem;
	 ||__||   : Vector -> Elem
     forall a, b : Vector
     . <a||b> = xc(a) * xc(b) + yc(a) * yc(b)      %(def_inner_prod)%
     . ||a|| * ||a|| = <a||a>                      %(def_norm)%
     then %implies
     forall a,b : Vector
     . <0||0> = 0                                  %(thm_zero)%
     . 0 <= ||a||                                  %(thm_norm>=0)%
     . <a||b> = <b||a>                             %(thm_commut)%
     . <a || a> = 0 => a = 0                       %(thm_x=0)%
end 

%% This spec is intended to be part of the interface from DRA to 
%% its domain
spec PointsToVector =
     Vector 
     then PointsOverField
     then
     type Dipol ::= [<__ __>] (sp : Point; ep : Point)
     then
     %% we consider s_a, e_a and a point pt in the 
     %% terminology of Moratz, Renz, Wolter:
     %% Qualitative Spatial Reasoing about Line Segments
     %% We are using a dipol and a point to calculate a 
     %% orthogonal coordinate system with basis in the 
     %% start point of the dipol
     ops A  : Vector;
     ops Ap : Vector;
     ops P  : Vector;
     ops s_A : Point;
     ops e_A : Point;
     ops pt  : Point;
     ops Dp : Dipol 
     . s_A = sp(Dp)
     . e_A = ep(Dp)
     . not ( s_A = e_A) => A  = [[x(e_A)+(-x(s_A)) y(e_A)+(-y(s_A))]]
     . not ( s_A = e_A) => Ap = [[y(e_A)+(-y(s_A)) x(s_A)+(-x(e_A))]]
     . not ( s_A = e_A) => P  = [[x(pt)+(-x(s_A))   y(pt)+(-y(s_A))]]
     . < A || Ap > = 0                       %(thm_orthogonal)% %implied
end

%% The definition of the 7 Dipol-Point relations via vectors
spec Vector_Vector_Relations =
     PointsToVector
     then
     TotallyOrderedField
     then
     free type DipolPointRelations ::= dr | dl | ds | de | db | di | df
     then
     pred __vr__ : Vector * Vector;
	  __vl__ : Vector * Vector;
	  __vs__ : Vector * Vector;	  
	  __ve__ : Vector * Vector;
	  __vb__ : Vector * Vector;
	  __vi__ : Vector * Vector;
	  __vf__ : Vector * Vector;
	  __dpr__ : Dipol * Point;
	  __dpl__ : Dipol * Point;
	  __dps__ : Dipol * Point;	  
	  __dpe__ : Dipol * Point;
	  __dpb__ : Dipol * Point;
	  __dpi__ : Dipol * Point;
	  __dpf__ : Dipol * Point 	  
     then
     free type DipolDipolRelation72 ::= <<__ __ __ __>> (fst: DipolPointRelations;
							    snd: DipolPointRelations;
							    trd: DipolPointRelations; 
							    frt: DipolPointRelations)
     pred >__ __ __< : Dipol * DipolDipolRelation72 * Dipol
     pred >>__ __ __<< : Dipol * DipolPointRelations * Point
     . A vr P <=> 0 < < Ap || P > 
     . A vl P <=> < Ap || P > < 0 
     . A vb P <=> < A || P > = -(||A|| * ||P||)
     . A ve P <=> (< A || P > = ||A|| * ||P||) /\ (||A|| = ||P||)
     . A vf P <=> (< A || P > = ||A|| * ||P||) /\ (||A|| < ||P||)
     . A vi P <=> (< A || P > = ||A|| * ||P||) /\ (||P|| < ||A||)
     . A vs P <=> (0 = ||P||)
     . Dp dpr pt <=> A vr P
     . Dp dpl pt <=> A vl P 
     . Dp dps pt <=> A vs P
     . Dp dpe pt <=> A ve P
     . Dp dpb pt <=> A vb P
     . Dp dpi pt <=> A vi P
     . Dp dpf pt <=> A vf P
     forall Dp1, Dp2 : Dipol; rel : DipolDipolRelation72; ptp : Point
     . > Dp1 rel Dp2 < <=> (>> Dp1 fst(rel) sp(Dp2) << /\
	                >> Dp1 snd(rel) ep(Dp2) << /\
		        >> Dp1 trd(rel) sp(Dp2) << /\
	                >> Dp1 frt(rel) ep(Dp2) << 
		       )
     . Dp1 dpr ptp <=> >> Dp1 dr ptp <<
     . Dp1 dpl ptp <=> >> Dp1 dl ptp <<     
     . Dp1 dps ptp <=> >> Dp1 ds ptp <<     
     . Dp1 dpe ptp <=> >> Dp1 de ptp <<
     . Dp1 dpb ptp <=> >> Dp1 db ptp <<
     . Dp1 dpi ptp <=> >> Dp1 di ptp <<     
     . Dp1 dpf ptp <=> >> Dp1 df ptp <<    
     then
     Set[sort DipolDipolRelation72 fit Elem |-> DipolDipolRelation72] with
     Set[DipolDipolRelation72] |-> GenRel,
      __union__ |-> __union__, __intersection__ |-> __cap__
end

spec VectorVectorRelationsHiding =
     Vector_Vector_Relations hide Vector, Elem, Nat, Pos
end

library Calculi/Space/EuclideanSpace
version 0.2
%author: S. Wölfl
%date: 12-10-2005
%% 

from Basic/LinearAlgebra_I  get
 	VectorSpace |-> VectorSpaceCASL
from Basic/Algebra_I  get
     	AbelianGroup, 
     	ExtAbelianGroup, 
     	Monoid,
     	Group
from HasCASL/TopologicalSpaces get 
	RichTopologicalSpace
from HasCASL/MetricSpaces get 
	MetricSpace
from HasCASL/Set get 
	Set
from HasCASL/Real get 
	Field,
	Real,
	OrderedField,
	FieldWithValuation,
	Real_as_FieldWithArchimedianValuation



logic CASL


spec VectorSpace_aux[Field] =
     VectorSpaceCASL[Field fit e |-> 1] 
end


logic HasCASL


spec VectorSpace[Field] =
     VectorSpace_aux[Field] with logic -> HasCASL
end


spec VectorSpaceWithNorm[FieldWithValuation with val |-> |__|]  given Real = 
     VectorSpace_aux[Field]
then
     op ||__|| : Space -> Real 
     forall a:Elem ; v,w: Space   
     . ||a * v|| = |a| * ||v||	 	%(homogen)%
     . ||v + w|| <= ||v|| + ||w||      	%(triangle)%
     . ||v|| = 0 <=> v = 0  	 	%(definit)%
end

spec VectorSpaceWithRealNorm = 
     VectorSpaceWithNorm[view Real_as_FieldWithArchimedianValuation] %% fit Elem |-> Real, val |-> |__|
end


spec RealVectorSpace = 
     VectorSpace[Real fit Elem |-> Real]
end


spec EuclideanVectorSpace = 
     RealVectorSpace
then
     op <__#__> : Space * Space -> Real   %% (bilinear form)

     forall a,b:Real ; v,v',w,w': Space
     . <v+v' # w> = <v # w> + <v' # w>  %(herm1)%
     . <a*v # w> = a * <v # w> 		%(herm2)%
     . <v # w> = <w # v>		%(sym)%
     . <v # v> = 0 =>  v = 0		%(pos_definit)%

then %implies
     forall a,b:Real ; v,v',w,w': Space
     . <v # w+w'> = <v # w> + <v # w'>
     . <v # a*w> = a * <v # w> 
end


view EuclideanVectorSpace_in_Real :
     EuclideanVectorSpace
to
     { Real then %def
       op <__#__> : Real * Real -> Real
       forall x,y:Real
       . <x # y> = x * y
      }
=
    sort Space |-> Real
end


spec ExtEuclideanVectorSpaceByNorm[EuclideanVectorSpace] = %def
     op ||__|| : Space -> Real
     forall v: Space
     . || v || = sqr(<v # v>)
then %implies
     forall v,w: Space; r: Real
     . | <v # w> | <= || v || * || w ||   		%(cauchy-schwarz)%
     . quad(||v + w||) = quad(||v||) + quad(||w||) + <v # w> + <w # v> %(pythagoras)%  
     . quad(||v + w||) + quad(||v + -1 * w||) = 2 * (quad(||v||) + quad(||w||))  %(parallel)%
end


view VectorSpaceWithNorm_in_EuclideanVectorSpace : 
     VectorSpaceWithNorm 
to
     ExtEuclideanVectorSpaceByNorm[EuclideanVectorSpace] 
end


spec Real2D =
     Real 
then %mono
     free type Space ::= <__!__> (pr1:Real;pr2:Real)
end


spec ExtReal2DByVectorSpace[Real2D] = 
     ops  0:Space;
	 __*__ : Real * Space -> Space;
	 __+__ : Space * Space -> Space  

     forall a,b:Real; v,w:Space
     . 0 = <0 ! 0>
     . a * v = <a*pr1(v) ! a*pr2(v)>
     . v + w = <pr1(v)+pr1(w) ! pr2(v)+pr2(w)>
end


spec ExtReal2DByBilinear[Real2D] =  
     ExtReal2DByVectorSpace[Real2D]
then %def
     op <__#__> : Space * Space -> Real
     forall x,y:Space
     . <x # y> = pr1(x) * pr1(y) + pr2(x) * pr2(y)
end


view RealVectorSpace_in_Real2D : 
     RealVectorSpace
to   ExtReal2DByVectorSpace[Real2D] 
end


view EuclideanVectorSpace_in_Real2D : 
     EuclideanVectorSpace
to   ExtReal2DByBilinear[Real2D] 
end



spec Real3D =
     Real 
then %mono
     free type Space ::= <__!__!__> (pr1:Real;pr2:Real;pr3:Real)
end


spec ExtReal3DByVectorSpace[Real3D] = 
     ops  0:Space;
	 __*__ : Real * Space -> Space;
	 __+__ : Space * Space -> Space  

     forall a,b:Real; v,w:Space
     . 0 = <0 ! 0 ! 0>
     . a * v = <a*pr1(v) ! a*pr2(v) ! a*pr3(v)>
     . v + w = <pr1(v)+pr1(w) ! pr2(v)+pr2(w) ! pr3(v)+pr3(w)>
end


spec ExtReal3DByBilinear[Real3D] =  
     ExtReal3DByVectorSpace[Real3D]
then %def
     op <__#__> : Space * Space -> Real
     forall x,y:Space
     . <x # y> = pr1(x) * pr1(y) + pr2(x) * pr2(y) + pr3(x) * pr3(y)
end


view RealVectorSpace_in_Real3D : 
     RealVectorSpace
to   ExtReal3DByVectorSpace[Real3D] 
end


view EuclideanVectorSpace_in_Real3D : 
     EuclideanVectorSpace
to   ExtReal3DByBilinear[Real3D] 
end





spec d =
     sort E
end





%[




spec ExtRealByMetric[Real] = %def
     op d: Real * Real -> Real
     forall x,y,r:Real
     . d(x,y)=r <=> x + r = y \/ y + r = x
end


view MetricSpace_From_ExtRealByMetric[Real]:
     MetricSpace to ExtRealByMetric[Real]
=  S |-> Real, d |-> d
end



spec EuclideanSpace3D = %def
     ExtRealByMetric[Real] 
then %def
local Set
within
     free type Point ::= <__ __ __>: (pr1:Real;pr2:Real;pr3:Real)
     op d: Point * Point -> Real
     forall x,y:Point;r:Real
     . d(x,y) = r * r <=> r = d(pr1(x),pr1(y)) * d(pr1(x),pr1(y))
				+ d(pr2(x),pr2(y)) * d(pr2(x),pr2(y))
				  + d(pr3(x),pr3(y)) * d(pr3(x),pr3(y))
end    


view MetricSpace_From_EuclideanSpace3D:
     MetricSpace to EuclideanSpace3D
=  S |-> Point, d |-> d
end 



spec EuclideanSpace2D = %def
     ExtRealByMetric[Real]
then %def
local Set
within
     free type Point ::= <__ __>: (pr1:Real;pr2:Real)
     op d: Point * Point -> Real
     forall x,y:Point;r:Real
     . d(x,y) = r * r <=> r = d(pr1(x),pr1(y)) * d(pr1(x),pr1(y))
				+ d(pr2(x),pr2(y)) * d(pr2(x),pr2(y))

end

]%


%%view MetricSpace_From_EuclideanSpace2D:
%%     MetricSpace to EuclideanSpace2D
%%=  S |-> Point, d |-> d
%%end 

library Calculi/Space/Interval version 0.7

%{Moore Intervals}%

%author Regivan H. N. Santiago <regivan@dimap.ufrn.br>
%date 15 November 2007

from Basic/Numbers get Rat

spec RatPair = Rat
then %mono
free type RatPair ::= __..__(proj1:Rat;proj2:Rat)
sort Interval = {a : RatPair . proj1(a) <= proj2(a)}
sort Rat < Interval
     forall a: Rat . a = (a..a) as Interval  %(Rat2Interval_embedding)%
then %def
ops
__+__ : Interval * Interval -> Interval,
comm,assoc,unit 0;
inva__: Interval -> Interval;
__-__ : Interval * Interval -> Interval;
__*__ : Interval * Interval -> Interval,
comm,assoc, unit 1;
invm__ : Interval ->? Interval;
__/__ : Interval * Interval -> Interval;
m__ : Interval -> Rat; %(midpoint)%
dist : Interval * Interval -> Rat; %(Distance)%
width__ : Interval -> Rat; %(width)%
abs: Interval -> Rat; %(absolute value)%
__cap__: Interval * Interval ->? Interval;
%(Intersection)%
then
preds __include__:Interval*Interval;
degen__:Interval; %($x$ is degenerate)%
__lc__:Interval*Interval; %(Local equality)%
__inf__:Interval*Interval; %(Inform. Order)%
vars x, y, w, z:Interval
%Some definitions
. def x %Every interval is defined
. x include y <=> (proj1(x) >= proj1(y) /\
proj2(x) <= proj2(y))
. degen(x) <=> proj1(x) = proj2(x)
. (x inf y) <=> (proj1(x)<= proj1(y)
/\ proj2(y) <= proj2(x))
%Local equality axioms
. (x lc x) <=> def x %(refllocJZ)%
. (x lc y) => (y lc x)
. def (x cap z) => ((x lc y) /\ (y lc z)=> (x lc z))
%Local equality introduction
. (x lc y) <=> def (x cap y) %(IntroLc01)%
. (x = y) => (x lc y) %(IntroLc02)%
%Congruence
. (x lc y) => (inva(x) lc inva(y))
. ((x lc y) /\ (def (invm(x)) /\ def (invm(y))))
=> (invm(x) lc invm(y))
. ((x lc y) /\ (w lc z)) => ((x + w) lc (y + z))
. ((x lc y) /\ (w lc z)) => ((x * w) lc (y * z))
%defSup
. ((x inf w) /\ (y inf z) /\ (w = z))
=> def(x cap y) /\ (x inf z) /\ (y inf w)
%Monotonicity
. ((x inf y) /\ (w inf z)) => (x + w) inf (y + z)
. ((x inf y) /\ (w inf z)) => (x * w) inf (y * z)
. (x inf y) => (inva(x) inf inva(y))
. (x inf y) => (invm(x) inf invm(y))
then %implies
vars x, y, z, w:Interval
%Subdistributivity
. x * (y + z) = (x * y) + (x * z) if degen(x)
. x * (y + z) include (x * y) + (x * z)
%local field axioms
. (x + (y + z)) lc ((x + y) + z)
. (x * (y * z)) lc ((x * y) * z)
. (x + y) lc (y + x)
. (x * y) lc (y * x)
. (x + inva(x)) lc 0
. (x * invm(x)) lc 1
. (x + 0) lc x
. (x * 1) lc x
. (x * (y + z)) lc ((x * y) + (x * z))
%Algebraic properties of intervals
. (x + inva(x)) = 0 if degen(x) %(inv+)%
. (x * invm(x)) = 1 if degen(x)
. (x * (y + z)) = ((x * y) + (x * z))
   if degen(x) /\ degen(y) /\ degen(z)
end

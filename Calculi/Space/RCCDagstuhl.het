
library Calculi/Space/RCCDagstuhl
version 0.1

%% author: S. Wölfl, T. Mossakowski
%% date: 25-11-2005


%( Proving correctness of composition table:
	We start with Bennett's version of RCC_FirstOrder 
	from his PhD thesis (1997) 
)%





spec RCC_FO = 
     sort QReg
     pred __C__: QReg * QReg;
     preds  __P__, __O__, __NTP__: QReg * QReg

     forall x,y: QReg
     . x P y   <=> forall z:QReg .(z C x => z C y)		%(P_def)%
     . x O y   <=> exists z:QReg .(z C z /\ z P x /\ z P y)	%(O_def)%
     . x NTP y <=> forall z:QReg .(z C x => z O y)		%(NTP_def)%
     . x C y => x C x					        %(C_non_null)%
     . x C y => y C x						%(C_sym)%
     . (forall z:QReg . z C x <=> z C y) => x = y     		%(C_id)%
%%     . exists z:QReg . forall u:QReg . 
%%		(z C u <=> ( not u NTP x \/ not u NTP y))	%(sum_ex)% 
     . x C x => exists z:QReg . (z C z /\ z NTP x) 		%(no_atoms)%

then %def
     sort Reg = { x: QReg . x C x }

then %implies
     forall x,y,z: Reg  
     . x O y => y O x						%(O_sym)%
     . x P y /\ y P z => x P z					%(cmps_PP)%	
     . x P y => x O y
end



spec ExtRCCByRCC5Rels[RCC_FO] = %def 
     preds
	  __PP__,  __PO__,  __EQ__, 
	  __DR__,  __PPi__, __?__: Reg * Reg

     forall x,y:Reg 
     . x PP y   <=>  x P y /\ not y P x              		%(PP_def)%
     . x PO y   <=>  x O y /\ not x P y /\ not y P x		%(PO_def)%
     . x DR y   <=>  not x O y					%(DR_def)%      	
     . x PPi y  <=> y PP x                                 	%(PPi_def)%
     . x EQ y   <=> x = y	                		%(EQ_def)%
     . x ? y    <=> x DR y \/ x PO y \/ x PP y \/ x PPi y \/ x EQ y 
								%(?_def)%
then %implies
     forall x,y,z:Reg 
     . x ? y

     . x PP y /\ y PP z => x PP	z				%(cmps_PPPP)%	
     . x PP y /\ y PPi z => x ? z  				%(cmps_PPPPi)%
     . x PP y /\ y PO z => x PP z \/ x PO z \/ x DR z		%(cmps_PPPO)%
     . x PP y /\ y DR z => x DR z				%(cmps_PPDR)%
     . x PP y /\ y EQ z => x PP z				%(cmps_PPEQ)%

     . x PPi y /\ y PP z => not x DR z				%(cmps_PPiPP)%	
     . x PPi y /\ y PPi z => x ? z				%(cmps_PPiPPi)%
     . x PPi y /\ y PO z => x PPi z \/ x PO z			%(cmps_PPiPO)%
     . x PPi y /\ y DR z => x PPi z \/ x PO z \/ x DR z		%(cmps_PPiDR)%
     . x PPi y /\ y EQ z => x PPi z				%(cmps_PPiEQ)%

     . x PO y /\ y PP z => x PP z \/ x PO z			%(cmps_POPP)%	
     . x PO y /\ y PPi z => x PPi z \/ x PO z \/ x DR z		%(cmps_POPPi)%
     . x PO y /\ y PO z => x ? z      				%(cmps_POPO)%
     . x PO y /\ y DR z => x PPi z \/ x PO z \/ x DR z		%(cmps_PODR)%
     . x PO y /\ y EQ z => x PO z				%(cmps_POEQ)%

     . x DR y /\ y PP z => x PP z \/ x PO z \/ x DR z		%(cmps_DRPP)%	
     . x DR y /\ y PPi z => x DR z				%(cmps_DRPi)%
     . x DR y /\ y PO z => x PP z \/ x PO z \/ x DR z		%(cmps_DRPO)%
     . x DR y /\ y DR z => x ? z				%(cmps_DRDR)%
     . x DR y /\ y EQ z => x DR	z 				%(cmps_DREQ)%

     . x EQ y /\ z PP z => x PP z   				%(cmps_EQPP)%	
     . x EQ y /\ z PPi z => x PPi z				%(cmps_EQPPi)%
     . x EQ y /\ z PO z => x PO	z				%(cmps_EQPO)%
     . x EQ y /\ z DR z => x DR	z 				%(cmps_EQDR)%
     . x EQ y /\ z EQ z => x EQ z				%(cmps_EQEQ)%


end


spec ExtRCCByRCC8Rels[RCC_FO] = %def 
     preds
	  __PP__,  __PO__,  __EC__,  __DC__, __EQ__, 
	 __TPP__, __NTPP__,  __DR__,  __Pi__,
	 __PPi__, __TPPi__,  __NTPPi__, __?__: Reg * Reg

     forall x,y:Reg 
     .   x PP y   <=>  x P y /\ not y P x              		%(PP_def)%
     .   x PO y   <=>  x O y /\ not x P y /\ not y P x		%(PO_def)%
     .   x DC y   <=>  not x C y				%(DC_def)%   
     .   x DR y   <=>  not x O y				%(DR_def)%      	
     .   x EC y   <=>  x C y /\ not x O y	          	%(EC_def)%
     .  x TPP y   <=>  x PP y /\ exists z:Reg. z EC x /\ z EC y %(TPP_def)%
     . x NTPP y   <=>  x PP y /\ forall z:Reg. z EC x => not z EC y 
								%(NTPP_def)%
     .    x Pi y  <=> y P x                                  	%(Pi_def)%
     .   x PPi y  <=> y PP x                                 	%(PPi_def)%
     .  x TPPi y  <=> y TPP x                                	%(TPPi_def)%
     . x NTPPi y  <=> y NTPP x	                		%(NTPPi_def)%
     . x EQ y     <=> x = y	                		%(EQ_def)%
     . x ? y      <=> x DR y \/ x PO y \/ x PP y \/ x PPi y \/ x EQ y 
								%(?_def)%
end











%[
spec RCC_FO = 
     sort Reg
     pred __C__: Reg * Reg;
then local {
     preds  __P__, __O__, __NTP__: Reg * Reg
     forall x,y: Reg
     . x P y   <=> forall z:Reg .(z C x => z C y)		%(P_def)%
     . x O y   <=> exists z:Reg .(z C z /\ z P x /\ z P y)	%(O_def)%
     . x NTP y <=> forall z:Reg .(z C x => z O y)		%(NTP_def)%
     	} 
within	{
     forall x,y: Reg
     . x C y => x C x					        %(C_non_null)%
     . x C y => y C x						%(C_sym)%
     . (forall z:Reg . z C x <=> z C y) => x = y     		%(C_id)%
     . exists z:Reg . forall u:Reg . 
		(z C u <=> ( not u NTP x \/ not u NTP y))	%(sum_ex)% 
     . x C x => exists z:Reg . (z C z /\ z NTP x) 		%(no_atoms)%
	}
end


spec RCC_FO1 = 
     sort Reg
     pred __C__: Reg * Reg;
then local {
     preds  __P__, __O__, __NTP__: Reg * Reg
within	{
     forall x,y: Reg
     . x P y   <=> forall z:Reg .(z C x => z C y)		%(P_def)%
     . x O y   <=> exists z:Reg .(z C z /\ z P x /\ z P y)	%(O_def)%
     . x NTP y <=> forall z:Reg .(z C x => z O y)		%(NTP_def)%
     . x C y => x C x					        %(C_non_null)%
     . x C y => y C x						%(C_sym)%
     . (forall z:Reg . z C x <=> z C y) => x = y     		%(C_id)%
     . exists z:Reg . forall u:Reg . 
		(z C u <=> ( not u NTP x \/ not u NTP y))	%(sum_ex)% 
     . x C x => exists z:Reg . (z C z /\ z NTP x) 		%(no_atoms)%
	}
end



spec RCC_FO3 = 
     sort Reg
     pred __C__: Reg * Reg;
     preds  __P__, __O__, __NTP__: Reg * Reg
     forall x,y: Reg
     . x P y   <=> forall z:Reg .(z C x => z C y)		%(P_def)%
     . x O y   <=> exists z:Reg .(z C z /\ z P x /\ z P y)	%(O_def)%
     . x NTP y <=> forall z:Reg .(z C x => z O y)		%(NTP_def)%
     . x C y => x C x					        %(C_non_null)%
     . x C y => y C x						%(C_sym)%
     . (forall z:Reg . z C x <=> z C y) => x = y     		%(C_id)%
     . exists z:Reg . forall u:Reg . 
		(z C u <=> ( not u NTP x \/ not u NTP y))	%(sum_ex)% 
     . x C x => exists z:Reg . (z C z /\ z NTP x) 		%(no_atoms)%
then %implies
     forall x,y,z: Reg  
     . x O y => y O x						%(O_sym)%
hide 
end

spec Ext_RCC_FO[RCC_FO] = %def     
     preds  __P__, __O__, __NTP__: Reg * Reg
     forall x,y: Reg
     . x P y   <=> forall z:Reg .(z C x => z C y)		%(P_def)%
     . x O y   <=> exists z:Reg .(z C z /\ z P x /\ z P y)	%(O_def)%
     . x NTP y <=> forall z:Reg .(z C x => z O y)		%(NTP_def)%
then %implies
     forall x,y,z: Reg  
     . x O y => y O x						%(O_sym)%
end     
end     



      then %implies
	

	. x P y /\ x C x => x C y			%(RCC_thm_non_null_P_implies_C)%
	. (exists y:Reg. x C y) => x C x		%(RCC_thm_help_1)%
	. (exists y:Reg. y C x) => x C x		%(RCC_thm_help_2)%
	.  x P y /\ (exists z:Reg. z C x) => x C y	%(RCC_thm_help_3)%
	. x P y /\ y P z => x P z			%(RCC_thm_P_trans)%
	. x P y /\ y P x => x = y			%(RCC_thm_P_extensionality)%




	forall x,y,z: Reg  
	. x POv y => y POv x 				%(RCC_thm_PO_sym_PO)%
	. x DC y => y DC x 				%(RCC_thm_PO_sym_DC)%
	. x EC y => y EC x 				%(RCC_thm_PO_sym_EC)%
	. x DR y => y DR x 				%(RCC_thm_PO_sym_DR)%
	. x EQ y => y EQ x 				%(RCC_thm_PO_sym_EQ)%
	. x PP y => x P y				%(RCC_thm_PP_subset_P)%
	. x TPP y => x PP y				%(RCC_thm_TPP_subset_PP)%
	. x NTPP y => x PP y				%(RCC_thm_NTPP_subset_PP)%
	. x TPPi y => y PP x				%(RCC_thm_TPPi_subset_Inv_PP)% 
	. x NTPPi y => y PP x				%(RCC_thm_NTPPi_subset_Inv_PP)%
	. x PP y => not y P x				%(RCC_thm_PP_subset_Cpl_Inv_P)% 
	. x P y /\ z C x => z C y			%(RCC_lem_PC_1)%
	. x PP y => not x EC y				%(RCC_thm_PP_implies_not_EC)%
	. x PP y /\ x C x => not x DC y			%(RCC_thm_PP_and_NotNull_implies_not_DC)%
	. x Ov y => x C y				%(RCC_thm_O_subset_C)%
	. x = y /\ x C x => not x DC y			%(RCC_thm_EQ_and_NotNull_implies_not_DC)%
	. x = y /\ x C x => not x EC y			%(RCC_thm_EQ_and_NotNull_implies_not_EC)%
	. x = y /\ x C x => not x TPP y			%(RCC_thm_EQ_and_NotNull_implies_not_TPP)%

end


spec RCC_FirstOrder_RelFunc 

     = 

     %% Definitions of algebraic operations  %%

     RCC_FirstOrder_Rel

     then 
     
	ops
		cp: Reg * Reg -> Reg; 
	     compl: Reg -> Reg;   
               sum: Reg * Reg -> Reg;
              prod: Reg * Reg -> Reg;
                 0: Reg;
                 1: Reg

	forall x,y,z: Reg
	. cp(x,y) = z <=> (forall u:Reg . 
                    (u C z <=> (not(u NTP x) \/ not(u NTP y))))
	.  compl(x) = cp(x,x)
	.  sum(x,y) = cp(cp(x,x),cp(y,y))
	. prod(x,y) = cp(cp(x,y),cp(x,y))
	.         0 = prod(x,compl(x))
	.         1 = sum(x,compl(x))

	
end

from  HasCASL/TopologicalSpaces get RegularClosedSets

logic HasCASL

view RCC_in_Topology_closed : 
  { RCC_FirstOrder reveal __C__ }
  to 
  { RegularClosedSets then
    pred __C__ (X,Y:RegularClosed) <=> not X disjoint Y
  } =
  Reg |-> RegularClosed
end

view RCC_in_Topology_open : 
  { RCC_FirstOrder reveal __C__ }
  to 
  { RegularClosedSets then
    pred __C__ (X,Y:RegularOpen) <=> not cls(X) disjoint cls(Y)
  } =
  Reg |-> RegularOpen
end

]%
library Calculi/Time/AllenHayesLadkin_TAPCAS
version 0.1 

%author: S. Wölfl
%date: 22-10-04

%{
	 Allen Hayes First-Order Theory on Intervals -- First order theory
	 Based on Peter B. ladkin's PhD thesis (1987): 
	       The Logic of Time Represenation 

	 Further readings:

	 All83 : Allen, J.F., Maintaining Knowledge about Temporal Intervals,
	 Comm. A.C.M.  26 (11), November 1983, 832-843.

	 All84 : Allen, J.F., Towards a General Theory of Action and Time,
	 Artificial Intelligence 23 (2), July 1984, 123-154.

	 AllKau85 : Allen, J.F. and Kautz, H., A Model of Naive Temporal
	 Reasoning, in Hobbs, J.R. and Moore, R.C., editors, Formal Theories
	 of the Commonsense World, Ablex 1985.

	 AllHay85 : Allen J.F. and Hayes, P. J., A Commonsense Theory of Time,
	 Proceedings of the 9th International Joint Conference on Artificial
	 Intelligence, Los Angeles, California, Morgan Kaufmann 1985, 528-531.

	 AllHay87.1 : Allen J.F. and Hayes, P. J., Short Time Periods,
	 Proceedings of the 10th International Joint Conference on Artificial
	 Intelligence, Milano, Italy, Morgan Kaufmann 1987, 981-983.

	 AllHay87.2 : Allen J.F. and Hayes, P. J., A Commonsense Theory of
	 Time: The Longer Paper, Technical Report, Dept. of Computer Science,
	 University of Rochester.

	 Ham71 : Hamblin, C.L., Instants and Intervals, Studium Generale (27),
	 1971, 127-134. 

	 Hum79 : Humberstone, I.L., Interval Semantics for Tense Logic: Some
	 Remarks, J. Philosophical Logic 8, 1979, 171-196.

	 Lad86.1 : Ladkin, P.B., Time Representation: A Taxonomy of Interval
	 Relations, Proceedings of AAAI-86, 360-366, Morgan Kaufmann, 1986.

	 Lad86.2 : Ladkin, P.B., Primitives and Units for Time Specification,
	 Proceedings of AAAI-86, 354-359, Morgan Kaufmann, 1986.

	 Lad86.3 : Ladkin, P.B., Two Papers on Time Representation, Kestrel
	 Institute Research Report KES.U.86.5, 1986.

	 Lad87a : Ladkin, P.B., Specification of Time Dependencies and
	 Synthesis of Concurrent Processes, Proceedings of the 9th
	 International Conference on Software Engineering, Monterey, Ca, IEEE
	 1987, also available as Kestrel Institute Technical Report
	 KES.U.87.1.

	 Lad87b : Ladkin, P.B., The Completeness of a Natural System for
	 Reasoning with Time Intervals, Proceedings of the 10th International
	 Joint Conference on Artificial Intelligence, Milano, Italy, Morgan
	 Kaufmann 1987, 462-467, also available as Kestrel Institute Technical
	 Report KES.U.87.5.

	 Lad87c : Ladkin, P.B., Models of Axioms for Time Intervals,
	 Proceedings of AAAI87, Morgan Kaufmann 1987, also available in a
	 longer version as Kestrel Institute Technical Report KES.U.87.4.

	 Lad87d : Ladkin, P.B., Deciding First-Order Statements About Time
	 Intervals: Preliminary Report, Kestrel Institute Technical Report
	 KES.U.87.7.

	 Lad87e : Ladkin, P.B., Constraint Satisfaction in Time Interval
	 Structures I: Convex Intervals, forthcoming Kestrel Institute
	 Technical Report, 1987.

	 LadMad87 : Ladkin, P.B. and Maddux, R.D., The Algebra of Convex
	 Time Intervals, Kestrel Institute Technical Report KES.U.87.2.

	 New80 : Newton-Smith, W.H., The Structure of Time, Routledge Kegan
	 Paul, 1980. PelAll86 : Pelavin, R., and Allen, J.F., A Formal Logic
	 of Plans in Temporally Rich Domains, Proceedings of the IEEE 74 (10),
	 Oct 1986, 1364-1382.

	 Rop79 : Roper, P., Intervals and Tenses, Journal of Philosophical
	 Logic 9, 1980. 

	 vBen83 : van Benthem, J.F.A.K., The Logic of Time, Reidel 1983. 

	 VilKau86 : Vilain, M., and Kautz, H., Constraint Propagation
	 Algorithms for Temporal Reasoning, Proceedings of AAAI-86, 377-382,
	 Morgan Kaufmann, 1986.
}%





spec AllenHayes = 
     sort Int
     preds __M__: Int * Int
     forall x,y,z,u:Int
     %% meeting places are unique:
     . x M y /\ x M u /\ z M y => z M u			%(M1)%
     %% meeting places are linearily ordered     
     . x M y /\ z M u =>  x M u 
		      \/ (exists v:Int. x M v /\ v M u) 
		      \/ (exists v:Int. z M v /\ v M y) 
							%(M2a)%
     . x M y /\ z M u /\ x M u => 
			not (exists v:Int. x M v /\ v M u) 
		     /\ not (exists v:Int. z M v /\ v M y) 
							%(M2b)%
     . x M y /\ z M u /\ (exists v:Int. x M v /\ v M u) => 
			not (x M u) 
		     /\ not (exists v:Int. z M v /\ v M y) 
							%(M2c)%
     . x M y /\ z M u /\ (exists v:Int. z M v /\ v M y) => 
			not (x M u) 
		     /\ not (exists v:Int. x M v /\ v M u) 
							%(M2d)%
     %% time is infinite, both to the past and to the future:		
     . exists y,z:Int . y M x /\ x M z		%(M3)%
					
     %% we do not care about endpoints of intervals:
     . x M y /\ y M u /\ x M z /\ z M u => y = z	%(M4)%
     %% 
     . x M y => exists z:Int . forall v:Int 
	. (v M z <=> v M x)  /\ (z M v <=> y M v)       %(M5exist)%

then %implies
   forall x,y,z:Int
   . not (x M x)					%(M_irrefl)%
   . x M y => not (y M x)				%(M_asym)%
   . x M y /\ y M z => not (x M z)			%(M_atrans)% 
end


spec ExtAllenHayesByRelations [AllenHayes] = %def
     preds  __B__, __O__,  __S__, __F__,  __D__, __E__: Int * Int
      
     forall x,y:Int
     . x B y <=> exists z:Int . x M z /\ z M y     %(B_def)%
     . x S y <=> exists z:Int . x M z /\ 
			(forall u:Int . y M u <=> z M u)
							%(S_def)%
     . x F y <=> exists z:Int . z M x /\ 
			(forall u:Int . u M y <=> u M z)
							%(F_def)%
     . x O y <=> exists z,u:Int . z S x /\ z M y /\ 
			x M u /\ u F y			
					                %(O_def)%
     . x D y <=> exists z,u:Int . z S y /\ z M x /\ 
			x M u /\ u F y	
					                %(D_def)%
     . x E y <=> forall z:Int . (z M x <=> z M y) /\ (x M z <=> y M z)
then %implies
     forall x,y,z:Int
     . x M y /\ y M z => x B z
     . x M y /\ y B z => x B z
     . x B y /\ y M z => x B z
     . x B y /\ y B z => x B z

     . x B y \/ x M y \/ x O y \/ x D y \/ x S y \/ x F y \/ x E y \/
	 y B x \/ y M x \/ y O x \/ y D x \/ y S x \/ y F x 
	 						%(All13_JE)%
end

spec ExtAllenHayesByCup [AllenHayes] = 
     ExtAllenHayesByRelations [AllenHayes]
then %def
     op __cup__: Int * Int ->? Int
     forall x,y,z:Int
     . def(x cup y) <=> x M y \/ y M x
     . x M y => (x cup y = z  <=> forall v:Int 
	. (v M z <=> v M x)  /\ (z M v <=> y M v))
     . y cup x = x cup y if def(x cup y)     
then %implies
     forall x,y:Int
     . x B y <=> exists z:Int . x M z /\ (x cup z) M y
%%     . x S y <=> exists z:Int . ()  
end
	
spec RichAllenHayes = 
     ExtAllenHayesByCup [AllenHayes]
end


spec ConstructPointsFromIntervals =
     AllenHayes
then %def
     preds  __ __ Equiv __ __: Int * Int * Int * Int;
	    __ __ PointLess __ __: Int * Int * Int * Int


     forall x,y,z,u:Int
     . x y Equiv z u <=> x M y /\ z M u /\ x M u	%(Equiv_def)%
%%     . x y PointLessOrg z u <=> (exists r,s,t:Int 
%%				    . x y Equiv r s /\ z u Equiv s t)
%%							%(PointLessOrg_def)%
     . x y PointLess z u <=> (exists v:Int 
				    . x y Equiv x v /\ z u Equiv v u)
							%(PointLess_def)%


then %implies
     forall x,y,z,u,v,w:Int 
     . x M y => x y Equiv x y				%(Equiv_refl)%
     . x y Equiv z u => z u Equiv x y			%(Equiv_sym)%
     . x y Equiv z u /\ z u Equiv v w => x y Equiv v w  %(Equiv_trans)%

     . x M y => not(x y PointLess x y)			%(PointLess_irrefl)%
     . x y PointLess z u /\ z u PointLess v w => x y PointLess v w 
	   						%(PointLess_trans)%    
     . x M y /\ z M u => (x y PointLess z u \/ x y Equiv z u  \/ 
			      z u PointLess x y)
							%(PointLess_linear)%
end


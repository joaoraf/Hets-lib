library Calculi/Time/PointAlgebraLin
version 0.4
%% author: S. Wölfl
%% date: 22-06-2005
%% 

%left_assoc __cup__,__cap__
%prec {__cup__} < {__cmps__}
%prec {__cmps__} < {__cmpl__} 

from Calculi/Algebra/BooleanAlgebra get 
	BooleanAlgebraWithCompl,
	ExtBooleanAlgebraByOrderRelations,
	AtomicBooleanAlgebra 
from Calculi/Algebra/RelationAlgebra get 
	AtomicRelationAlgebra,
	IntegralRelationAlgebra,
	SymmetricRelationAlgebra
from Calculi/Algebra/RelationAlgebraSymbolic get 
	CompositionTable,
	GroundingCompositionTable,	
	ConstructBooleanAlgebra,		
	ConstructPseudoRelationAlgebra,
	ConstructExtPseudoRelationAlgebra
from Calculi/Algebra/RelationAlgebraModel get 
	AlgebraOfBinaryRelations,
	JEPDBaseRelationModel,
	BaseRelationModel,
	ConstructPseudoModelFromBaseRelationModel
from Calculi/Time/LinearFlowOfTime get 
	DnsLinFlowOfTimeSEnd,
	NTLinFlowOfTime |-> LinFlowOfTime 
	   %% we just consider flows of time with at least 2 elements

from Calculi/Time/FlowOfTime get 
	ExtFlowOfTimeByConvexity,
	ExtFlowOfTimeBySetRelations


%(  Part I: Symbolic Level

    We start by describing the symbolic level of the point algebra
    of linear time (abbrev. by PAlin), i.e., the set of base relations 
    and the composition table. Arbitrary relations of PAlin are 
    represented as sets of base relations. In turn base relations are 
    represented by their respective singleton sets. The spec
    RelationBaseOfPintAlgebraLin builds this set of all relations, 
    which obviously forms an atomic boolean algebra. Via the composition 
    table we then define a relation algebra on the set of all relations. 
    This provides us with a specification of PAlin, namely spec 
    PAlin.
)%

%( 
     The Point Algebra for linear flows of time has three base relations,
     namely, p ("precedes"), pi ("precedes inverse"), and e ("equals").
)%


spec PAlinBaseRelations = %mono
     free type BaseRel ::= p | pi | e
end

%(   The following specs encode the composition table of PAlin as well as 
     the information on inverses of base relations.
)%


spec PAlinCompositionTable =
     sort BaseRel
     ops p,pi,e: BaseRel
and 
     CompositionTable with op id |-> e
then
     . inv(p) = pi					%(inv_p)%
     . inv(pi) = p					%(inv_pi)%
     . inv(e) = e					%(sym_e)%
     . p cmps p  = p 					%(cmps_pp)%	
     . p cmps pi = 1					%(cmps_ppi)%
     . p cmps e  = p					%(cmps_pe)%
     . pi cmps p  = 1 					%(cmps_pip)%	
     . pi cmps pi = pi					%(cmps_pipi)%
     . pi cmps e  = p					%(cmps_pie)%
     . e cmps p  = p 					%(cmps_ep)%	
     . e cmps pi = pi					%(cmps_epi)%
     . e cmps e  = e					%(cmps_ee)%
end


view PAlinCompositionTable_as_GroundingCompositionTable:
     GroundingCompositionTable to PAlinCompositionTable
=
     id |-> e
end


spec BooleanAlgebraOfPAlinRelations = 
     ConstructBooleanAlgebra[PAlinBaseRelations] 
end

view BooleanAlgebraOfPAlinRelations_as_AtomicBooleanAlgebra :
     AtomicBooleanAlgebra to BooleanAlgebraOfPAlinRelations
= 
     Elem |-> Rel, AtomElem |-> BaseRel
end


spec PAlin = 
     ConstructPseudoRelationAlgebra[PAlinBaseRelations]
	[PAlinCompositionTable fit op id:BaseRel |-> e]
end


spec RichPAlin =
     ConstructExtPseudoRelationAlgebra[PAlinBaseRelations]
	[PAlinCompositionTable fit op id:BaseRel |-> e]
end	


view PAlin_as_AtomicRelationAlgebra :
     AtomicRelationAlgebra to 
     RichPAlin 
=
     AtomRel |-> BaseRel
end


view PAlin_as_IntegralRelationAlgebra :
     IntegralRelationAlgebra to RichPAlin
end


view PAlin_as_SymmetricRelationAlgebra :
     SymmetricRelationAlgebra to RichPAlin
end


%(  Part II: Semantic Level

    Following we describe how models of PAlin can be constructed from 
    dense linear flows of time without endpoints. 
)%



logic HasCASL


spec PAlinBaseRelationModel[LinFlowOfTime] = %def 
     BaseRelationModel[LinFlowOfTime fit Elem |-> Instant]  
then %def
     ops pRel,eRel,piRel:Relation 
     free type BaseRel ::= pRel | eRel | piRel 

     forall x,y:Instant
     . (x,y) isIn rep(pRel)  <=> x pre y
     . (x,y) isIn rep(eRel)  <=> x = y
     . (x,y) isIn rep(piRel) <=> y pre x
end


 
view JEPDBaseRelationModel_From_PAlinBaseRelationModel[LinFlowOfTime]:
     JEPDBaseRelationModel 
to 
     PAlinBaseRelationModel[LinFlowOfTime]
=    sort Elem |-> Instant
end


spec ConstructPAlinPseudoModel[LinFlowOfTime] = %def
     ConstructPseudoModelFromBaseRelationModel[	
	PAlinBaseRelationModel[LinFlowOfTime] fit Elem |-> Instant]
end
	

spec PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd] = %def
     ConstructPAlinPseudoModel[LinFlowOfTime]
end


spec Rich_PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd] = %def
     PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd]
then %def
     ops __cmps__:BaseRel*BaseRel -> Rel;
	    inv__:BaseRel -> BaseRel
end


view PAlinDnsLinFlowTimeSEndModel_modelsExtensionally_PAlinCompositionTable[DnsLinFlowOfTimeSEnd] :
     PAlinCompositionTable 
to 
     Rich_PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd]
=   
    ops p|->pRel, pi|->piRel, e|->eRel
end



view DnsLinFlowOfTimeSEnd_induces_AlgebraOfBinaryRelations[DnsLinFlowOfTimeSEnd] :
    AlgebraOfBinaryRelations 
to 
    PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd] 
=
    Elem |-> Instant, Rel |-> Rel 
end


view DnsLinFlowOfTimeSEnd_induces_ModelOfPAlin[DnsLinFlowOfTimeSEnd] :
     { PAlin 
	hide ops __+__,__-__,{},{__},     
	     preds __eps__,__isSubsetOf__,isNonEmpty 
     } 	
to 
    Rich_PAlinDnsLinFlowOfTimeSEndModel[DnsLinFlowOfTimeSEnd]
=   
    ops p|->pRel, pi|->piRel, e|->eRel
end





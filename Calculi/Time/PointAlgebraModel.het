library Calculi/Time/PointAlgebraModel

version 0.1
%author: S. Wölfl
%date: 00-02-2005

%( 
    This library defines the model classes for the relation algebras in
    
	Calculi/Time/PointAlgebra

)%

from HasCASL/Set get Set
from Calculi/Algebra/RelationAlgebra get RelationAlgebra,
	ExtRelationAlgebraByPartialOrder, RelationAlgebraWithPartialOrder,
	AtomicRelationAlgebra,CompositionTable
from Calculi/Algebra/Auxiliary get BooleanAlgebraWithCompl
from Calculi/Time/LinearFlowOfTime get DnsLinFlowOfTime,
	DnsLinFlowOfTimeSEnd



logic HasCASL


spec JEPDBase[sort Elem] =
     Set
then
     op baseRel:Set(Set(Elem*Elem))
     type BaseRel = {X:Set(Elem*Elem) . baseRel X }
     %% type BaseRel :: Set(Set(Elem*Elem))
then
     forall x,y:Elem; r,s:BaseRel
     . exists r:BaseRel . (x,y) isIn r			%(JointlyExhaustive)%
     . not r = s => r intersection s = emptySet		%(PairwiseDisjoint)%
end


spec AlgebraOfBinaryRelation[sort Elem] =
     Set
then 
     op rel:Set(Set(Elem*Elem))

then %def
     type Rel = {X:Set(Elem*Elem) . rel X }
     ops
	 0,1:Rel;
         __cup__,__cap__:  Rel * Rel -> Rel;
         compl__:Rel -> Rel;

      forall r,s:Rel; x:Elem
      . 0 = emptySet
      . 1 = allSet
      . compl(r) = 1 \\ r
      . r cup s = r union s
      . r cap s = r intersection s

then %implies 
     ops
         __cup__:  Rel * Rel -> Rel, assoc, comm, idem, unit 1;
	 __cap__:  Rel * Rel -> Rel, assoc, comm, idem, unit 0;  
end


view AlgebraOfBinaryRelation_as_BoolenAlgebra:
     BooleanAlgebraWithCompl to AlgebraOfBinaryRelation[sort Elem]
=
     sort Elem |-> Rel 
end




spec AlgebraOfBinaryRelationWithComposition[sort Elem] = %def
      AlgebraOfBinaryRelation[sort Elem]
then %def
     ops
	id:Rel; 
        conv__:Rel -> Rel;         
	__cmps__:  Rel * Rel -> Rel

     forall r,s:Rel
     . id =  \(x,y):Elem*Elem . x = y
     . r cmps s = \(x,y):Elem*Elem . ( exists z:Elem . (x,z) isIn r /\ (z,y) isIn s )
     . conv(r) = \(x,y):Elem*Elem . (y,x) isIn r

then %implies
     ops
          __cmps__: Rel * Rel -> Rel, assoc, unit id;
     forall x:Rel
     . conv(conv(x)) = x
    . conv(id) = id
end






%(
spec ModelPointAlgebraLinBase = 
     DnsLinFlowOfTimeSEnd and Set
then %def
     ops 
	Pre:Set(Instant*Instant) = \(x:Instant,y:Instant) . x pre y;
	Id:Set(Instant*Instant) = \(x:Instant,y:Instant) . x = y;
	Suc:Set(Instant*Instant) = \(x:Instant,y:Instant) . y pre x
     op baseRel:Set(Set(Instant*Instant)) = \X:Set(Instant*Instant) . X=Pre \/ X=Id \/ X=Suc
     type BaseRel = {X:Set(Instant*Instant) .  baseRel X }
end


view ModelPointAlgebraLinBase_as_JEPDBase:
     JEPDBase to ModelPointAlgebraLinBase
= 
    sort Elem |-> Instant, sort BaseRel |-> BaseRel, op baseRel |-> baseRel
end


spec ModelPointAlgebraLin =
	GenerateRelationAlgebraFromBase[view ModelPointAlgebraLinBase_as_JEPDBase]
end

spec ModelPointAlgebraLinV =
	GenerateRelationAlgebraFromBase[JEPDBase fit Elem |-> Instant]
end


view ModelPointAlgebraLin_as_RelationAlgebra:
     RelationAlgebra to ModelPointAlgebraLin
=
     Rel |-> GenRel
end
)%






library Calculi/Time/PointAlgebraModel

version 0.1
%author: S. Wölfl
%date: 00-02-2005

%( 
    This library defines the model classes for the relation algebras in
    
	Calculi/Time/PointAlgebra

)%

from HasCASL/Set get Set
from Calculi/Algebra/RelationAlgebra get RelationAlgebra,
	ExtRelationAlgebraByPartialOrder, RelationAlgebraWithPartialOrder,
	AtomicRelationAlgebra,CompositionTable
from Calculi/Algebra/Auxiliary get BooleanAlgebraWithCompl
from Calculi/Time/LinearFlowOfTime get DnsLinFlowOfTime,
	DnsLinFlowOfTimeSEnd



logic HasCASL


spec JEPDBase[sort Elem] =
     Set
then
     type BaseRel 
then
     forall x,y:Elem; r,s:BaseRel
     . exists r:BaseRel . (x,y) isIn r			%(JointlyExhaustive)%
     . not r = s => r intersection s = emptySet		%(PairwiseDisjoint)%
end



spec FullRelationAlgebra[sort Elem] =
     Set
then %def
     type Relation = {X:Set(Elem*Elem) . X = X}
     ops
	 0,1,id:Relation;
         __cup__,__cap__,__cmps__:  Relation * Relation -> Relation;
         compl__,conv__:Relation -> Relation;

     forall r,s:Relation; x,y:Elem
     . 0 = emptySet
     . 1 = allSet
     . compl(r) = 1 \\ r
     . r cup s = r union s
     . r cap s = r intersection s
     . (x,y) isIn id <=> x = y
     . (x,y) isIn r cmps s <=> exists z:Elem . (x,z) isIn r /\ (z,y) isIn s 
     . (x,y) isIn conv(r) <=> (y,x) isIn r

then %implies 
     ops
         __cup__:  Relation * Relation -> Relation, assoc, comm, idem, unit 1;
	 __cap__:  Relation * Relation -> Relation, assoc, comm, idem, unit 0;  
         __cmps__: Relation * Relation -> Relation, assoc, unit id;
     forall x:Relation
     . compl(compl(x)) = x 
     . conv(conv(x)) = x 
end


spec AlgebraOfBinaryRelation[sort Elem] =
	FullRelationAlgebra[sort Elem]
then
     type Rel < Relation
     ops
	 0,1,id:Rel; 
	__cup__,__cap__,cmps__:  Rel * Rel -> Rel;
        compl__,conv__:Rel -> Rel;
then %implies
     ops	
	__cup__:  Rel * Rel -> Rel, assoc, comm, idem, unit 1:Rel;
 	__cap__:  Rel * Rel -> Rel, assoc, comm, idem, unit 0;  
        __cmps__: Rel * Rel -> Rel, assoc, unit id;
     forall x,y:Rel
     . compl(compl(x)) = x 
     . conv(conv(x)) = x 
%%     . exists y:Relation . x =y
end
   

  
view AlgebraOfBinaryRelation_as_BoolenAlgebra:
     BooleanAlgebraWithCompl to AlgebraOfBinaryRelation[sort Elem]
=
     sort Elem |-> Rel 
end


%(	

spec AlgebraOfBinaryRelationWithComposition[sort Elem] = %def
      AlgebraOfBinaryRelation[sort Elem]
then %def
     ops
	id:Rel; 
        conv__:Rel -> Rel;         
	__cmps__:  Rel * Rel -> Rel

     forall r,s:Rel
     . id =  \(x,y):Elem*Elem . x = y
     . r cmps s = \(x,y):Elem*Elem . ( exists z:Elem . (x,z) isIn r /\ (z,y) isIn s )
     . conv(r) = \(x,y):Elem*Elem . (y,x) isIn r

then %implies
     ops
          __cmps__: Rel * Rel -> Rel, assoc, unit id;
     forall x:Rel
     . conv(conv(x)) = x
    . conv(id) = id
end







spec ModelPointAlgebraLinBase = 
     DnsLinFlowOfTimeSEnd and Set
then %def
     ops 
	Pre:Set(Instant*Instant) = \(x:Instant,y:Instant) . x pre y;
	Id:Set(Instant*Instant) = \(x:Instant,y:Instant) . x = y;
	Suc:Set(Instant*Instant) = \(x:Instant,y:Instant) . y pre x
     op baseRel:Set(Set(Instant*Instant)) = \X:Set(Instant*Instant) . X=Pre \/ X=Id \/ X=Suc
     type BaseRel = {X:Set(Instant*Instant) .  baseRel X }
end


view ModelPointAlgebraLinBase_as_JEPDBase:
     JEPDBase to ModelPointAlgebraLinBase
= 
    sort Elem |-> Instant, sort BaseRel |-> BaseRel, op baseRel |-> baseRel
end


spec ModelPointAlgebraLin =
	GenerateRelationAlgebraFromBase[view ModelPointAlgebraLinBase_as_JEPDBase]
end

spec ModelPointAlgebraLinV =
	GenerateRelationAlgebraFromBase[JEPDBase fit Elem |-> Instant]
end


view ModelPointAlgebraLin_as_RelationAlgebra:
     RelationAlgebra to ModelPointAlgebraLin
=
     Rel |-> GenRel
end
)%






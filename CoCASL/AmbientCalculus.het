library CoCASL/Examples

%display  __union__          %LATEX __\cup__
%display  __setMinus__       %LATEX __\setminus__
%display  __disjointUnion__  %LATEX __\cup__
%display  __member__         %LATEX __\epsilon__
%display  __inCap__          %LATEX __in__

%left_assoc __||__

logic CoCASL

spec Set[sort Elem] =

free {
    type Set[Elem] ::= {} | {__}(Elem) | __union__(Set[Elem]; Set[Elem])
    op __union__ : Set[Elem] * Set[Elem] -> Set[Elem], 
                assoc, comm, idem, unit {} }
    then
    pred __member__: Elem * Set[Elem]
    forall x,y: Elem; M,N: Set[Elem]
    . not x member {}                                
    . x member {y} <=> x=y 
    . x member M union N <=> x member M \/ x member N
    then
    op __setMinus__, __disjointUnion__ : Set[Elem] * Set[Elem] -> Set[Elem]
    op __-__ : Set[Elem] * Elem -> Set[Elem]
    
spec FinalLTS =
    sort Label 
    then cofree {
        sort State
        then free {
            type Set ::= {} | {__}(State) | __union__(Set; Set);
            op __union__ : Set * Set -> Set, 
                        assoc, comm, idem, unit {} }
        then cotype State ::= (next : Label -> Set) }
end   

spec ACDomain[sort Name] = Set[sort Name] then
cofree {
    sort State
    free type Cap ::= inCap | out | open         
    free type HCap ::= enter | coenter | exit | coopen
    free type Action ::= tau | action(Cap; Name)
    free type HAct ::= haction(HCap; name : Name)
    free type Concretion ::= conc(State; State)
    then Set[sort State] and Set[sort Concretion]
    then cotype State ::= (next : Action -> Set[State];
                           harden : HAct -> Set[Concretion]; 
                           names : Set[Name]) }
end

spec Zero = ACDomain[sort Name]
then op zero : State
     vars a : Action; b : HAct
         . next(a, zero) = {}
         . harden(b, zero) = {}
         . names(zero) = {}
end

spec CapabilityPrefixing = Zero
then op cap : Cap * Name * State -> State
     vars a : Action; b : HAct; c : Cap; n : Name; P: State
     . next(a, cap(c, n, P)) = { P } when a = action(c, n) else {}
     . harden(b, cap(c, n, P)) = {}
     . names(cap(c, n, P)) = { n } union names(P)
end

spec NameRestriction = ACDomain[sort Name]
then op res : Name * State -> State
     vars a : Action; b : HAct; n : Name; P, Q : State; c : Concretion 
     . Q member next(a, res(n, P)) <=> 
        exists R : State . Q = res(n, R) /\ R member next(a, P) /\ not name(a)=n
     . c member harden(b, res(n, P)) <=>
        (exists R, S : State
         . c = conc(R, res(n, S))
           /\ conc(R, S) member harden(b, P) 
           /\ not n member names(R)) \/
        (exists R, S : State
         . c = conc(res(n, R), S) 
           /\ conc(R, S) member harden(b, P) 
           /\ not n member names(S)) \/
        (exists R, S : State
         . c = conc(rename(R,n,m), rename(S,n,m)) 
           /\ conc(R, S) member harden(b, P) 
           /\ not m member names(P)
           /\ n member names(S)
           /\ n member names(R))
      . names(res(n, P)) = names(P) - n

spec ParallelComposition = ACDomain[sort Name]
then op __||__ : State * State -> State, assoc  %implied
    vars a : Action; b : HAct; n : Name; P, Q, R : State
    . R member next(a, P || Q) <=>
       (exists P',Q2' : State; Q1' : Prime; f : Set[Name]
        . R = P' || Q2' 
          /\ P' member next(action(open, n), P)
          /\ conc(Q1', Q2', f) member harden(haction(coopen, n), Q)) 
%[ \/
        (exists P2',Q2' : State; P1', Q1' : Prime; f1, f2 : Set[Name]
        . R = P' || Q2' 
          /\ P' member next(action(open, n), P)
          /\ conc(Q1', Q2', f) member harden(haction(coopen, n), Q)) \/
]%   

library CoCASL/Examples

%display  __union__          %LATEX __\cup__
%display  __setMinus__       %LATEX __\setminus__
%display  __disjointUnion__  %LATEX __\cup__
%display  __member__         %LATEX __\epsilon__
%display  __inCap__          %LATEX __in__

%left_assoc __||__, __+__, __-__

logic CoCASL

spec Set[sort Elem] =
free {
    type Set[Elem] ::= {} | {__}(Elem) | __union__(Set[Elem]; Set[Elem])
    op __union__ : Set[Elem] * Set[Elem] -> Set[Elem], 
                assoc, comm, idem, unit {} }
    then
    pred __member__: Elem * Set[Elem]
    forall x,y: Elem; M,N: Set[Elem]
    . not x member {}                                
    . x member {y} <=> x=y 
    . x member M union N <=> x member M \/ x member N
    then
    op __setMinus__, __disjointUnion__ : Set[Elem] * Set[Elem] -> Set[Elem]
    ops __-__,__+__ : Set[Elem] * Elem -> Set[Elem]
end

spec ACDomain[sort Name] = Set[sort Name] then
cofree {
    sort State
    free type Cap ::= inCap | out | open         
    free type HCap ::= enter | coenter | exit | coopen
    free type Action ::= tau | action(Cap; name :? Name)
    free type HAct ::= haction(HCap; name : Name)
    free type Concretion ::= conc(State; State)
    then Set[sort State] and Set[sort Concretion]
    then cotype State ::= (next : Action -> Set[State];
                           harden : HAct -> Set[Concretion]; 
                           names : Set[Name]) }
end

spec Rename = ACDomain[sort Name] 
then op subst : Name * Name * Name -> Name;
        subst : Name * Name * Action -> Action;
        subst : Name * Name * HAct -> HAct;
        rename : Name * Name * State -> State;
        rename : Name * Name * Set[State] -> Set[State];
        rename : Name * Name * Concretion -> Concretion;
        rename : Name * Name * Set[Concretion] -> Set[Concretion]
     vars a : Action; b : HAct; c : Cap; h : HCap; m,n,o : Name; P,Q: State;
          C : Concretion; s1,s2 : Set[State]; cs1,cs2 : Set[Concretion]
     . subst(m,n,o) = n when m=o else o
     . subst(m,n,tau) = tau
     . subst(m,n,action(c,o)) = action(c,subst(m,n,o))
     . subst(m,n,haction(h,o)) = haction(h,subst(m,n,o))
     . next(a, rename(m,n,P)) = rename(m,n,next(subst(m,n,a),P))
     . harden(b, rename(m,n,P)) = rename(m,n,harden(subst(m,n,b),P))
     . names(rename(m,n,P)) = (names(P) - m) + n
     . rename(m,n,{}:Set[State]) = {}
     . rename(m,n,{P}) = {rename(m,n,P)}
     . rename(m,n,s1 union s2) = 
       rename(m,n,s1) union rename(m,n,s2)
     . rename(m,n,conc(P,Q)) = conc(rename(m,n,P),rename(m,n,Q))
     . rename(m,n,{}:Set[Concretion]) = {}
     . rename(m,n,{C}) = {rename(m,n,C)}
     . rename(m,n,cs1 union cs2) = 
       rename(m,n,cs1) union rename(m,n,cs2)
end

spec Zero = ACDomain[sort Name]
then op zero : State
     vars a : Action; b : HAct
         . next(a, zero) = {}
         . harden(b, zero) = {}
         . names(zero) = {}
end

spec CapabilityPrefixing = Zero
then op cap : Cap * Name * State -> State
     vars a : Action; b : HAct; c : Cap; n : Name; P: State
     . next(a, cap(c, n, P)) = { P } when a = action(c, n) else {}
     . harden(b, cap(c, n, P)) = {}
     . names(cap(c, n, P)) = { n } union names(P)
end

spec NameRestriction = ACDomain[sort Name] and Rename
then op res : Name * State -> State
     vars a : Action; b : HAct; n : Name; P, Q : State; c : Concretion 
     . Q member next(a, res(n, P)) <=> 
        exists R : State . Q = res(n, R) /\ R member next(a, P) /\ not name(a)=n
     . c member harden(b, res(n, P)) <=>
        (exists R, S : State
         . c = conc(R, res(n, S))
           /\ conc(R, S) member harden(b, P) 
           /\ not n member names(R)) \/
        (exists R, S : State
         . c = conc(res(n, R), S) 
           /\ conc(R, S) member harden(b, P) 
           /\ not n member names(S)) \/
        (exists R, S : State; m : Name
         . c = conc(rename(n,m,R), rename(n,m,S)) 
           /\ conc(R, S) member harden(b, P) 
           /\ not m member names(P)
           /\ n member names(S)
           /\ n member names(R))
      . names(res(n, P)) = names(P) - n
end

spec AmbientAndParallel = Zero
then ops amb : Name * State -> State;
         __||__ : State * State -> State, assoc  %implied
vars a : Action; b : HAct; cap : Cap;m, n : Name; P,Q : State; c : Concretion
  . Q member next(tau, amb(n, P)) <=>
     ( exists P', P'' : State  .
                 Q = amb(n, P'') || P' /\
                 conc(P', P'') member  harden(haction(exit, n), P)) \/
     ( exists P' : State  . Q = amb(n, P') /\ P' member next(tau, P))
  . next(action(cap, n), amb(m, P)) = {}
  . c member harden(haction(enter, n), amb(m, P)) <=>
     ( exists P' : State  . c = conc(amb(m, P'), zero) /\
                          P' member next(action(inCap, n), P))
  . harden(haction(coenter, n), (amb(n, P))) = {conc(P, zero)}
  . c member harden(haction(exit, n), amb(m, P)) <=>
     ( exists P' : State  . c = conc(amb(m, P'), zero) /\
                        P' member next(action(out, n), P))
  . harden(haction(coopen, n), (amb(n, P))) = {conc(P, zero)}
  . names(amb(n, P)) = {n} union names(P)

vars a : Action; b : HAct; n : Name; P, Q, R : State; c : Concretion
    . R member next(a, P || Q) <=>
      (a = tau /\ exists P',Q',Q'' : State  .
        R = P' || Q' || Q'' /\ P' member next(action(open, n), P) /\
        conc(Q',Q'') member harden(haction(coopen, n),Q)) \/
      (a = tau /\  exists Q', P', P'' : State  .
        R = P' || P'' || Q' /\ Q' member next(action(open, n),Q) /\
        conc(P', P'') member harden(haction(coopen, n), P)) \/
      (a = tau /\  exists P', P'',Q',Q'' : State  .
        R = amb(n, P' || Q') || P'' || Q'' /\
        conc(P', P'') member harden(haction(enter, n), P) /\
        conc(Q',Q'') member harden(haction(coenter, n),Q)) \/
      (a = tau /\  exists P', P'',Q',Q'' : State  .
         R = amb(n, P' || Q') || P'' || Q'' /\
         conc(P', P'') member harden(haction(coenter, n), P) /\
         conc(Q',Q'') member harden(haction(enter, n),Q)) \/
      ( exists P' : State  . R = P' || Q /\ P' member next(a, P)) \/
      ( exists Q' : State  . R = P || Q' /\ Q' member next(a,Q))
    . c member harden(b, (P || Q)) <=>
        ( exists P', P'' : State  . 
           c = conc(P', P'' || Q) /\ conc(P', P'') member  harden(b, P)) \/
        ( exists Q',Q'' : State  . 
           c = conc(Q', P || Q'') /\ conc(Q',Q'') member harden(b,Q))
    . names(P || Q) = names(P) union names(Q)
end

spec AmbientCalculus =
     CapabilityPrefixing and NameRestriction and AmbientAndParallel
end
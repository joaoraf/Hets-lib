library CoCASL/Examples

%display  __union__        %LATEX __\cup__

logic CoCASL

spec Set[sort Elem] =

free {
    type Set[Elem] ::= {} | {__}(Elem) | __union__(Set[Elem]; Set[Elem])
    op __union__ : Set[Elem] * Set[Elem] -> Set[Elem], 
                assoc, comm, idem, unit {} }

spec FinalLTS =
    sort Label 
    then cofree {
        sort State
        then free {
            type Set ::= {} | {__}(State) | __union__(Set; Set);
            op __union__ : Set * Set -> Set, 
                        assoc, comm, idem, unit {} }
        then cotype State ::= (next : Label -> Set) }
end   

spec ExtendedFinalLTS[sorts Action, HAction, Name] =
cofree {
    sort State
    sort Cap          
    free type CapNameState ::= CapNameState(Cap; Name; State) | 
                               NameState(Name; State)
    free type StatePair ::= StatePair(CapNameState; State)
    then Set[sort State] and Set[sort StatePair] and Set[sort Name]
    then cotype State ::= (next : Action -> Set[State];
                           harden : HAction -> Set[StatePair]; 
                           freenames : Set[Name]) }
end

spec Zero[sorts Action, HAction, Name]
        = ExtendedFinalLTS[sorts Action, HAction, Name]
then op zero : State
     vars a : Action; b : HAction
         . next(a, zero) = {}
         . harden(b, zero) = {}
         . freenames(zero) = {}
end

spec CapabilityPrefixing[sorts Action, HAction, Name]
      = Zero[sorts Action, HAction, Name]
then op cap : Cap * Name * State -> State
     vars a : Action; b : HAction; c : Cap; n : Name; p: State
     . next(a, cap(c, n, p)) = { p } if a = a
     . harden(b, cap(c, n, p)) = { StatePair(CapNameState(c, n, p), zero) }
     . freenames(cap(c, n, p)) = { n } union freenames(p)
end

%% spec NameRestriction[sorts Action, HAction, Name] = 




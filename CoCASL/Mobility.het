library CoCASL/Examples

%display  __union__          %LATEX __\cup__
%display  __setMinus__       %LATEX __\setminus__
%display  __disjointUnion__  %LATEX __\cup__
%display  __member__         %LATEX __\epsilon__
%display  __inCap__          %LATEX __in__

%left_assoc __||__

logic CoCASL

spec Set[sort Elem] =

free {
    type Set[Elem] ::= {} | {__}(Elem) | __union__(Set[Elem]; Set[Elem])
    op __union__ : Set[Elem] * Set[Elem] -> Set[Elem], 
                assoc, comm, idem, unit {} }
    then
    pred __member__: Elem * Set[Elem]
    forall x,y: Elem; M,N: Set[Elem]
    . not x member {}                                
    . x member {y} <=> x=y 
    . x member M union N <=> x member M \/ x member N
    then
    op __setMinus__, __disjointUnion__ : Set[Elem] * Set[Elem] -> Set[Elem]
    op __-__ : Set[Elem] * Elem -> Set[Elem]
    
spec FinalLTS =
    sort Label 
    then cofree {
        sort State
        then free {
            type Set ::= {} | {__}(State) | __union__(Set; Set);
            op __union__ : Set * Set -> Set, 
                        assoc, comm, idem, unit {} }
        then cotype State ::= (next : Label -> Set) }
end   

spec ACDomain[sort Name] = Set[sort Name] then
cofree {
    sort State
    free type Cap ::= inCap | out | open         
    free type HCap ::= sort Cap | enter | coenter | exit | coopen
    free type Action ::= tau | action(Cap; Name)
    free type HAction ::= phi | haction(HCap; Name)
    free type Prime ::= prefix(Cap; Name; State) | ambient(Name; State)
    free type Concretion ::= conc(Prime; State; Set[Name])
    then Set[sort State] and Set[sort Concretion]
    then cotype State ::= (next : Action -> Set[State];
                           harden : HAction -> Set[Concretion]; 
                           freenames : Set[Name]) }
   then %def
   op freenames: Prime -> Set[Name]
   vars c : Cap; p : State; n : Name
   . freenames(prefix(c, n, p)) = freenames(p)
   . freenames(ambient(n, p)) = freenames(p)
end

spec Zero = ACDomain[sort Name]
then op zero : State
     vars a : Action; b : HAction
         . next(a, zero) = {}
         . harden(b, zero) = {}
         . freenames(zero) = {}
end

spec CapabilityPrefixing = Zero
then op cap : Cap * Name * State -> State
     vars a : Action; b : HAction; c : Cap; n : Name; p: State
     . next(a, cap(c, n, p)) = { p } when a = action(c, n) else {}
     . harden(b, cap(c, n, p)) = { conc(prefix(c, n, p), zero, {}) } 
                        when b = phi else {}
     . freenames(cap(c, n, p)) = { n } union freenames(p)
end

spec NameRestriction = ACDomain[sort Name]
then op res : Name * State -> State
     vars a : Action; b : HAction; n : Name; p, q : State; c : Concretion 
     . q member next(a, res(n, p)) <=> 
        exists r : State . q = res(n, r) /\ r member next(a, p)
     . c member harden(b, res(n, p)) <=>
        (exists r : Prime; s : State; f : Set[Name] 
         . c = conc(r, res(n, s), f - n) 
           /\ conc(r, s, f) member harden(b, p) 
           /\ not n member freenames(r)) \/
        (exists r, s : State; f: Set[Name]; m : Name 
         . c = conc(ambient(m, res(n, r)), s, f - n) 
           /\ conc(ambient(m, r), s, f) member harden(b, p) 
           /\ not n member freenames(r)) \/
        (exists r : Prime; s : State; f : Set[Name] 
         . c = conc(r, s, f - n) 
           /\ conc(r, s, f) member harden(b, p) 
           /\ not n member freenames(s)
           /\ not n member freenames(r))

spec ParallelComposition = ACDomain[sort Name]
then op __||__ : State * State -> State, assoc
    vars a : Action; b : HAction; n : Name; p, q, r : State
    . r member next(a, p || q) <=>
       (exists p',q2' : State; q1' : Prime; f : Set[Name]
        . r = p' || q2' 
          /\ p' member next(action(open, n), p)
          /\ conc(q1', q2', f) member harden(haction(coopen, n), q)) 
%[ \/
        (exists p2',q2' : State; p1', q1' : Prime; f1, f2 : Set[Name]
        . r = p' || q2' 
          /\ p' member next(action(open, n), p)
          /\ conc(q1', q2', f) member harden(haction(coopen, n), q)) \/
]%   

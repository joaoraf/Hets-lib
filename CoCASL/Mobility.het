library CoCASL/Examples

%display  __union__          %LATEX __\cup__
%display  __setMinus__       %LATEX __\setminus__
%display  __disjointUnion__  %LATEX __\cup__
%display  __member__         %LATEX __\epsilon__
%display  __inCap__          %LATEX __in__

logic CoCASL

spec Set[sort Elem] =

free {
    type Set[Elem] ::= {} | {__}(Elem) | __union__(Set[Elem]; Set[Elem])
    op __union__ : Set[Elem] * Set[Elem] -> Set[Elem], 
                assoc, comm, idem, unit {} }
    then
    pred __member__: Elem * Set[Elem]
    forall x,y: Elem; M,N: Set[Elem]
    . not x member {}                                
    . x member {y} <=> x=y 
    . x member M union N <=> x member M \/ x member N
    then
    op __setMinus__, __disjointUnion__ : Set[Elem] * Set[Elem] -> Set[Elem]
    
spec FinalLTS =
    sort Label 
    then cofree {
        sort State
        then free {
            type Set ::= {} | {__}(State) | __union__(Set; Set);
            op __union__ : Set * Set -> Set, 
                        assoc, comm, idem, unit {} }
        then cotype State ::= (next : Label -> Set) }
end   

spec ACDomain[sort Name] =
cofree {
    sort State
    free type Cap ::= inCap | out | open         
    free type HCap ::= sort Cap | enter | coenter | exit | coopen
    free type Action ::= tau | action(Cap; Name)
    free type HAction ::= phi | haction(HCap; Name)
    free type Prime ::= prefix(Cap; Name; State) | ambient(Name; State)
    free type Concretion ::= conc(prime : Prime; residue : State)
    then Set[sort State] and Set[sort Name] and Set[sort Concretion]
    then cotype State ::= (next : Action -> Set[State];
                           harden : HAction -> Set[Concretion]; 
                           freenames : Set[Name]) }
end

spec Zero[sorts Name] = ACDomain[sort Name]
then op zero : State
     vars a : Action; b : HAction
         . next(a, zero) = {}
         . harden(b, zero) = {}
         . freenames(zero) = {}
end

spec CapabilityPrefixing[sorts Name] = Zero[sorts Name]
then op cap : Cap * Name * State -> State
     vars a : Action; b : HAction; c : Cap; n : Name; p: State
     . next(a, cap(c, n, p)) = { p } when a = action(c, n) else {}
     . harden(b, cap(c, n, p)) = { conc(prefix(c, n, p), zero) } 
                        when b = phi else {}
     . freenames(cap(c, n, p)) = { n } union freenames(p)
end

spec NameRestriction[sorts Name] = ACDomain[sort Name]
then op res : Name * State -> State
     vars a : Action; b : HAction; n : Name; p, q : State; c : Concretion 
     . q member next(a, res(n, p)) <=> 
        exists r : State . q = res(n, r) /\ r member next(a, p)
%[     . c member harden(b, res(n, p)) <=>
        (exists r : Prime; s : State . c = conc(r, res(n, s)) /\ 
                        conc(r, s) member harden(b, p) /\ 
                        not n member freenames(r)) \/
        (exists r, s : State; m : Name . c = conc(ambient(m, res(n, r)), s) /\ 
                        conc(ambient(m, r), s) member harden(b, p) /\ 
                        not n member freenames(r))
]%


%% Examples for the first diagram:

%% declaration of a new sort

spec SP1 = 
 sort s
end

spec SP2 = 
  SP1 
 then 
  sort t
end

%% declaration of a new subsort

spec SP3 = 
  SP1 
 then
  sort u < s
end

%% subsort definition

spec Nat = 
 free type Nat ::= 0 | suc(Nat)
end

spec Nat_Comp = 
 Nat then 
 free {
  pred __<__ : Nat * Nat
  forall x,y : Nat
    . 0 < suc(x)
    . x < y => suc(x) < suc(y)
 }

spec Pos = 
 Nat then
 sort Pos = {p:Nat . not p = 0}
end

%% definition of a E-subsort

spec Pos_Esort = 
 Nat then
 esort Pos = {p:Nat . not p = 0}
end

%% freely generated with no term of that sort

spec Nat_NotCons = 
 free type Nat ::= suc(Nat)

%% freely generated E-type

spec Nat_Etype = 
 free etype Nat ::= suc(Nat)

%% Examples for the second diagram:

%% new subsort with overloaded constructors

spec Pos_Overload = 
  Nat 
 then
  sort Pos = {p:Nat . not p = 0 }
  op suc : Nat -> Pos

%% definition of addition

spec Nat_Add = 
 Nat then
 op __+__ : Nat * Nat -> Nat
 forall x,y : Nat 
  . x + 0 = x
  . x + suc(y) = suc(x + y)

%% leading term consists of not only vars and constructors

spec Nat_Multi = 
 Nat_Add
then
 op __*__ : Nat * Nat -> Nat
 forall r,s,t : Nat
 . (r + s) * t = (r * t) + (s * t)
 . t * (r + s) = (t * r) + (t * s)
end

%% PartialFunctionNoDomainTerminatingSufComplete

spec Nat_Pred = 
  Nat then
  op pre : Nat -> ?Nat
  forall x : Nat 
   . not def(pre(0))
   . pre(suc(x)) = x 
end

spec Nat_Diff = 
  Nat_Pred and Nat_Comp then 
  op __-__ : Nat * Nat -> ?Nat
  forall x, y : Nat 
   . def(x - y) <=> (y < x \/ y = x)
   . def(x - 0) => x - 0 = x
   . def(x- suc(y)) => x - suc(y) = pre(x -y)
end

spec Nat_F = 
 Nat then 
 op __f__ : Nat * Nat -> ?Nat
 forall x, y : Nat 
   . def(x f y) <=> not y = 0
   . x f y = x
end 

spec Nat_Leq = 
 Nat_Comp then
 pred __<=__ : Nat * Nat
 forall x,y : Nat 
  . x <= y <=> (x < y \/ x = y)
end

spec Nat_Overlap = 
 Nat_Add then 
 op f : Nat -> Nat 
 forall x : Nat 
  . f(x) = x + x
  . f(x) = suc(x)
end

spec Nat_Overlap_OK = 
 Nat_Leq then
 op f : Nat -> Nat
 forall x : Nat
  . x <= suc(suc(0)) => f(x) = x
  . not (x < suc(suc(suc(0)))) => f(x) = suc(x)
end

spec Nat_Incomplete_Domain = 
 Nat_Leq then 
 op f : Nat -> Nat 
 forall x : Nat
  . x <= suc(suc(0)) => f(x) = x
  . not (x < suc(suc(suc(0)))) /\ x <= suc(suc(suc(suc(suc(suc(0)))))) 
   => f(x) = suc(x)
end 

spec Nat_MultiOverlap = 
 Nat then 
 op f : Nat * Nat -> Nat 
 forall x, y : Nat
  . f(x, suc(y)) = 0
  . f(suc(x), y) = suc(0)
  . f(suc(suc(x)), 0) = x
end

spec Nat_Triple_Function = Nat
then
op f : Nat * Nat * Nat -> Nat
forall x,y,z : Nat
. f(x, suc(y), 0) = 0
. f(suc(x), suc(y), suc(z)) = suc(0)
end

%% overlapping on undefined values

spec Nat_Overlap_Partial = 
 Nat then
 op f : Nat * Nat -> ?Nat
 forall x, y : Nat
  . not def(f(0,x))
  . f(x, 0) = 0
  . f(x, suc(y)) = x 
end

%% incomplete and overlapping

spec Nat_Incomplete = 
 Nat then
 op f : Nat * Nat -> Nat
 forall x, y : Nat
 . f(x, suc(y)) = x
 . f(suc(x), y) = suc(y)
end

%% not left-linear

spec Nat_Non_Left_Linear = 
 Nat then
 op __+__ : Nat * Nat -> Nat
 forall m : Nat 
  . 0 + m = m
  . suc(m) + m = suc(m + m)
end

%% examples for each branch of the diagram

 spec NotConfluent = 
   sort s 
   ops a, b : s
   then 
   op f : s -> s
   forall x : s 
    . f(x) = a 
    . f(x) = b
 end

 spec NotConfluent2 = 
  free type s ::= a | b
  then 
  op f : s -> s
  forall x :s
   . f(x) = a
   . f(x) = b
 end

 spec PartialNoDomainNonTerminating = 
   Nat then
   op f : Nat -> ?Nat
   forall n : Nat 
    . f(n) = f(n)
 end

 spec PartialNoDomainTerminatingNotSC = 
  Nat then
  op f : Nat -> ?Nat
  . f(0) = 0
  . f(suc(0)) = 0
 end

 spec PartialDomainProofSC = 
  Nat then
   op f : Nat -> ?Nat
   var n : Nat
   . def(f(n)) <=> n = 0
   . f(0) = 0
   . f(suc(n)) = f(suc(suc(n)))
 end
 
 spec PartialDomainProofNotSC = 
  Nat then
   op f : Nat -> ?Nat
   var n : Nat
   . def(f(n)) <=> n = 0
   . f(0) = 0
 end

%% for this case we can't decide syntactically
%% and we have an example for each possibility
%% since we require f to be totally defined
%% they also provide examples for the case
%% when the function is total but not terminating

 spec PartialDomainNoProofCons = 
   Nat then
   op f : Nat -> ?Nat
   var n : Nat
   . def(f(n)) <=> true
   . f(0) = 0
   . f(suc(n)) = f(suc(suc(n)))
  end

 spec PartialDomainNoProofNotCons = 
  Nat then
  op f : Nat -> ?Nat
  var n : Nat
  . def(f(n)) <=> true
  . f(0) = 0
  . f(suc(n)) = suc(f(suc(n)))  
 end

%% total functions

 spec TotalTermNotSC =
   Nat then
   op f : Nat -> Nat 
   . f(0) = 0
  end

 spec TotalTermSC = 
  Nat then 
  op f : Nat -> Nat
  var n : Nat
  . f(n) = n

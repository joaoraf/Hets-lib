library HasCASL/AffineRealGeometry
version 0.1

%author: E. Schulz
%date: 04-09-2008

logic HasCASL

from Basic/Numbers get
     Nat, Int

from HasCASL/Iteration get
     Sequence, Sum

from HasCASL/Reals get
     Reals

from HasCASL/Algebra get
     WithInverse, AbelianGroup

from HasCASL/LinearAlgebra get
     VectorSpace


spec Basics = Sequence and Reals then
     types Mat := \a:Type. Nat*Nat -> a; %% Matrices
	   RMat := Mat Real;  %% Real Matrices (we'll use only them)
	   RSeq := Seq Real; %% The supertype of all finite real vector spaces

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Real Vector Spaces                         %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

spec RealVectorSpace = 
     VectorSpace[Reals fit Field |-> Real]
and WithInverse[AbelianGroup] with
    Elem |-> Space, __ * __ |-> __ + __, e |-> 0
end

spec RN_aux [op dimension:Nat] given Nat = Basics
then
     type VecRN = {X: RSeq. forall x:Nat. X(0) = 0 /\ x > dimension => X(x) = 0}
then %def	  
     ops __ + __:VecRN*VecRN->VecRN;
	 __ + __(x,y:VecRN):VecRN = \i:Nat.! x(i) + y(i);  %(vector_add)%
	 __ * __(s:Real; x:VecRN):VecRN = \i:Nat.! s*x(i); %(scalar_mult)%
	 0:VecRN = const(0:Real);

end

spec RN[op dimension:Nat] given Nat =
     Sum[RN_aux[op dimension:Nat] fit Elem |-> Real]
%[then
     op __ * __: VecRN*VecRN->Real
%%     ops __ * __(x,y:VecRN):Real = sum(1,dimension,\i:Nat. x(i) * y(i))
	  
     . forall x,y:VecRN. x*y = sum(1,dimension,(\i:Nat. x(i) * y(i)):Seq Real)
     
]%
end

spec R2 = RN[op 2:Nat fit dimension |-> 2]
then
     op v2(x,y:Real):VecRN = [1->x][2->y]0

end

spec R3 = RN[op 3:Nat fit dimension |-> 3]
then
     op v3(x,y,z:Real):VecRN = [1->x][2->y][3->z]0

end

spec R4 = RN[op 4:Nat fit dimension |-> 4]
then
     op v4(x,y,z,t:Real):VecRN = [1->x][2->y][3->z][4->t]0

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Affine Point Spaces                        %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

spec AffineSpace[RealVectorSpace] = 
     sort Point = Space
     ops  0:Point;
	  __+__ : Point * Space -> Point;
	  vec : Point * Point -> Space;


     forall p:Point; v:Space
     . vec(0,p) = p            %(point_to_space_embedding)%
     . (0 + v):Point = v       %(space_to_point__embedding)%

then
     forall p,q,r:Point ; v,w: Space
     . vec(p,q) + vec(q,r) = vec(p,r) %(transitivity_of_vec_+)%
     . vec(p,q) = - vec(q,p)          %(antisymmetry_of_vec)%

end

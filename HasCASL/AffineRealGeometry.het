library HasCASL/AffineRealGeometry
version 0.1

%author: E. Schulz
%date: 04-09-2008

logic HasCASL

from Basic/Numbers get
     Nat, Int

from HasCASL/Iteration get
     Sequence, Sum

from HasCASL/Reals get
     Reals

from HasCASL/Algebra get
     ExtInverse, AbelianGroup

from HasCASL/LinearAlgebra get VectorSpace


spec Basics = Sequence and Reals then
     types Mat := \a:Type. Nat*Nat -> a; %% Matrices
	   RMat := Mat Real;  %% Real Matrices (we'll use only them)
	   RSeq := Seq Real; %% The supertype of all finite real vector spaces

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Real Vector Spaces                         %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

spec RealVectorSpace = 
     VectorSpace[Reals fit Elem |-> Real]
and ExtInverse[AbelianGroup] with
    Elem |-> Space, __ * __ |-> __ + __, e |-> 0
end

spec RN_aux [op dimension:Nat] given Nat = Basics
then
     type VecRN =
	  {X: RSeq. forall x:Nat. X(0) = 0 /\ x > dimension => X(x) = 0}
then %def	  
     ops __ + __(x,y:VecRN):VecRN = \i:Nat.! x(i) + y(i);  %(vector_add)%
	 __ * __(s:Real; x:VecRN):VecRN = \i:Nat.! s*x(i); %(scalar_mult)%
	 0:VecRN = const(0:Real);
end

spec RN[op dimension:Nat] given Nat =
     Sum[RN_aux[op dimension:Nat] fit Elem |-> Real]
then
     ops __ * __(x,y:RSeq):Real = sum(1,dimension,\i:Nat.! x(i) * y(i));
	 %(scalar_product)%
	 constvec(x:Real):VecRN =
	      \i:Nat.! (x when i>0 /\ i<=dimension else 0);
	 %(constant_vector)%
	 kronecker(n:Nat):RSeq = \i:Nat.! (1 when i=n else 0);
	 %(kronecker_delta)%

then %implies
     forall n,m:Nat
     . not(m=n) => kronecker(m) * kronecker(n) = 0 %(kdeltas_orthogonal)%
end

spec R2 = RN[op 2:Nat fit dimension |-> 2]
then
     op v2(x,y:Real):VecRN = [1->x][2->y]0

end

spec R3 = RN[op 3:Nat fit dimension |-> 3]
then
     op v3(x,y,z:Real):VecRN = [1->x][2->y][3->z]0

end

spec R4 = RN[op 4:Nat fit dimension |-> 4]
then
     op v4(x,y,z,t:Real):VecRN = [1->x][2->y][3->z][4->t]0

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Affine Point Spaces                        %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

spec AffineSpace[VectorSpace] =
     sort Point
     ops __+__ : Point * Space -> Point;
	 origin: Point = asPoint(0);
	 asPoint  : Space -> Point;
	 asVector : Point -> Space;
	 vec(p,q:Point):Space = asVector(q) - asVector(p); %(vec_def)%


     vars p,q:Point; v,w:Space
     . asVector(asPoint(v)) = v %(vector_point_vector)%
     . asPoint(asVector(p)) = p %(point_vector_point)%
     . asPoint(origin) = 0  %(origin_to_zero)%
     . asVector(p + v) = asVector(p) + v     %(compatibility_PVplus_Vplus)%

then %implies
     vars p,q,r:Point; v,w:Space
     . vec(p,q) + vec(q,r) = vec(p,r) %(transitivity_of_vec_+)%
     . vec(p,q) = - vec(q,p)          %(antisymmetry_of_vec)%
     . p + v = q => v = vec(p,q) %(vec_shift_unique_lemma)%
     . p + vec(p,q) = q  %(vec_shift_def_lemma)%
     . (p + v) + w = (p + w) + v %(point_vector_add_comm_lemma)%

end

spec AffineSpace[RealVectorSpace] = 
     sort Point = Space
     ops  0:Point;
	  __+__ : Point * Space -> Point;
	  vec : Point * Point -> Space;


     forall p:Point; v:Space
     . vec(0,p) = p            %(point_to_space_embedding)%
     . (0 + v):Point = v       %(space_to_point__embedding)%

then
     forall p,q,r:Point ; v,w: Space
     . vec(p,q) + vec(q,r) = vec(p,r) %(transitivity_of_vec_+)%
     . vec(p,q) = - vec(q,p)          %(antisymmetry_of_vec)%

end

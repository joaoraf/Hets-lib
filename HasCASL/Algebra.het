library HasCASL/Algebra
version 0.1

%author: E. Schulz
%date: 17-09-2008

logic HasCASL

spec Commutative =
     sort Elem
     op  __ * __: Elem * Elem -> Elem, comm
end

spec Semigroup =
     sort Elem
     op  __ * __: Elem * Elem -> Elem, assoc
end

spec Monoid = Semigroup
then
     ops  e:Elem;
	  __ * __: Elem * Elem -> Elem, unit e
end

spec WithInverse[Monoid] = 
  ops inv:Elem->Elem;
      __ / __:Elem*Elem->Elem;

  forall x,y:Elem
  . inv(x) * x = e     %(unary_inverse)%
  .  x / y = x * inv(y) %(binary_inverse)%
end

spec Group =
     Monoid
then
     forall x: Elem
     . exists x': Elem . x' * x = e   %(inv_Group)%
then %implies
     forall x,y,z: Elem
     . exists x': Elem . x * x' = e   %(rinv_Group)%
     . y * x = e /\ z * x = e => y = z %(unique_linv_Group)%
     . x * y = e /\ x * z = e => y = z %(unique_rinv_Group)%
     . x * y = e /\ z * x = e => y = z %(linv_is_rinv_Group)%
end

spec AbelianGroup = Group and Commutative

spec Ring =
     AbelianGroup with ops __ * __ |-> __ + __,
                           e       |-> 0
and
     Monoid with op e |-> 1
then
     forall x,y,z:Elem
     . (x + y) * z = (x * z) + (y * z)          %(distr1_Ring)%
     . z * ( x + y ) = (z * x) + (z * y)        %(distr2_Ring)%
end

spec CommutativeRing = Ring and Commutative

spec IntegralDomain =
     CommutativeRing
then
     forall x,y: Elem 
     . ( x * y = 0 => ( x = 0 \/ y = 0 ) )      %(noZeroDiv)%
     . not (1 = 0)                              %(zeroNeqOne)%
end

spec NonZeros =
     sort Elem
     op  0:Elem
     type NonZero = {x:Elem. not (x=0)}
end

spec RingWithNonZeros = IntegralDomain and NonZeros
then 
     ops 1:NonZero;
	 __ * __:NonZero*NonZero->NonZero
end

spec Field = RingWithNonZeros and Group with Elem |-> NonZero, e |-> 1

spec ExtField =
WithInverse[Field fit __ * __ |-> __ + __, e |-> 0]
   with inv |-> -__, __ / __ |-> __ - __
and
WithInverse[Field fit Elem |-> NonZero, e |-> 1]
end

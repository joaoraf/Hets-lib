library HasCASL/Algebra
version 0.1

%author: E. Schulz
%date: 17-09-2008

logic HasCASL

spec SubtypeHandling = 
     %% For subtypes defined by a predicate ( ST = {x:T. P(x)} )
     %% there is a common pattern how to handle the type coercions.
     %% As this pattern is not yet implemented we introduce a
     %% convention how to handle subtype declarations and provide
     %% a polymorphic predicate to express the subtype relation explicitly.

     %% The pattern looks as follows:
     %% (1) define a predicate for a subtype, name it as the subtype but add
     %%     the suffix "_pred"
     %% (2) define the subtype by using the defined predicate, e.g.,
     %%     type the_subtype = {x:the_type. the_subtype_pred x}
     %% (3) define the injection for the subtype, name it as the subtype but
     %%     add the suffix "_inj", e.g.,
     %%     op the_subtype_inj:the_subtype -> the_type
     %% (4) define the projection for the subtype, name it as the subtype but
     %%     add the suffix "_proj", e.g.,
     %%     op the_subtype_proj:the_type -> the_subtype
     %%     REMARK: This shouldn't be used with empty types/subtypes !!
     %% (5) add an axiom using the predicate isSubtypeWithPred, name it as
     %%     the subtype but add the suffix "_subtype", e.g.,
     %%     . isSubtypeWithPred(the_subtype_pred, the_subtype_inj, the_subtype_proj)

     vars s,t:Type

     preds isSubtype(injection:s->t; projection:t->s)
	  <=> forall x:s. x = projection(injection(x));
	      %(subtype def)%
	  isSubtypeWithPred(P:Pred(t); injection:s->t; projection:t->s)
	  <=> isSubtype(injection, projection)
	      /\ (forall x:t. P x => x = injection(projection(x)))
	      /\ (forall x:s. P(injection(x)));
	      %(subtype pred def)%

     %% This workaround is mainly important for doing proofs in Isabelle
     %% and the naming convention should prevent you from being lost in
     %% a haystack of user-defined names.

end


spec Commutative =
     sort Elem
     op  __ * __: Elem * Elem -> Elem, comm

     %% workaround for Ticket #692
     forall x : Elem; y : Elem . x * y = y * x %(ga_comm___*__)%
end

spec Semigroup = SubtypeHandling then
     sort Elem
     op  __ * __: Elem * Elem -> Elem, assoc

     %% workaround for Ticket #692
     forall x : Elem; y : Elem; z : Elem . (x * y) * z = x * (y * z)
     %(ga_assoc___*__)%
end

spec Monoid = Semigroup
then
     ops  e:Elem;
	  __ * __: Elem * Elem -> Elem, unit e;

     %% workaround for Ticket #692
     forall x : Elem . x * e = x; %(ga_right_unit___*__)%
     forall x : Elem . e * x = x; %(ga_left_unit___*__)%
end

spec Group =
     Monoid
then
     op inv:Elem->Elem

     forall x: Elem
     . inv(x) * x = e   %(inv_Group)%
then %implies
     forall x: Elem
     . x * inv(x) = e   %(rinv_Group)%
end

spec ExtInverseSig = 
     sort Elem
     ops  __ * __: Elem * Elem -> Elem;
	  inv: Elem->Elem
end

%( Definitional extension of unary inv to binary inv (= /) )%
spec ExtInverse[ExtInverseSig] = %def
  op __ / __:Elem*Elem->Elem;

  forall x,y:Elem
  .  x / y = x * inv(y) %(binary_inverse)%
end

spec AbelianGroup = Group and Commutative

spec Ring =
     AbelianGroup with ops __ * __ |-> __ + __,
                           inv     |-> - __,
                           e       |-> 0

and
     Monoid with op e |-> 1
then
     forall x,y,z:Elem
     . (x + y) * z = (x * z) + (y * z)          %(distr1_Ring)%
     . z * ( x + y ) = (z * x) + (z * y)        %(distr2_Ring)%
end

spec CommutativeRing = Ring and Commutative

spec IntegralDomain =
     CommutativeRing
then
     forall x,y: Elem 
     . ( x * y = 0 => ( x = 0 \/ y = 0 ) )      %(noZeroDiv)%
     . not (1 = 0)                              %(zeroNeqOne)%
end

spec RingWithNonZeros = IntegralDomain
then 
     type NonZero = {x:Elem. not (x=0)}

     ops 1:NonZero;
	 __ * __:NonZero*NonZero->NonZero
end

spec Field = RingWithNonZeros and Group with Elem |-> NonZero, e |-> 1

spec RichField =
ExtInverse[Field fit __ * __ |-> __ + __,  inv |-> - __]
   with __ / __ |-> __ - __
then
     op __ / __(x:Elem;y:NonZero):Elem=x*inv(y);
end

library HasCASL/HLR

from HasCASL/Categories get Category, Pushout

logic HasCASL

spec POComplement[Category] = 
  Pushout[Category]
then
  pred  POComplement  : Mor * Mor * Ob
  forall o: Ob; f,h:Mor
  . POComplement (f,h,o) <=> 
    exists g,k : Mor . ((h,k) as POCocone) isCoconeFor ((f,g) as PODiagram)
    /\ dom k = o
end

spec Transformation[Category] =
  POComplement[Category]
then
  sort M < Mor
  type Rules = {(l,r): M * M
                      . dom l = dom r}

  ops transform: Rules * Mor ->? Ob;
  
  forall p : Rules; g1 : Mor
  . let (l,r) = p 
    in
    def transform(p,g1) <=>
        exists g2,g3,c1,c2 : Mor . POcomplement (l,g1,dom c1)
    /\ (forall o1,o2 : Ob . POcomplement (l,g1,o1) /\ POcomplement (l,g1,o2)
         => o1 = o2)
    /\ ((g1,c1) as POCocone) isCoconeFor ((l,g2) as PODiagram)
    /\ ((g3,c2) as POCocone) isCoconeFor ((r,g2) as PODiagram))
  
   . let (l,r) = p;
        ((g1,c1) as POCocone) isCoconeFor ((l,g2) as PODiagram)
    in
    def transform(p,g1) => transform(p,g1) = r objPushout g2
end


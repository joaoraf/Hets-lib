library HasCASL/LinearAlgebra
version 0.1

%author: E. Schulz
%date: 18-09-2008

logic HasCASL

from HasCASL/Reals get
     Reals, FieldWithValuation, RealFunctions,
     OrderedReals, OrderedReals_as_FieldWithValuation
from HasCASL/Algebra get
     ExtInverse, AbelianGroup, Field

spec AdditiveAbelianGroup_aux =
ExtInverse[AbelianGroup] with
  Elem |-> Space, __ * __ |-> __ + __, e |-> 0, __ / __ |-> __ - __, inv |-> -__
end

spec VectorSpace[Field] = AdditiveAbelianGroup_aux
then
     op  __ * __: Elem * Space -> Space

     vars s,r:Elem; x,y:Space

     . 1 * x = x                              %(unit)%
     . (r * s) * x = r * (s * x)              %(mix_assoc)%
     . (r + s) * x = (r * x) + (s * x)        %(distr_Field)%
     . r * (x + y) = (r * x) + (r * y)        %(distr_Space)%

then %implies
     vars x:Space; r:Elem
     . 0 * x = 0 %(zero by left zero)%
     . r * 0:Space = 0 %(zero by right zero)%

     . -1 * x = -x %(inverse by -1)%
end

%( Definitional extension: lindep-pred )%
spec ExtVectorSpace[VectorSpace[Field]] = %def
     preds lindep:Space*Space;

     var x,y:Space
     . lindep(x,y) <=> (y=0 \/ exists r:Elem. x = r*y) %(lindep_def)%


then %implies
     var x,y,z:Space; r:Elem
     %{ lindep props }%
     . lindep(x,x) %(lindep reflexivity)%
     . lindep(x,y) => lindep(y,x) %(lindep symmetry)%
     . x = r * y => lindep(x,y)  %(simple lindep condition)%
     . not(x=0) /\ lindep(x,y) /\ not(lindep(y,z)) => not(lindep(x,z))
       %(lindep nonlindep transitivity)%
end

spec NormedSpace[FieldWithValuation] =
VectorSpace[FieldWithValuation]
then
     op ||__|| : Space -> Real 
     forall a:Elem ; v,w: Space   
     . ||a * v|| = val(a) * ||v||	%(homogen)%
     . ||v + w|| <= ||v|| + ||w||      	%(triangle)%
     . ||v|| = 0 <=> v = 0  	 	%(definit)%
end

spec EuclideanVectorSpace = 
     VectorSpace[Reals fit Elem |-> Real]
then
     op __*__ : Space * Space -> Real   %% (bilinear form)

     forall a:Real ; v,v',w: Space
     . (v+v') * w = (v * w) + (v' * w)  %(distributiv)%
     . (a*v) * w = a * (v * w) 		%(homogen)%
     . v * w  = w * v   		%(commutativ)%
     . v * v = 0 =>  v = 0		%(pos_definit)%

then %implies
     forall a:Real ; v,v',w: Space
     . w * (v+v') = (w * v) + (w * v')  %(right_distributiv)%
     . v * (a*w) = a * (v * w) 		%(right_homogen)%
end

%( Definition of Norm and Projection )%
spec ExtEuclideanVectorSpace[EuclideanVectorSpace] given RealFunctions
= %def
ExtVectorSpace[EuclideanVectorSpace fit Elem |-> Real] then 
     ops  sqr(x:Space):RealNonNeg = x*x as RealNonNeg; %(sqr def)%
	  ||__|| (x:Space): Real = sqrt(sqr(x)); %(norm from inner prod def)%
	  proj(v,w:Space):Space
	       = 0 when w = 0 else ((v*w)/(w*w as NonZero)) * w; %(proj def)%
	  orthcomp(v,w:Space):Space = v - proj(v,w); %(orthcomp def)%
     pred orth(x,y:Space) <=> x*y=0 %(orthogonal def)%

then %implies
     vars x,y,z:Space; r:Real

     %{ orth props }%
     . orth(x,y) => orth(y,x) %(orth symmetry)%

     %{ mixed props }%
     . lindep(x,y) /\ orth(y,z) => orth(x,z) %(lindep orth transitivity)%

     . proj(x,y)=0 => orth(x,y)  %(orthogonal on zero projection)%

     . orth(orthcomp(x,y), y) %(orthogonal projection theorem)%

     . proj(x,y) + orthcomp(x,y) = x %(orthogonal decomposition theorem)%
end

view EuclideanSpaceIsNormedSpace:
     NormedSpace[view OrderedReals_as_FieldWithValuation]
     to ExtEuclideanVectorSpace[EuclideanVectorSpace]
end

library HasCASL/Morphisms

from Basic/Numbers get Nat

from HasCASL/Set get Set, Map, SumNatSet

from HasCASL/Petri get MultiSet 

from HasCASL/Categories get Category

from HasCASL/Graphs get DirectedGraph, GraphHomomorphism

logic HasCASL

spec GraphCategory =
  sorts N,E 
and 
  GraphHomomorphism
then
  types G := Graph N E;
        H := HomHom N E
end

view CategoryofGraphs : Category to GraphCategory =
     Ob |-> G, Mor |-> H, __o__, dom, cod, id
end


spec RichMultiSet = 
  MultiSet 
then
  var Elem : Type
 op   MultiSetToSet : MultiSet Elem -> Set Elem
 forall B:MultiSet Elem; S: Set Elem
     . let S = MultiSetToSet(B) in 
        forall x: Elem. x isIn S <=> freq(x,B) > 0
end


spec MapMultiSet=
  RichMultiSet and SumNatSet
then
  var Elem : Type
  type  MapMultiSet Elem := MultiSet Elem ->? MultiSet Elem
then %def
  var Elem, S, T : Type
  ops __ :: __ --> __ : Pred ( (S->? MultiSet T) * Set S * Set T);
      freeMap : Map Elem -> MapMultiSet Elem;
      linMap : (S->? MultiSet T) -> (MultiSet S->? MultiSet T)
  forall x1, x2, y: Elem; x3, x4: S; m:MultiSet Elem; s: Set S; t: Set T;  
         f: Map Elem; h: S->? MultiSet T
   . h :: s --> t <=> forall x:S . x isIn s => MultiSetToSet(h x) subset t
   . freeMap f m y = sum (image m (\x:Elem . y = f x))
   . linMap h {} = {}
   . linMap h ({x3}+{x4}) = h x3  + h x4 ; 


spec PetriNetCategory = 
  Set and Map 
then
  sorts P,T 
  type Net = {(p,pre,post) : Set P  *  (T ->? MultiSet P) * (T ->? MultiSet P)                        	. dom pre=dom post /\
                     	pre :: dom  pre --> p /\
                     	post :: dom post --> p }
  type HomNet = 
     {(n1,hp,ht,n2) : PetriNet  * (P->?P) * (T->?T) * PetriNet .
       hp :: places n1 --> places n2 /\ ht :: trans n1 --> trans n2 
       /\ forall t:T . t isIn trans n1 =>
          (   freeMap hp (preMap n1 t) = preMap n2 (ht t)
           /\ freeMap hp (postMap n1 t) = postMap n2 (ht t) ) } 
   ops places : Net  -> Set P;
       transitions : Net  -> Set T;
       preMap, postMap : Net  -> (T ->? Multiset P);
       dom : HomNet  -> Net;
       cod : HomNet  -> Net;
       placesMap : HomNet  -> (P->?P);
       transitionsMap : HomNet  -> (T->?T);
       id : Net ->? HomNet;
       __o__ : HomNet  * HomNet  ->? HomNet 
   forall n, n1,n2 : Net; p : Set P; pre, post : T ->? Multiset P; hp:P->?P; ht:T->?T; h, h1, h2:HomNet 
   . let n=(p,pre,post) in places n  p
   . let n=(p,pre,post) in transitions n = dom pre
   . let n=(p,pre,post) in preMap = pre
   . let n=(p,pre,post) in postMap = post
   . let h=(n1,hp,ht,n2) in dom (h) = n1
   . let h=(n1,hp,ht,n2)  in cod (h) = n2
   . let h=(n1,hp,ht,n2)  in placesMap (h) = hp
   . let h=(n1,hp,ht,n2)  in transitionsMap (h) = ht
   . def (h2 o h1) <=> cod h1 = dom h2
   . def (h2 o h1) => h2 o h1 = 
     (dom h1, placesMap h2 o placesMap h1, transitionsMap h2 o transitonsMap h1,cod h2)
      as HomNet
end


view CategoryofPetriNets : Category to PetriNetCategory =
     Ob |-> Net, Mor |-> HomNet, __o__, dom, cod, id
end

spec PetriSystemCategory = 
  PetriNet 
then
  type Marking := MultiSet P
  type System = {(n,m) : Net * Marking 
                          . let (p,pre1,post1) = n 
		          in forall x:P . x isIn m => x isIn p }
  type HomSys  = {(sys1,hp,ht,sys2) : System  * (P->?P) * (T->?T) * System .  
                  (net(sys1), hp, ht, net(sys2)) as HomNet 
       /\ forall p: P. freq(p, marking(sys1)) <= freq(hp p, marking(sys2))} 
  ops  marking   : System -> Marking;
       net       : System -> Net;
       empty     : Marking;
        __|<__>    : System * T -> System; 
        __|<__>    : System * MultiSet T ->? System;
       dom : HomSys  -> Net;
       cod : HomSys  -> Net;
       placesMap : HomSys  -> (P->?P);
       transitionsMap : HomSys  -> (T->?T);
       id : System ->? HomSys;
       __o__ : Hom  * HomSys  ->? HomSys 
  forall sys,sys1,sys2:System; n:Net; x:P; m:Marking; t:T; hp:P->?P; ht:T->?T; h, h1, h2:HomSys 
  . empty = {}
  . net sys = let (n,m) = sys in n
  . marking sys = let (n,m) = sys in m
  . def sys|<t> <=> t isIn dom preMap(net(sys)) /\  preMap(net(sys))  t <= marking(sys)
  . def sys|<t> => sys|<t> = (net(sys), marking(sys) -  preMap(net(sys)) t + postMap(net(sys)) t)
  . def sys|<v> <=> forall t:T . t isIn v /\ t isIn dom preMap(net(sys)) /\ linMap preMap(net(sys)) v <= marking(sys)
  . def sys|<v> => 
    sys|<v> = (net(sys), marking(sys) - linMap preMap(net(sys)) v + linMap postMap(net(sys)) v )
  . let h=(sys1,hp,ht,sys2) in dom (h) = sys1
  . let h=(sys1,hp,ht,sys2)  in cod (h) = sys2
  . let h=(sys1,hp,ht,sys2)  in placesMap (h) = hp
  . let h=(sys1,hp,ht,sys2)  in transitionsMap (h) = ht
  . def (h2 o h1) <=> cod h1 = dom h2
  . def (h2 o h1) => h2 o h1 = 
     (dom h1, placesMap h2 o placesMap h1, transitionsMap h2 o transitonsMap h1,cod h2)
      as HomSys
end

view CategoryofPetriSystems : Category to PetriSystemCategory =
     Ob |-> System, Mor |-> HomSys, __o__, dom, cod, id
end



\chapter{Haskell Implementation of mbody }
\label{cha:hask-impl-mbody}

We present here a complete Haskell implementation of the $\op{mbody}$ construct
described in Section \ref{sec:param-except}. As an example application the
pattern match algorithm that has been verified in Section
\ref{sec:corr-patt-match} and in \cite{WalterEA05} is used.
\begin{alltt}
module MBodyTrans
where

import Control.Monad.Error
import Control.Monad.State

data Exception a = Excpt String
                 | Ret a
                 | DropOff
                   deriving (Show)


-- Needed for class dependencies; actually only for fail 
-- which is not used in our calculus.
instance Error (Exception a) where
    noMsg = Excpt ""
    strMsg = Excpt
\end{alltt}
Rather than defining the binding in an exception monad by ourselves, we make use
of the \emph{exception monad transformer} \code{ErrorT} from the Haskell
libraries. The type of exceptions consists of three alternatives; exceptions
either signal failure through \code{Excpt} with a message attached, or they
carry a return value of some method, or they indicate that a method has
illegally terminated normally (\code{DropOff}).  For simplicity, \code{continue}
and \code{break} have been left out, but could easily be added.

For every monad $m$ we can construct a monad $(\op{Ex}\ m\ e)$ that behaves just
like $m$ in the absence of an exception, but also allows exceptions to be thrown
and caught. 
\begin{alltt}
type Ex m e a = ErrorT (Exception e) m a
\end{alltt}
Recall the instance definition of \code{ErrorT} from the Haskell libraries:
\begin{alltt}
instance (Monad m, Error e) => Monad (ErrorT e m) where
        return a = ErrorT $ return (Right a)
        m >>= k  = ErrorT $ do
                a <- runErrorT m
                case a of
                        Left  l -> return (Left l)
                        Right r -> runErrorT (k r)
        fail msg = ErrorT $ return (Left (strMsg msg))
\end{alltt}  % $ ugly highlighter!
which precisely captures the intended behaviour of the binding in the presence
of an exception, namely that the right-hand argument is only evaluated if the
left one terminated normally. The function \code{runErrorT} simply unpacks the
inner monad, \IE drops the constructor \code{ErrorT}.

The concrete state monad that will be used below needs a single reference of
type \code{Int}, but the general variable mapping can be defined as follows. A
variable map consists of an ID for the next reference and a function mapping
references to their values:
\begin{alltt}
type Ref = Int

type VMap a = (Int, Ref -> a)
\end{alltt}

Next comes the \code{mbody} construction that catches \code{Ret} exceptions and
converts them into normal return values. All other exceptions are propagated
unchanged.  This implementation is polymorphic in the exception type of the
result and thus allows for switching between monads.  Whether the input
computation should be polymorphic in its return type or whether $\unit$ should be
enforced is a matter of taste. \code{mret} emulates the actual Java
\code{return} statements -- whereas \code{return} is the usual monadic $\ret$
function. 
\label{page:mbody-def}
\begin{alltt}
mret :: Monad m=> e -> Ex m e a
mret x = throwError (Ret x)

mbody :: Monad m=> Ex m e () -> Ex m e1 e
mbody p = ErrorT $ do
          a <- runErrorT p      -- binding in the "inner" monad
          case a of
            Right () -> return (Left DropOff)
            Left e   -> case e of
              Ret x    -> return (Right x)
              Excpt s  -> return (Left (Excpt s))
              DropOff  -> return (Left DropOff)
\end{alltt}
% $ stupid highlighter!

There are three state-related operations on exception state monads: reading,
writing and creation of variables. A generic while loop for the exception
state monad is also easily defined.
\begin{alltt}
readVar :: Ref -> Ex (State (VMap a)) e a
readVar r = do (_, f) <- get
               return (f r)

wrtVar :: Ref -> a -> Ex (State (VMap a)) e ()
wrtVar r x = do (n, f) <- get
                put (n, \textbackslash{} k-> if k == r then x else f k)

newVar :: a -> Ex (State (VMap a)) e Ref
newVar v = do (n, f) <- get
              put (n+1, \textbackslash{} k-> if k == n then v else f k)
              return n

while :: Monad m=> Ex m e Bool -> Ex m e () -> Ex m e ()
while b p = do v <- b
               if v then do p; while b p
                    else return ()
\end{alltt}

The pattern match algorithm, as described in \cite{WalterEA05,HuismanJacobs00}.
For testing purposes, here's how to evaluate pmatch with an initial state with
all references defaulting to 0:\\[1.5ex]
\centerline{\texttt{evalState (runErrorT (pmatch base1 pat1)) (0, const 0)}}\\[1.5ex]
which will
evaluate (correctly) to \code{Right 9}
\begin{alltt}
pmatch :: String -> String -> Ex (State (VMap Int)) e Int
pmatch base pat = mbody $ do
    r <- newVar 0
    s <- newVar 0
    while (return True)
          (do u <- readVar r
              v <- readVar s
              if u == length pat
                then mret v
                else if v + u == length base 
                  then throwError (Excpt "Pattern not found")
                  else if base!!(v+u) == pat!!u
                    then wrtVar r (u+1)
                    else do wrtVar s (v+1); wrtVar r 0)

-- Some sample patterns
base1 :: String
base1 = "puff the magic dragon"

pat1 :: String
pat1 = "magic"

pat2 :: String
pat2 = "mary"
\end{alltt}
% $


\chapter{Table of  Rules of Isabelle/HOL}
\label{cha:freq-used-rules}

Since the main purpose of the implementation in Isabelle was to set up a new
logic, only few deep theorems of Isabelle/HOL itself, on which the logic is
based, have been made use of.  Further, many rules are applied implicitly
when employing the simplifier or the classical reasoner. The following is a list
of the rules that appear verbatim in the implementation.

\begin{table}[h]
  \centering \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{|l@{$\quad$}l|}\hline
    \irule{allI}        & $(\bigwedge x\bdot P\, x) \Longrightarrow \forall x\bdot P\, x$\\\hline
    \irule{arg\_cong}    & $x = y \Longrightarrow f\ x = f\ y$\\\hline
    \irule{cong}        & $\llbracket f = g;\; x = y\rrbracket \Longrightarrow f\ x = g\ y$\\\hline
    \irule{conjE}       & $\llbracket P\land Q;\; \llbracket P;\; Q\rrbracket \Longrightarrow R\rrbracket \Longrightarrow R$\\\hline
    \irule{conjI}       & $\llbracket P;\; Q\rrbracket \Longrightarrow P \land Q$ \\\hline
    \irule{conjunct1}   & $\llbracket P \land Q\rrbracket \Longrightarrow P$ \\\hline
    \irule{exE}         & $\llbracket\exists x\bdot P\ x;\; \bigwedge x\bdot P\ x \Longrightarrow Q\rrbracket \Longrightarrow Q$\\\hline
    \irule{FalseE}      & $\mathit{False} \Longrightarrow P$\\\hline
    \irule{iffD1}       & $\llbracket Q = P;\; Q\rrbracket \Longrightarrow P$\\\hline
    \irule{iffD2}       & $\llbracket P = Q;\; Q\rrbracket \Longrightarrow P$\\\hline
    \irule{iffI}        & $\llbracket P \Longrightarrow Q;\; Q \Longrightarrow P\rrbracket \Longrightarrow P = Q$\\\hline
    \irule{impI}        & $(P \Longrightarrow Q) \Longrightarrow P \longrightarrow Q$\\\hline
    \irule{mp}          & $\llbracket P \longrightarrow Q;\; P\rrbracket \Longrightarrow Q$\\\hline
    \irule{notE}        & $\llbracket\lnot P;\; P\rrbracket \Longrightarrow R$\\\hline
    \irule{notI}        & $(P \Longrightarrow \mathit{False}) \Longrightarrow \lnot P$\\\hline
    \irule{refl}        & $t = t$\\\hline
    \irule{spec}        & $\forall x.\ P\ x \Longrightarrow P\ y$ \\\hline
    \irule{subst}       & $\llbracket s = t;\; P\ s\rrbracket \Longrightarrow P\ t$\\\hline
  \end{tabular}
  \caption{Derived rules of inference for HOL}
  \label{tab:derived-rules}
\end{table}


\chapter{Isabelle Theories}
\label{cha:isabelle-theories}

The following sections present the concrete implementation of the calculus of
dynamic logic in Isabelle. The typesetting has been automatically taken care of
by the \verb|isatool| mechanism of the Isabelle distribution, which directly
extracts this information from the given theory files. This chapter is intended
for reference usage and not so much for being perused sequentially. Refer to
Chapter \ref{cha:implementation} for a conceptual description of the
implementation.

\input{session}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 

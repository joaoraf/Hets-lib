

\chapter{Introduction}
\label{cha:introduction}


\section{Motivation and Classification}
\label{sec:motiv-class}

The study of formal methods, \IE the mathematically rigorous specification,
design and analysis of software systems, has a long tradition in the -- by
itself relatively short -- history of computer science. It has, however, not
gained as much attention for being an effective and efficient means of software
design as for example object oriented software design or UML \cite{Fowler04}
\Eat{\footnote{Unified Modeling Language (see \url{www.uml.org})}} modelling
have. Quite the contrary, it is often considered a very complex and demanding
way of creating software, requiring specialised skills in mathematics of all
developers involved and taking a long time to finish. Its application is
therefore often rejected and regarded as too expensive. A similar situation can
be found in the field of software verification and validation, where the
predominant method of operation is to perform clever and extensive testing.

Despite these facts, we consider formal methods to be a very valuable arrow in a
computer scientist's quiver; the use of formal methods is the only known way to
actually prove the absence of errors in a system, whereas other methods, \EG
testing, can only show their presence. Experience has shown (see
\cite{KuhnChandramouliButler02,SobelClarkson02}) that there are applications in
which formal methods is a means of not only writing better software, but writing
it in proper time. Examples include the verification of AMD's floating point
processing unit of the K7 CPU, which Intel also did for their Pentium Pro CPU,
the verification of several cryptographic protocols, and the employment of
various model-checkers in hardware design. We consider essential two features
when using formal methods: firstly, it must be reasonably easy to understand and
use and, secondly, there has to be a software tool that assists the user and
relieves him of the duty of performing trivial but highly detailed proof steps.

Within the subject of formal methods, there are three major branches that are
concerned with giving meaning to programs and programming languages and in
particular with proving equivalences of programs; these are
\begin{itemize}
\item \emph{Operational semantics}, in which the execution of programs is
  described by a transition (or evaluation) relation between program fragments,
  an overall state and the value in which an expression is supposed to result.
  Among the various incarnations of operational semantics, an approach
  popularised by Plotkin is used very commonly. This method employs rules that
  are structurally similar to those found in deduction systems to determine the
  evaluation of a program in a syntax directed way (see \cite{Plotkin81}).
  
  Other known examples of operational semantics, which are quite close to actual
  implementations of the respective language include Warren's abstract machine
  for interpreting Prolog programs or the SECD machine for evaluation of lambda
  terms.
\item \emph{Denotational semantics}, in which so-called semantic functions are
  defined, which map language elements into their intended interpretation in a
  mathematical model of the programming language at hand.  In simple cases this
  is quite similar to giving a model for a language of first-order logic, but in
  common applications (\EG when giving a semantics for a functional language
  featuring some kind of recursion) rather sophisticated mathematics (in
  concrete terms: the field of \emph{domain theory} with its notions of least
  upper bounds, continuous functions and fixed points) become involved, cf.
  \cite{Reynolds98,Winskel93}. A cornerstone of this kind of semantics is the
  compositionality of its semantic functions, \IE semantic functions for
  composite terms can be explained through the meaning of their component parts
  alone.
  
\item \emph{Program logics} (often called axiomatic semantics), which differ
  from the above methods as they do not directly assign meaning to programs, but
  rather embed the programming language into a logical framework that allows for
  making statements about a program's behaviour and, hence, its correctness.
  Hoare's article \cite{Hoare69} is the classic introductory paper about program
  logics, a special kind of which therefore are termed \emph{Hoare logics}.

\end{itemize}

In this thesis we describe, apply and implement a program logic named
\emph{(propositional) monadic dynamic logic} \cite{SchroederMossakowski:PDL}
which allows one to prove properties of monadic programs. \Eat{The semantics of
  this logic is monad-independent in the sense that it is not tailored towards
  specific monads like the state monad, but rather requires some quite general
  additional structure that is found in many commonly encountered monads.}  The
logic allows to reason about partial correctness of programs, but also to prove
termination and thus total correctness in one and the same framework.

Monads constitute an elegant technique for consistently abstracting and
analysing several kinds of language features, \EG side effects, nondeterminism,
exceptions, input and output as well as combinations of these. The use of a
logic of monadic programs is twofold: it can be used to rather directly reason
about programming languages that support the notion of a monad (such as
Haskell), but it can also be used to reason about programs written in imperative
first-order languages, if one creates a monadic model of the key features of
such a language and translates programs into this model. For Java this has been
done recently (see \cite{HuismanJacobs00}) and the calculus described in this
thesis has been extended to deal with Java-like abnormal termination. This
extension does not solely cover actual exceptions but also termination of a
method through a \code{return} statement, or the interruption of execution of a
while-loop through a \code{break} or \code{continue} statement.

An important feature of the logic is the fact that it is monad independent,
which means that the general logical framework is applicable to every monad that
allows the interpretation of dynamic logic, which is the case for nearly all
computationally relevant monads. A notable exception to this is the continuation
monad. Instantiations of the logic for concrete monads are realised through
additional axioms determining the monad-specific operations, like reference
writing in the state monad, or nondeterministic choice in the nondeterminism
monad.  While bearing some resemblance to Pitt's evaluation logic
\cite{Pitts91}, the calculus described here is equipped with a purely monadic
semantics, whereas Pitts provides a semantics only through certain
hyperdoctrines acting on top of the monad. An alternative, but merely global
semantics for the modal operators was given by Moggi \cite{Moggi95}. However, a
critical property of the modal operators is their \emph{local} character, which
is retained in the calculus described here. On top of it, a Hoare calculus for
total correctness can easily be formulated.


\section{Problem Setting}
\label{sec:problem-setting}
The aim of this work is twofold: on the one hand, it constitutes the first
extended application of the recently developed calculus of monadic dynamic logic
 and thus demonstrates how this calculus can be
applied to serious verification tasks. To name two examples, the total
correctness of a breadth-first search algorithm and of a pattern matching
algorithm involving Java-like exception handling have been established. 

On the other hand, driven by the insight that due to the complexity even of
relatively small software systems it is not feasible to carry out formal proofs
about these manually, the calculus had to be implemented in some proof assistant
tool. Furthermore, the formalisation within such a tool provides further
evidence of the correctness of one's inferences -- provided one trusts in the
correctness of the tool, of course.  We chose the generic proof assistant (often
termed `theorem prover') \IsabelleHOL in which we could base our implementation
on a stable and well developed formalisation of higher-order logic. \IsabelleHOL
comes with tools for proving theorems outright (by means of a classical tableau
reasoner) as well as a term rewriting system that allows for equational
reasoning and functional programming. Tasks during this implementation included
the definition of a syntax for monadic dynamic logic, proving the theorems
needed as foundations for the logic, and working out theorems and setting up
\Isabelle's automatic proof facilities to make life easier when applying the
logic. The embedding into higher-order logic is a deep one in the sense that we
define monadic logical connectives $\land_D$, $\longrightarrow_D$, etc. as well
as a predicate $\vdash$ asserting the validity of monadic formulae. HOL formulae
may, however, appear in monadic formulae thanks to existence of an insertion
function $\Ret$ mapping HOL formulae into those of dynamic logic.

\section{Structure of the Thesis}
\label{sec:structure-thesis}
This thesis is structured as follows:
\begin{description}
\item[Chapter \ref{cha:theoret-basis}] introduces the theoretical background
  needed for the further development, which is the lambda calculus in its typed
  and untyped form, and the
  categorical concept of a monad as it is used in computer science. 
\item[Chapter \ref{cha:logic}] contains some preliminary work which eventually
  leads to the formulation of the calculus of monadic dynamic logic. This
  calculus is then extended to deal with the peculiarities of the exception
  monad such that a pattern match algorithm can be specified and proved correct.
\item[Chapter \ref{cha:application}] provides basic theorems characteristic of
  dynamic logics and it contains an extended application of the calculus to
  several monads. For example, the correctness of a tree search algorithm is
  established.
\item[Chapter \ref{cha:isabelle}] gives an overview of the proof assistant
  Isabelle, its basic concepts, the higher-order logic HOL and the Isar proof
  language.
\item[Chapter \ref{cha:implementation}] describes the implementation of the
  calculus in Isabelle/HOL. This includes background work on properties of
  monadic programs as well as the setup of the calculus itself and the
  presentation of example specifications and proofs. Also, some differences
  between the calculus as laid out in \cite{SchroederMossakowski:PDL} and its
  implementation are depicted.
\item[Chapter \ref{cha:outlook}] concludes by summarising the achievements and
  pointing out future work.
\end{description}

The appendix contains a Haskell implementation of the exception monad programs
described in Section \ref{sec:spec-extens-except}, a list of rules frequently
used in Isabelle/HOL, and finally  a typeset edition of the theory files which
make up the calculus of monadic dynamic logic as implemented in Isabelle.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 

spec PetriNet = 
  Monoid and Map 
then
  sorts P,T 
  type Net = {(p,pre,post) : Set P  *  (T ->? Mon P) * (T ->? Mon P)  
                      	. dom pre=dom post /\
                     	pre :: dom  pre  -> mon p /\
                     	post :: dom post  -> mon p }

  op __union__ : Net * Net -> Net
  forall p1,p2:Set P; pre1,pre2,post1,post2:T ->? Mon P
  . (p1,pre1,post1) union (p2,pre2,post2) = 
    (p1 union p2, \t . pre1 + pre2, \t . post1 + post2) 
end

spec PetriSystem = 
  PetriNet 
then
  type Sys = {((p,pre,post),m) : Net P T  *  Mon P  
                          . m isIn mon p}

  ops  marking   : Sys ->  Mon P;
       net       : Sys -> Net; 
        __[__>   : Sys * T -> Sys; 
       __union__ : Sys * Sys -> Sys

  forall sys,sys1,sys2:Sys; n:Net; m:Mon P; t:T
  . marking ((n,m) as Sys P T) = m
  . def sys[t> <=> t isIn dom pre  /\ pre(t) < marking(sys)
  . def sys[t> => sys[t> = (net(sys), marking(sys) - pre(t) + post(t)) as Sys
  . union (sys1,sys2) = 
    (net(sys1) union net(sys2), marking(sys1) + marking(sys2)) as Sys
end 
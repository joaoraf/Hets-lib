library HasCASL/Real3D/Basics
version 0.1

%author: E. Schulz
%date: 12-11-2008

%prec({__isIn__, __subset__, __disjoint__,__ :: __ --> __} 
		 < {__union__, __intersection__, __\\__} )%
%prec {__union__} < {__*__}

%number __@@__

logic HasCASL

from HasCASL/Algebra get
     ExtInverse
from HasCASL/LinearAlgebra get
     EuclideanVectorSpace
from HasCASL/Reals get
     ExtFieldWithOrdering, RealFunctions



%[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Real 3D Vector Space                       %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]%

spec RealBase = ExtFieldWithOrdering[RealFunctions fit Elem |-> Real]
then
     ops  2: Real = 1 + 1;                      %(2_def_Real)%
	  3: Real = 2 + 1;                      %(3_def_Real)%
	  4: Real = 3 + 1;                      %(4_def_Real)%
	  5: Real = 4 + 1;                      %(5_def_Real)%
	  6: Real = 5 + 1;                      %(6_def_Real)%
	  7: Real = 6 + 1;                      %(7_def_Real)%
	  8: Real = 7 + 1;                      %(8_def_Real)%
	  9: Real = 8 + 1;                      %(9_def_Real)%

     type ZeroToNine =
	  {x:Real. x=0\/x=1\/x=2\/x=3\/x=4\/x=5\/x=6\/x=7\/x=8\/x=9}

     op __ @@ __ (m:ZeroToNine;n:Real): Real = (m * (9 + 1)) + n
     %(decimal_def)%

end

spec Points3D = RealBase then
     free type Point ::= P(C1:Real;C2:Real;C3:Real)
     ops 0:Point=P(0,0,0);
end

spec Vectors3DBase = RealBase then
     free type Vector ::= V(C1:Real;C2:Real;C3:Real)
     ops 0:Vector=V(0,0,0);
	 __+__ : Vector * Vector -> Vector;
	 - __ : Vector -> Vector;

     forall x,y:Vector
     . x+y = V(C1(x)+C1(y),C2(x)+C2(y),C3(x)+C3(y))
     . -x = V(-C1(x),-C2(x),-C3(x))
end

%( extend by binary inverse )%
spec Vectors3D =
ExtInverse[Vectors3DBase fit
	   Elem |-> Vector, __ * __ |-> __ + __, inv |-> - __]
     with __ / __ |-> __ - __ then

     ops __*__(x:Real;y:Vector):Vector = V(x*C1(y),x*C2(y),x*C3(y));
     %(scalar mutliplication)%
	 __*__(x,y:Vector):Real = C1(x)*C1(y)+C2(x)*C2(y)+C3(x)*C3(y);
	 %(scalar product)%
	 __#__(x,y:Vector):Vector = V(C2(x)*C3(y)-C2(y)*C3(x),
				      C3(x)*C1(y)-C3(y)*C1(x),
				      C1(x)*C2(y)-C1(y)*C2(x));
				      %(vector product)%
	 |__|(x:Vector):Real=sqrt(x*x as RealPos); %(the norm of a vector)%

     preds orth:Vector*Vector;
	   colin:Vector*Vector;

     forall x,y:Vector
     . orth(x,y) <=> x*y=0 %(orthogonal_def)%
     . colin(x,y) <=> (y=0 \/ exists r:Real. x = r*y) %(colin_def)%

then %implies
     forall x,y:Vector
     . x # y = -(y # x)    %(cross product antisymmetric)%
     . orth(x,x # y)       %(cross product orthogonal)%
     . colin(x,y) <=> (x # y = 0)       %(cross product zero iff colinear)%
end

%[
view Vectors3D_as_EuclideanVectorSpace :
     EuclideanVectorSpace to Vectors3D
=    Space |-> Vector
end
]%

spec AffineRealSpace3D = Points3D and Vectors3D
then
     ops __+__ : Point * Vector -> Point;
	 vec : Point * Point -> Vector;
	 asVector : Point -> Vector;
	 asPoint  : Vector -> Point;

     forall p,p':Point; v:Vector
     . asVector(p) = V(C1(p),C2(p),C3(p)) %(point_to_vector_embedding)%
     . asPoint(v) = P(C1(p),C2(p),C3(p))  %(vector_to_point_embedding)%
     . vec(p,p') = asVector(p') - asVector(p)         %(vec_def)%
     . asVector(p + v) = asVector(p) + v     %(compatibility_PVplus_Vplus)%

then %implies
     forall p,q,r:Point
     . vec(p,q) + vec(q,r) = vec(p,r) %(transitivity_of_vec_+)%
     . vec(p,q) = - vec(q,p)          %(antisymmetry_of_vec)%
end

%( taken from Set.het but changed the meaning of {f} )%
spec SetsWithComprehension =
  var S,T : Type
  type Set S := Pred(S);
  ops emptySet : Set S;
      allSet : Set S;
      __isIn__ : Pred(S * Set S);
      __subset__ :Pred( Set(S) * Set(S) );
      __union__, __intersection__, __\\__  : Set S * Set S -> Set S;
      bigunion : Set(Set S) -> Set S;
      __disjoint__ : Pred( Set(S) * Set(S) );
      __*__ : Set S * Set T -> Set (S*T);
      {__}(s:Set S):Set S = s; %(set comprehension)%
      image(f:(S->T);X:Set S):Set T
	   = { \x:T . exists y:S. y isIn X /\ f(y) = x }; %(function image)%

  forall x,x':S; y:T; s,s':Set S; t:Set T; XX:Set(Set S) 
  . not (x isIn emptySet)
  . x isIn allSet
  . x isIn s <=> s x
  . s subset s' <=> forall x:S . x isIn s => x isIn s'
  . x isIn s union s' <=> x isIn s \/ x isIn s'
  . x isIn bigunion XX <=> exists X:Set S . X isIn XX /\ x isIn X
  . x isIn s intersection s' <=> x isIn s /\ x isIn s'
  . x isIn s \\ s' <=> x isIn s /\ not x isIn s'
  . s disjoint s' <=> s intersection s' = emptySet
  . (x,y) isIn s * t <=> x isIn s /\ y isIn t

end

spec AffineRealSpace3DWithSets = AffineRealSpace3D and SetsWithComprehension
then
     types PointSet := Set Point;
	   VectorSet := Set Vector;
	   RealSet := Set Real;

     ops [__ ... __](a,b:Real):RealSet= \r:Real . (r >= a) /\ (r <= b);

	 %{Lifting operations for +}%

	 __+__ (P:PointSet; v:Vector):PointSet = image((\x:Point .! x+v), P);
	 __+__ (p:Point; V:VectorSet):PointSet = image((\x:Vector .! p+x), V);
	 __+__ (P:PointSet; V:VectorSet):PointSet =
	       bigunion (image((\x:Vector .! P+x), V));

	 %{We could also introduce lifting operations for vec}%

end

library HasCASL/Real3D/Basics
version 0.1

%author: E. Schulz
%date: 12-11-2008

%prec({__isIn__, __subset__, __disjoint__,__ :: __ --> __} 
		 < {__union__, __intersection__, __\\__} )%
%prec {__union__} < {__*__}

%number __@@__

logic HasCASL

from HasCASL/Algebra get
     ExtInverse
from HasCASL/LinearAlgebra get
     ExtEuclideanVectorSpace
from HasCASL/AffineGeometry get
     ExtAffineSpace
from HasCASL/Reals get
     ExtFieldWithOrdering, RealFunctions



%[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       Real 3D Vector Space                       %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]%

spec RealBase = ExtFieldWithOrdering[RealFunctions fit Elem |-> Real]
then
     ops  2: Real = 1 + 1;                      %(2_def_Real)%
	  3: Real = 2 + 1;                      %(3_def_Real)%
	  4: Real = 3 + 1;                      %(4_def_Real)%
	  5: Real = 4 + 1;                      %(5_def_Real)%
	  6: Real = 5 + 1;                      %(6_def_Real)%
	  7: Real = 6 + 1;                      %(7_def_Real)%
	  8: Real = 7 + 1;                      %(8_def_Real)%
	  9: Real = 8 + 1;                      %(9_def_Real)%

     type ZeroToNine =
	  {x:Real. x=0\/x=1\/x=2\/x=3\/x=4\/x=5\/x=6\/x=7\/x=8\/x=9} %(ZeroToNine type)%

     op __ @@ __ (m:ZeroToNine;n:Real): Real = (m * (9 + 1)) + n %(decimal_def)%

end

spec Points3D = RealBase then
     free type Point ::= P(C1:Real;C2:Real;C3:Real)  %(Point datatype)%
     ops 0:Point=P(0,0,0); %(Zero Point)%

	 %% choice operators may only be defined on non-empty types,
	 %% otherwise they introduce inconsistencies as they guarantee
	 %% the existence of an element!
	 choose:Pred(Point) -> Point; %(choice op for Point)%

     . forall P:Pred(Point). (exists y:Point. P(y)) => P(choose(P)) %(Point choice)%

end

spec Vectors3DBase = RealBase then
     free type Vector ::= V(C1:Real;C2:Real;C3:Real) %(Vector datatype)%

     ops 0:Vector=V(0,0,0); %(Zero Vector)%
	 __+__ : Vector * Vector -> Vector;
	 - __ : Vector -> Vector;

     pred VectorStar_pred(x:Vector) <=> not x = 0; %(RealStar_pred_def)%
     type VectorStar = {x:Vector. VectorStar_pred x};
     ops VectorStar_inj: VectorStar -> Vector;
         VectorStar_proj: Vector -> VectorStar;
     . isSubtypeWithPred(VectorStar_pred, VectorStar_inj, VectorStar_proj);
     %(VectorStar_subtype)%

     vars x,y:Vector
     . x+y = V(C1(x)+C1(y),C2(x)+C2(y),C3(x)+C3(y))  %(def of vector addition)%
     . -x = V(-C1(x),-C2(x),-C3(x)) %(def of minus vector)%
end

%( extend by binary inverse )%
spec Vectors3D =
ExtInverse[Vectors3DBase fit
	   Elem |-> Vector, __ * __ |-> __ + __, inv |-> - __]
     with __ / __:Vector*Vector->Vector |-> __ - __ then

     ops __*__(x:Real;y:Vector):Vector = V(x*C1(y),x*C2(y),x*C3(y));
     %(scalar mutliplication)%
	 __*__(x,y:Vector):Real = C1(x)*C1(y)+C2(x)*C2(y)+C3(x)*C3(y);
	 %(scalar product)%
	 __#__(x,y:Vector):Vector = V(C2(x)*C3(y)-C2(y)*C3(x),
				      C3(x)*C1(y)-C3(y)*C1(x),
				      C1(x)*C2(y)-C1(y)*C2(x));
				      %(vector product)%

then %implies
     var x,y,z:Vector; r:Real

     %{ cross prod props }%
     . r * (x # y) = (r * x) # y; %(cross left homogenity)%
     . x # y = -(y # x)    %(cross product antisymmetric)%

end

spec Vectors3DSpace = ExtEuclideanVectorSpace[Vectors3D fit Space |-> Vector]
then %implies
     var x,y,z:Vector; r:Real

     %{ mixed props }%
     . orth(x,x # y)       %(cross product orthogonal)%
     . lindep(x,y) <=> (x # y = 0) %(cross product zero iff lindep)%

end

spec AffineRealSpace3D_aux = Points3D and Vectors3DSpace
then
     ops asVector(p: Point):Vector = V(C1(p),C2(p),C3(p)); %(point_to_vector_embedding)%
	 asPoint(v: Vector):Point  = P(C1(v),C2(v),C3(v)); %(vector_to_point_embedding)%
end

spec AffineRealSpace3D = ExtAffineSpace[AffineRealSpace3D_aux
					fit Space |-> Vector,
					Elem |-> Real,
					origin |-> 0:Point]


%( taken from Set.het but changed the meaning of {f} )%
spec SetsWithComprehension =
  var S,T : Type
  type Set S := Pred(S);
  ops emptySet : Set S;
      allSet : Set S;
      __isIn__ : Pred(S * Set S);
      __subset__ :Pred( Set(S) * Set(S) );
      __union__, __intersection__, __\\__  : Set S * Set S -> Set S;
      bigunion : Set(Set S) -> Set S;
      __disjoint__ : Pred( Set(S) * Set(S) );
      __*__ : Set S * Set T -> Set (S*T);
      {__}(s:Set S):Set S = s; %(set comprehension)%
      image(f:(S->T);X:Set S):Set T
	   = { \x:T . exists y:S. y isIn X /\ f(y) = x }; %(function image)%

  vars x,x':S; y:T; s,s':Set S; t:Set T; XX:Set(Set S) 
  . not (x isIn emptySet)  %(emptySet not empty)%
  . x isIn allSet %(allSet contains all)%
  . x isIn s <=> s x %(def of isIn)%
  . s subset s' <=> forall x:S . x isIn s => x isIn s' %(def of subset)%
  . x isIn s union s' <=> x isIn s \/ x isIn s' %(def of union)%
  . x isIn bigunion XX <=> exists X:Set S . X isIn XX /\ x isIn X %(def of bigunion)%
  . x isIn s intersection s' <=> x isIn s /\ x isIn s' %(def of intersection)%
  . x isIn s \\ s' <=> x isIn s /\ not x isIn s' %(def of difference)%
  . s disjoint s' <=> s intersection s' = emptySet %(def of disjoint)%
  . (x,y) isIn s * t <=> x isIn s /\ y isIn t %(def of productset)%

end

spec AffineRealSpace3DWithSets = AffineRealSpace3D and SetsWithComprehension
then
     types PointSet := Set Point;
	   VectorSet := Set Vector;
	   RealSet := Set Real;

     ops [__ ... __](a,b:Real):RealSet= \r:Real . (r >= a) /\ (r <= b); %(def of interval)%

	 %{Lifting operations for +}%

	 __+__ (P:PointSet; v:Vector):PointSet = image((\x:Point .! x+v), P); %(plus PointSet Vector)%
	 __+__ (p:Point; V:VectorSet):PointSet = image((\x:Vector .! p+x), V); %(plus Point VectorSet)%
	 __+__ (P:PointSet; V:VectorSet):PointSet =
	       bigunion (image((\x:Vector .! P+x), V)); %(plus PointSet VectorSet)%

	 %{We could also introduce lifting operations for vec}%

end

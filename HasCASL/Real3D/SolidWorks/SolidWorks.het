library HasCASL/Real3D/SolidWorks/SolidWorks
version 0.1

%author: E. Schulz
%date: 12-12-2008

logic HasCASL

from HasCASL/Real3D/Geometry get BaseObjects
from HasCASL/Real3D/Basics get RealBase

%[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       The SolidWorks base objects                %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]%


spec SolidWorks = RealBase then

     type Direction = {x:Real. x=1\/x= -1};

     free types
     SWPoint ::= SWPoint(x:Real;y:Real;z:Real);
     SWArc ::= SWArc(ArcPlane:SWPlane;Center:SWPoint;Start:SWPoint;End:SWPoint);
     SWPlane ::= SWPlane(SpacePoint:SWPoint;NormalVector:SWPoint);
     SWObject ::= Arc (getArc:SWArc)
			| Plane (getPlane:SWPlane)
			| Extrusion(From:SWObject;
				    Length:Real;ExDirection:Direction);

     
     ops
     %% the base objects of SolidWorks
     E1:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(0,0,1));
     E2:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(0,1,0));
     E3:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(1,0,0));

end


spec SolidWorksSemanticConstructors = BaseObjects then
     ops
	 %{ The following part provides a basis for the
	 semantics of the solid works objects }%

	 %{ The plane orthogonal to the normal vector }%
	 VLine(p1:Vector;p2:Vector):VectorSet
	  = image(\y:Real .! p1 + (y*(p2-p1)), [0...1]);

	 %{ Normalize the given Vector and scale it by the scalar }%
	 VWithLength(v:Vector;s:Real):Vector
	  = v when (v=0) else (s / (|v| as NonZero))*v;

	 %{ The plane orthogonal to the normal vector }%
	 VPlane(normal:Vector):VectorSet
	  = { \y:Vector .! orth(y,normal) };

	 %{ The plane spanned by the given to axes }%
	 VPlane2(axis1:Vector;axis2:Vector):VectorSet
          = VPlane(axis1 # axis2);

	 %{ The connected set containing the given point and separated 
	 by the given frontier }%
	 VConnected(frontier:VectorSet;point:Vector):VectorSet
	  = frontier when (frontier point) else 
	       { \y:Vector .!  VLine(point,y) intersection frontier = emptySet };

	 %{ The halfspace separated by the plane defined
	 by the given normal vector, where the normal vector points to. }%
	 VHalfSpace(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal);

	 %{ As VHalfSpace but including the resulting VPlane. }%
	 VHalfSpace2(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal) union (VPlane normal);

	 %{ The ball with radius r }%
	 VBall(r:Real):VectorSet
	  = { \y:Vector .!  |y| <= r };

	 %{ The circle as intersection of a plane with a ball }%
	 VCircle(r:Real;axis:Vector):VectorSet
	  = VPlane(axis) intersection VBall(r);


	 %{ This action attaches the given vectors to the given point
	 and thus creates a PointSet }%
	 ActAttach(point:Point;vectors:VectorSet):PointSet
	  = point + vectors;

	 %{ This action adds points to the given points by moving along
	 the axis }%
	 ActExtrude(axis:Vector;points:PointSet):PointSet
	  = { \x:Point .! exists l:Real. exists y:Point.
	      l isIn [0...1] /\ y isIn points /\ x= y + l * axis };
end


spec SolidWorksWithSemantics = SolidWorks and SolidWorksSemanticConstructors
then
     ops

     %% the semantics of the objects:
     %% ip = point-interpretation for points
     ip(point:SWPoint):Point=P(x(point),y(point),z(point));
     %% iv = vector-interpretation for points
     iv(point:SWPoint):Vector=asVector(ip point);

     %% i = interpretation for solid works objects
     i:SWObject->PointSet;

     vars x,y,z:SWPoint;p:SWPlane;d:Direction;a:SWArc;s:SWObject;l:Real

     . i(Plane(SWPlane(x,y))) = ActAttach(ip x,VPlane(iv y))

     . i(Arc(SWArc(p,x,y,z))) = 
       let cp = ip(x);
	   center = iv(x);
	   p1 = iv(y);
	   p2 = iv(z);
	   n = iv(NormalVector(p));
	   r1 = p1 - center;
	   r2 = p2 - center;
	   Ball = VBall(|r1|);
	   HS1 = VHalfSpace2(n#r1);
	   HS2 = VHalfSpace2(r2#n);
	   plane = i(Plane(p))
       in
       ActAttach(cp,
		 Ball
		 intersection
		 ((HS1 intersection HS2) when (n#r1)*r2 > 0
		  else (HS1 union HS2)))
       intersection plane

     . i(Extrusion(Arc(a),l,d)) =
       let axis = iv(NormalVector(ArcPlane(a)));
	   scaledAxis = VWithLength(axis, d*l);
	   arc = i(Arc(a))
       in
       ActExtrude(scaledAxis, arc)
%[
]%
end

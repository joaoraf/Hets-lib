library HasCASL/Real3D/SolidWorks/SolidWorks
version 0.1

%author: E. Schulz
%date: 12-12-2008

%list [__], [], __::__

logic HasCASL

from HasCASL/Real3D/Basics get RealBase, AffineRealSpace3DWithSets

%[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       The SolidWorks base objects                %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]%


%[ The type hierarchie:

          SWObject
            |  | \
            |  |  \
            |  |   SWFeature
            |  |      |
            |  |      | constructed of
            |  |      |
            |  \   SWSketch
            \   \     |
             \   \    | list of
              \   \   |
               \   SWSketchObject
                \     |
                 \    |
                  \   |
                   SWLine, SWArc and SWSpline
             

]%

spec SolidWorks = RealBase then

     var a:Type
     free type SWList a ::=  [] |  __ :: __ (first:? a; rest:? SWList a) %(SWList datatype)%

     free types
     SWVector ::= SWVector(x:Real;y:Real;z:Real); %(SWVector datatype)%
     SWPoint ::= SWPoint(x:Real;y:Real;z:Real); %(SWPoint datatype)%
     SWPlane ::= SWPlane(SpacePoint:SWPoint;NormalVector:SWVector;InnerCS:SWVector); %(SWPlane datatype)%
     SWArc ::= SWArc(Center:SWPoint;Start:SWPoint;End:SWPoint);  %(SWArc datatype)%
     SWLine ::= SWLine(From:SWPoint;To:SWPoint);  %(SWLine datatype)%
     SWSpline ::= SWSpline(Points:SWList SWPoint);  %(SWSpline datatype)%
     SWSketchObject ::= type SWArc | type SWLine | type SWSpline ;  %(SWSketchObject datatype)%
     SWSketch ::= SWSketch(Objects:SWList SWSketchObject;Plane: SWPlane);  %(SWSketch datatype)%

     SWExtrusion ::= SWExtrusion(Sketch:SWSketch;
				 Depth:Real;
				 DraftAngle:Real;
				 DraftOutward:Logical;
				 DraftWhileExtruding:Logical;
				 EndCondition:Real;
				 WallThickness:Real;
				 IsBaseExtrude:Logical;
				 IsBossFeature:Logical;
				 IsThinFeature:Logical); %(SWExtrusion datatype)%

     %% This Features are missing: Revolution, Sweep, Loft, Chamfer
     SWFeature ::= type SWExtrusion;  %(SWFeature datatype)%

     SWObject ::= type SWSketchObject
		| type SWSketch
		| type SWPlane
		| type SWFeature; %(SWObject datatype)%

     ops
     SWReal:Real*Real -> Real; %(Real representation def)%

     %% the base objects of SolidWorks
     E1:SWPlane=SWPlane(SWPoint(0,0,0),SWVector(0,0,1),SWVector(1,0,0)); %(E1 def)%
     E2:SWPlane=SWPlane(SWPoint(0,0,0),SWVector(0,1,0),SWVector(1,0,0)); %(E2 def)%
     E3:SWPlane=SWPlane(SWPoint(0,0,0),SWVector(1,0,0),SWVector(0,1,0)); %(E3 def)%

end


spec SolidWorksSemanticConstructors = AffineRealSpace3DWithSets then
     ops
	 %{ The following part provides a basis for the
	 semantics of the solid works objects }%

	 %{ The plane orthogonal to the normal vector }%
	 VLine(p1:Vector;p2:Vector):VectorSet
	  = image(\y:Real .! p1 + (y*(p2-p1)), [0...1]); %(VLine constr)%

	 %{ Normalize the given Vector and scale it by the scalar }%
	 VWithLength(v:Vector;s:Real):Vector
	  = v when (v=0) else (s / (||v|| as NonZero))*v; %(VWithLength constr)%

	 %{ The plane orthogonal to the normal vector }%
	 VPlane(normal:Vector):VectorSet
	  = { \y:Vector .! orth(y,normal) }; %(VPlane constr)%

	 %{ The plane spanned by the given to axes }%
	 VPlane2(axis1:Vector;axis2:Vector):VectorSet
          = VPlane(axis1 # axis2); %(VPlane2 constr)%

	 %{ The connected set containing the given point and separated 
	 by the given frontier }%
	 VConnected(frontier:VectorSet;point:Vector):VectorSet
	  = frontier when (frontier point) else 
	       { \y:Vector .!  VLine(point,y) intersection frontier = emptySet }; %(VConnected constr)%

	 %{ The halfspace separated by the plane defined
	 by the given normal vector, where the normal vector points to. }%
	 VHalfSpace(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal); %(VHalfSpace constr)%

	 %{ As VHalfSpace but including the resulting VPlane. }%
	 VHalfSpace2(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal) union (VPlane normal); %(VHalfSpace2 constr)%

	 %{ The ball with radius r }%
	 VBall(r:Real):VectorSet
	  = { \y:Vector .!  ||y|| <= r }; %(VBall constr)%

	 %{ The circle as intersection of a plane with a ball }%
	 VCircle(r:Real;axis:Vector):VectorSet
	  = VPlane(axis) intersection VBall(r); %(VCircle constr)%


	 %{ This action attaches the given vectors to the given point
	 and thus creates a PointSet }%
	 ActAttach(point:Point;vectors:VectorSet):PointSet
	  = point + vectors; %(ActAttach constr)%

	 %{ This action adds points to the given points by moving along
	 the axis }%
	 ActExtrude(axis:Vector;points:PointSet):PointSet
	  = { \x:Point .! exists l:Real. exists y:Point.
	      l isIn [0...1] /\ y isIn points /\ x= y + l * axis }; %(ActExtrude constr)%
then %implies

	 %{ The following part provides some basic facts about
	 these constructor }%
	 vars v:Vector;s:Real

	 . not (v=0) => ||VWithLength(v,s)|| = abs(s) %(vwl length)%

	 . lindep(v, VWithLength(v,s)) %(vwl lindep)%

end


spec SolidWorksWithSemantics = SolidWorks and SolidWorksSemanticConstructors
then
     ops

     %% the semantics of the objects:
     %% ip = point-interpretation for points
     ip(point:SWPoint):Point=P(x(point),y(point),z(point)); %(semantics for SWPoint)%
     %% iv = vector-interpretation for vectors
     iv(vector:SWVector):Vector=V(x(vector),y(vector),z(vector)); %(semantics for SWVector)%

     %% i = interpretation for solid works features
     i:SWFeature->PointSet;

     %% i = interpretation for solid works planes
     i:SWPlane->PointSet;

     vars o,x,y,z:SWPoint;n,ics:SWVector;l,x1,x2,x3:Real;plane:SWPlane;
	  b1,b2,b3,b4,b5:Logical

     . i(SWPlane(o,n,ics)) = ActAttach(ip(o), VPlane(iv(n)));
     %(semantics for Planes)%

     %% we ignore all parameters after the length
     . i(SWExtrusion(SWSketch([SWArc(x,y,z)],plane),
		    l,x1,b1,b2,x2,x3,b3,b4,b5)) =
       (let cp = ip(x);
	    r1 = vec(cp, ip(y));
	    ball = ActAttach(cp, VBall( ||r1|| ));
	    planeI = i(plane);
	    scaledAxis = VWithLength(iv(NormalVector(plane)), l)
        in ActExtrude(scaledAxis, ball intersection planeI)) when y = z else emptySet
       %(semantics for ArcExtrusion)%


     %% we define the inverse functions for point and vector interpretations
     ops ip_i(point:Point):SWPoint = 
	 SWPoint(C1(point),C2(point),C3(point)); %(inverse of ip)%
	 iv_i(vector:Vector):SWVector =
	 SWVector(C1(vector),C2(vector),C3(vector)); %(inverse of iv)%

then %implies
     vars x:Point; w:Vector; p:SWPoint; v:SWVector
     . ip_i(ip(p)) = p %(ip left inverse)%
     . ip(ip_i(x)) = x %(ip right inverse)%

     . iv_i(iv(v)) = v %(iv left inverse)%
     . iv(iv_i(w)) = w %(iv right inverse)%

end

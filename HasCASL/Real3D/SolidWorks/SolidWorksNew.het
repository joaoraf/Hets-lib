library HasCASL/Real3D/SolidWorks/SolidWorksNew
version 0.1

%author: E. Schulz
%date: 12-12-2008

%list [__], [], __::__

logic HasCASL

from HasCASL/Real3D/Geometry get BaseObjects
from HasCASL/Real3D/Basics get RealBase

%[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                  %%
%%                       The SolidWorks base objects                %%
%%                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]%


%[ The type hierarchie:

          SWObject
            |  | \
            |  |  \
            |  |   SWFeature
            |  |      |
            |  |      | constructed of
            |  |      |
            |  \   SWSketch
            \   \     |
             \   \    | list of
              \   \   |
               \   SWSketchObject
                \     |
                 \    |
                  \   |
                   SWPlane, SWPoint and other base objects
             

]%

spec SolidWorks = RealBase then

     type Direction = {x:Real. x=1\/x= -1}; %(direction subtype)%

     var a:Type
     free type SWList a ::=  [] |  __ :: __ (first:? a; rest:? SWList a) %(SWList datatype)%

     free types
     SWPoint ::= SWPoint(x:Real;y:Real;z:Real); %(SWPoint datatype)%
     SWPlane ::= SWPlane(SpacePoint:SWPoint;NormalVector:SWPoint); %(SWPlane datatype)%
     SWArc ::= SWArc(ArcPlane:SWPlane;Center:SWPoint;Start:SWPoint;End:SWPoint);  %(SWArc datatype)%
     SWSketchObject ::= type SWArc;  %(SWSketchObject datatype)%
     SWSketch ::= SWSketch(Arguments:SWList SWSketchObject);  %(SWSketch datatype)%

     %% Tanmay, please name (and adapt if necessary) these arguments appropriately
     SWFeature ::= SWExtrusion(Real;Real;Logical;Logical;Real;Real;
			       Logical;Logical;Logical;SWSketch); %(SWFeature datatype)%

     %% grouped together for semantics definition
     SWObject ::= type SWSketchObject
		| type SWSketch
		| type SWPlane
		| type SWFeature; %(SWObject datatype)%

     ops
     SWReal:Real*Real -> Real; %(Real representation def)%
     degenerated:Pred(SWPoint)= \p:SWPoint . p = SWPoint(0,0,0); %(degenerated Point def)%
     degenerated:Pred(SWPlane)= \p:SWPlane . degenerated(NormalVector(p)); %(degenerated Plane def)%

     %% the base objects of SolidWorks
     E1:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(0,0,1)); %(E1 def)%
     E2:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(0,1,0)); %(E2 def)%
     E3:SWPlane=SWPlane(SWPoint(0,0,0),SWPoint(1,0,0)); %(E3 def)%

     types SWPointNonDegenerated = {p:SWPoint. not degenerated(p)}; %(nondegeneratedpoint subtype)%
	   SWPlaneNonDegenerated = {p:SWPlane. not degenerated(p)}  %(nondegeneratedplane subtype)%

end


spec SolidWorksSemanticConstructors = BaseObjects then
     ops
	 %{ The following part provides a basis for the
	 semantics of the solid works objects }%

	 %{ The plane orthogonal to the normal vector }%
	 VLine(p1:Vector;p2:Vector):VectorSet
	  = image(\y:Real .! p1 + (y*(p2-p1)), [0...1]); %(VLine constr)%

	 %{ Normalize the given Vector and scale it by the scalar }%
	 VWithLength(v:Vector;s:Real):Vector
	  = v when (v=0) else (s / (||v|| as NonZero))*v; %(VWithLength constr)%

	 %{ The plane orthogonal to the normal vector }%
	 VPlane(normal:Vector):VectorSet
	  = { \y:Vector .! orth(y,normal) }; %(VPlane constr)%

	 %{ The plane spanned by the given to axes }%
	 VPlane2(axis1:Vector;axis2:Vector):VectorSet
          = VPlane(axis1 # axis2); %(VPlane2 constr)%

	 %{ The connected set containing the given point and separated 
	 by the given frontier }%
	 VConnected(frontier:VectorSet;point:Vector):VectorSet
	  = frontier when (frontier point) else 
	       { \y:Vector .!  VLine(point,y) intersection frontier = emptySet }; %(VConnected constr)%

	 %{ The halfspace separated by the plane defined
	 by the given normal vector, where the normal vector points to. }%
	 VHalfSpace(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal); %(VHalfSpace constr)%

	 %{ As VHalfSpace but including the resulting VPlane. }%
	 VHalfSpace2(normal:Vector):VectorSet
	  = VConnected(VPlane normal, normal) union (VPlane normal); %(VHalfSpace2 constr)%

	 %{ The ball with radius r }%
	 VBall(r:Real):VectorSet
	  = { \y:Vector .!  ||y|| <= r }; %(VBall constr)%

	 %{ The circle as intersection of a plane with a ball }%
	 VCircle(r:Real;axis:Vector):VectorSet
	  = VPlane(axis) intersection VBall(r); %(VCircle constr)%


	 %{ This action attaches the given vectors to the given point
	 and thus creates a PointSet }%
	 ActAttach(point:Point;vectors:VectorSet):PointSet
	  = point + vectors; %(ActAttach constr)%

	 %{ This action adds points to the given points by moving along
	 the axis }%
	 ActExtrude(axis:Vector;points:PointSet):PointSet
	  = { \x:Point .! exists l:Real. exists y:Point.
	      l isIn [0...1] /\ y isIn points /\ x= y + l * axis }; %(ActExtrude constr)%
then %implies

	 %{ The following part provides some basic facts about
	 these constructor }%
	 vars v:Vector;s:Real

	 . not (v=0) => ||VWithLength(v,s)|| = abs(s) %(constrfact1)%

end


spec SolidWorksWithSemantics = SolidWorks and SolidWorksSemanticConstructors
then
     ops

     %% the semantics of the objects:
     %% ip = point-interpretation for points
     ip(point:SWPoint):Point=P(x(point),y(point),z(point)); %(pointsemantics for SWPoint)%
     %% iv = vector-interpretation for points
     iv(point:SWPoint):Vector=asVector(ip point); %(vectorsemantics for SWPoint)%

     %% i = interpretation for solid works objects
     i:SWObject->PointSet;

     vars x,y,z:SWPoint;p:SWPlane;d:Direction;a:SWArc;s:SWObject;l:Real;sk:SWSketch

     . i(SWPlane(x,y)) = ActAttach(ip x,VPlane(iv y)) %(semantics for plane)%


     . i(SWArc(p,x,y,z)) =
       let cp = ip(x);
	   center = iv(x);
	   p1 = iv(y);
	   p2 = iv(z);
	   n = iv(NormalVector(p));
	   r1 = p1 - center;
	   r2 = p2 - center;
	   Ball = VBall( ||r1|| );
	   HS1 = VHalfSpace2(n#r1);
	   HS2 = VHalfSpace2(r2#n);
	   plane = i(p)
       in
       ActAttach(cp,
		 Ball
		 intersection
		 ((HS1 intersection HS2) when (n#r1)*r2 > 0
		  else (HS1 union HS2)))
       intersection plane 
       %(semantics for Arc)%


     . i(SWExtrusion(l,0,false,false,0,0,true,false,false,sk)) =
       i(SWExtrusion(l,0,false,false,0,0,true,false,false,sk))
%[       %% todo: access the vector for extrusion from the sketch
       let axis = iv(SWPoint(l,0,0));
	   scaledAxis = VWithLength(axis, l);
	   sketch = i(sk)
       in
       ActExtrude(scaledAxis, sketch) %(semantics for Extrusion)%
]%

end

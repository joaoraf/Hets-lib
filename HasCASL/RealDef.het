library HasCASL/RealDef
version 0.1

%author: D. Dietrich
%date: 09-2008

from Basic/Numbers get
        Nat

from Basic/RelationsAndOrders get
        EquivalenceRelation, TotalOrder

from HasCASL/Reals get 
        Reals

logic HasCASL


%[spec Quotconstruction = EquivalenceRelation]%
%[then]%
%[   generated type QuotElem ::= __ - __(Elem;Elem)]%
%[   forall a,b,c,d: Elem]%
%[   .  a - b = c - d <=> a + d = c + b    %(equality_Quot)%]%
%[   sort  Elem < QuotElem	]%
%[   forall a: Elem . a = a - 0             %(Elem2Quot_embedding)%]%
%[end]%

%% we use x to denote sequences
%% m,n,p to denote natural numbers
%% B always represeents a bound
%% define a new type for nearly additive functions
%% injNat for injecting the naturals
%% <<= as ordering on naturals

spec Naddfunctions = Nat
then %def
  ops
    dist: Nat*Nat -> Nat;
  preds
   is_nadd:Nat->Nat;

  . forall m,n:Nat. dist(m,n) = (m -! n) + (n -! m)
  . forall x:Nat->Nat . is_nadd(x) <=>
     (exists B:Nat. forall m,n:Nat. dist(m * x(n),n * x(m)) <= B * (m + n))

then %mono
  free type NaddAux ::= NAdd (unAdd: Nat->Nat)
  type Nadd = {X: NaddAux . is_nadd(unAdd X)}
  sort Nat < Nadd
  forall k:Nat . k = NAdd (\n:Nat.! k * n) %% Injection Natural Numbers
ops
    __ ++ __: Nadd * Nadd -> Nadd;
    __ ** __: Nadd * Nadd -> Nadd;
    nadd_rinv:Nadd -> Nadd;
    
    . forall x,y:Nadd . x ++ y = NAdd \n:Nat.! (unAdd x)(n) + (unAdd y)(n)   %% Addition on Nadd
    . forall x,y:Nadd . x ** y  = NAdd \n:Nat.! (unAdd x)((unAdd y)(n))      %% Multiplication on Nadd
    . forall x:Nadd . nadd_rinv(x) = NAdd \n:Nat.! (n * n) div (unAdd x)(n)  %% RInverse on Nadd

then %def
  preds
   __ === __ : Nadd*Nadd;          %% Equivalence Relation
   __ <<= __ : Nadd*Nadd;          %% refl. Ordering on Nadd

  . forall x,y:Nadd . x === y <=>
      (exists B:Nat. forall n:Nat. dist((unAdd x)(n), (unAdd y)(n)) <= B)

ops
    nadd_inv:Nadd -> Nadd;
    . forall x:Nadd . nadd_inv(x) = 0 when (x === 0) else nadd_rinv(x)  %% Proper Inverse

then %implies
  forall m,n,p:Nat
  . dist(n,n) = 0
  . dist(0,n) = n
  . dist(n,0) = n
  . dist(m,n) = dist(n,m)
  . dist(m + n,m + p) = dist(n,p)
  . dist(m + p,n + p) = dist(m,n)
  . dist(m + n,m) = n
  . dist(m,m + n) = n
  . m * dist(n,p) = dist(m * n,m * p)
  . dist(m,n) * p = dist(m * p,n * p)
  . (dist(m,n) = 0) <=> (m = n)
end

view naddequivEquivalenceRelation :
     EquivalenceRelation to Naddfunctions
=    Elem |-> Nadd,
     __ ~ __ |-> __ === __
end

view naddorderTotalOrder :
    TotalOrder to Naddfunctions
=   __ <= __ |-> __ <<= __,
    Elem |-> Nadd
end

spec SignedReal = Naddfunctions
then
   generated type SReal ::= __ - __(Nadd;Nadd)
   forall a,b,c,d: Nadd
   .  a - b = c - d <=> a ++ d = c ++ b    %(equality_Quot)%
   sort  Nadd < SReal	
   forall a: Nadd . a = a - 0             %(Nadd2SReal_embedding)%

ops
  inv_mul : SReal -> SReal;                %% multiplicative inverse
  __ ++ __ : SReal * SReal -> SReal;       %% addition
  __ ** __ :SReal * SReal -> SReal;        %% multiplication
  inv_add :SReal -> SReal;                 %% additive inverse

  . forall x,y:Nadd .  inv_add(x - y) = (y - x) %(SReal_addinv)%
  . forall x1,x2,y1,y2:Nadd . (x1 - y1) ++ (x2 - y2) = (x1 ++ x2) - (y1 ++ y2) %(SReal_add)%
  . forall x1,x2,y1,y2:Nadd . (x1 - y1) ** (x2 - y2) = ((x1 ** x2) ++ (y1 ** y2)) - ( (x1 ** y2) ++ (y1 ** x2)) %(SReal_mul)%
  
preds  __ <<= __ : SReal * SReal;
       __ === __ : SReal * SReal;      
  . forall x1,x2,y1,y2:Nadd . (x1 - y1) === (x2 - y2) <=> (x1 ++ y2 = x2 ++ y1)   %(SReal_eqv)%
  . forall x1,x2,y1,y2:Nadd . (x1 - y1) <<= (x2 - y2) <=> (x1 ++ y2 <<= x2 ++ y1) %(SReal_leq)%
%[  . forall x,y:SReal . inv(x,y) = (0 - 0) when (x = y) ]%
%[                    else ((inv(@d. x = y + d), &0) when (y <<= x)  ]%
%[                    else (&0, inv(@d. y = x + d))]%
%[			  )]%
end

view SignedRealEquiv :
     EquivalenceRelation to SignedReal
=    Elem |-> SReal,
     __ ~ __ |-> __ === __
end

view SignedRealTotalOrder :
    TotalOrder to SignedReal
=   __ <= __ |-> __ <<= __,
    Elem |-> Nadd
end

view RealsSignedReal :
  Reals to SignedReal
= 
  sort Real |-> SReal,
  pred __ <= __ |-> __ <<= __,
  ops 
    __ + __ |-> __ ++ __,
    __ * __ |-> __ ** __,
    0 |-> 0,
    1 |-> 1
end


library HasCASL/RealDef
version 0.1

%author: D. Dietrich
%date: 09-2008

from Basic/Numbers get
        Nat

from Basic/RelationsAndOrders get
        EquivalenceRelation, TotalOrder


logic HasCASL


%% we use x to denote sequences
%% m,n,p to denote natural numbers
%% B always represeents a bound
%% define a new type for nearly additive functions
%% injNat for injecting the naturals
%% <<= as ordering on naturals

spec PReal = Nat
then %def
  ops
    dist: Nat*Nat -> Nat;
  preds
   is_nadd:Nat->Nat;

  . forall m,n:Nat. dist(m,n) = (m -! n) + (n -! m)
  . forall x:Nat->Nat . is_nadd(x) <=>
     (exists B:Nat. forall m,n:Nat. dist(m * x(n),n * x(m)) <= B * (m + n))

then %mono
  free type NaddAux ::= NAdd (unAdd: Nat->Nat)
  type Nadd = {X: NaddAux . is_nadd(unAdd X)}
  sort Nat < Nadd
  forall k:Nat . k = NAdd (\n:Nat.! k * n) %% Injection Natural Numbers
ops
    __ ++ __: Nadd * Nadd -> Nadd;
    __ ** __: Nadd * Nadd -> Nadd;
    nadd_rinv:Nadd -> Nadd;
    
    . forall x,y:Nadd . x ++ y = NAdd \n:Nat.! (unAdd x)(n) + (unAdd y)(n)   %% Addition on Nadd
    . forall x,y:Nadd . x ** y  = NAdd \n:Nat.! (unAdd x)((unAdd y)(n))      %% Multiplication on Nadd
    . forall x:Nadd . nadd_rinv(x) = NAdd \n:Nat.! (n * n) div (unAdd x)(n)  %% RInverse on Nadd

then %def
  preds
   __ === __ : Nadd*Nadd;          %% Equivalence Relation
   __ <<= __ : Nadd*Nadd;          %% refl. Ordering on Nadd

  . forall x,y:Nadd . x === y <=>
      (exists B:Nat. forall n:Nat. dist((unAdd x)(n), (unAdd y)(n)) <= B)

ops
    nadd_inv:Nadd -> Nadd;
    . forall x:Nadd . nadd_inv(x) = 0 when (x === 0) else nadd_rinv(x)  %% Proper Inverse

then %implies
  forall m,n,p:Nat
  . dist(n,n) = 0
  . dist(0,n) = n
  . dist(n,0) = n
  . dist(m,n) = dist(n,m)
  . dist(m + n,m + p) = dist(n,p)
  . dist(m + p,n + p) = dist(m,n)
  . dist(m + n,m) = n
  . dist(m,m + n) = n
  . m * dist(n,p) = dist(m * n,m * p)
  . dist(m,n) * p = dist(m * p,n * p)
  . (dist(m,n) = 0) <=> (m = n)
end

view naddequivEquivalenceRelation :
     EquivalenceRelation to PReal
=    Elem |-> Nadd,
     __ ~ __ |-> __ === __
end

view naddorderTotalOrder :
    TotalOrder to PReal
=   __ <= __ |-> __ <<= __,
    Elem |-> Nadd
end

spec SignedReal = PReal
then %mono

   generated type Sreal ::= __ - __(Nadd;Nadd)
   forall a,b,c,d: Nadd
   .  a - b = c - d <=> a ++ d = c ++ b    %(equality_Sreal)%

   sort  Nadd < Sreal
   forall a: Nadd . a = a - 0             %(Nadd2Sreal_embedding)%

ops
  __ ++ __ : Sreal * Sreal -> Sreal;

pred
  __ <<= __ : Sreal * Sreal -> Sreal;
end


library HasCASL/RealDef
version 0.1

%% todo: structure similar parts of the theories to subtheories

%author: D. Dietrich
%date: 09-2008

from Basic/Numbers get
        Nat, Rat

from Basic/RelationsAndOrders get
        EquivalenceRelation, TotalOrder

from HasCASL/Reals get 
        SimpleReals, Reals, FieldWithOrdering

logic HasCASL


%% we use x to denote sequences
%% m,n,p to denote natural numbers
%% B always represeents a bound
%% define a new type for nearly additive functions
%% injNat for injecting the naturals
%% <<= as ordering on naturals

spec Quotient[EquivalenceRelation] =
  generated type Quotient ::= mk_quot(unquot:Elem)
  . forall a,b:Elem. mk_quot(a) = mk_quot(b) <=> a ~ b
  sort Elem < Quotient
end

spec NegExtension[sort Elem op __+__:Elem*Elem->Elem] =
  type ElemPair:=Elem*Elem
  preds
    __===__ :ElemPair*ElemPair;
    . forall x1,x2,y1,y2:Elem . (x1,x2) === (y1,y2) <=> x1+y2 = x2+y1
  ops
    __+__:ElemPair*ElemPair->ElemPair;
   . forall x1,x2,y1,y2:Elem . (x1,x2) + (y1,y2) = (x1+y1,x2+y2)
end

spec NegExtensionQuotient[sort Elem ops __+__:Elem*Elem->Elem; 0:Elem] =
  Quotient[NegExtension[sort Elem op __+__:Elem*Elem->Elem] fit Elem |-> ElemPair, __~__ |-> __===__]
then
  sort Elem<Quotient
  . forall a:Elem . a = mk_quot(a,0)
  ops
    __+__:Quotient*Quotient->Quotient;
    -__:Quotient->Quotient;
    __-__:Quotient*Quotient->Quotient;
    0:Quotient;
   . forall a,b:ElemPair . mk_quot(a) + mk_quot(b) = mk_quot(a+b)
   . forall a,b:Elem. -mk_quot(a,b) = mk_quot(b,a)
   . forall a,b:Quotient. a - b = a + (-b)
end

spec Dist[sort Elem ops 0:Elem; __+__:Elem*Elem->Elem; __-!__:Elem*Elem->Elem] =
ops
    dist: Elem*Elem -> Elem;
  . forall m,n:Elem. dist(m,n) = (m -! n) + (n -! m)
then %implies
  forall m,n,p:Elem
  . dist(n,n) = 0
  . dist(0,n) = n
  . dist(n,0) = n
  . dist(m,n) = dist(n,m)
  . dist(m + n,m + p) = dist(n,p)
  . dist(m + p,n + p) = dist(m,n)
  . dist(m + n,m) = n
  . dist(m,m + n) = n
end

spec NatDist = Dist[{Nat with logic -> HasCASL} fit Elem |-> Nat]
end


spec PRat = %mono

     Nat 

then %mono

     generated type PRat ::= __ / __ (Nat;Pos)
     forall i,j: Nat; p,q: Pos
     . i / p = j / q <=> i*q = j*p              %(equality_Rat)%

     sort Nat < PRat
     forall i:Nat . i = i / 1                   %(Nat2Rat_embedding)%

then %def

     preds    __ <= __, __ < __,
              __ >= __, __ > __: PRat * PRat;

  %% implied operation attributes :
then
     ops __+__:   PRat * PRat -> PRat;
         __*__:   PRat * PRat -> PRat;
         __ / __ : PRat * PRat ->? PRat;
 then
    forall p,q:Pos; n:Nat; i,j: Nat; x,y,z: PRat

  %% axioms concerning predicates]%

     . (i / p <= j / q <=> i * q <= j * p ) %(leq_def_Rat)%
     . x >= y <=> y <= x                    %(geq_def_Rat)%
     . x < y <=> (x <= y /\ not x=y )       %(less_def_Rat)%
     . x > y <=> y < x                      %(greater_def_Rat)%

  %% axioms concerning operations

     . (i / p) + (j / q) =	
       (i * q + j * p) / (p * q)        %(add_def_Rat)%
     . (i / p) * (j / q) = 
       (i * j) / (p * q)                %(mult_def_Rat)%
end


spec PRatSub = PRat
then
  ops
    __-!__ :         PRat * PRat ->  PRat;
    __ -?__ : PRat * PRat ->? PRat;
  forall p,q,r:PRat
  .  p -! q = 0 if p < q
  .  p -! q = p -? q if p >= q
  . def(p-?q) <=> p >= q             %(sub_dom_Nat)% %implied 
  . p -? q = r <=> p = r + q         %(sub_def_Nat)%
end

spec PRatDist = Dist[{PRatSub with logic -> HasCASL} fit Elem |-> PRat]
end






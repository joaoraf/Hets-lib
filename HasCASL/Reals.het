library HasCASL/Reals
version 0.2

%author: T. Mossakowski, S. Wölfl, E. Schulz, D.Dietrich
%date: 12-10-2005

%prec( 
  { __ - __, __ + __ } < 
  { __*__, __ / __ } 
)%

%prec( 
  { __ * __, __ / __ } < 
  { - __ } 
)%

%%from Basic/Numbers get Rat
from Basic/RelationsAndOrders get
     TotalOrder, ExtTotalOrder
from HasCASL/Algebra get Field, RichField
     

logic HasCASL

spec FieldWithOrdering =

     RichField and TotalOrder

then
    forall a, b, c:Elem
    . (a + c) <= (b + c) if a <= b              %(FWO_plus_left)%
%% doesn't work with if!!!
    . (a <= b /\ 0 <= c) => (a * c) <= (b * c) %(FWO_times_left)%
then %implies
    forall a, b, c, d: Elem
    . (a + b) <= (a + c) if b <= c              %(FWO_plus_right)%
    . (a * b) <= (a * c) if b <= c /\ 0 <= a    %(FWO_times_right)%
    . (a + b) <= (c + d) if a <= c /\ b <= d    %(FWO_plus)%
end


spec OrderedField =
     RichField
then
     pred Pos: Elem
     forall x,y: Elem
     . Pos(x) /\ Pos(y) => Pos(x*y)             %(OF_plus)%
     . Pos(x) /\ Pos(y) => Pos(x+y)             %(OF_times)%
     . Pos(x) /\ Pos(-x) => x = 0               %(OF_mutex)%
     . Pos(x) \/ Pos(-x)                        %(OF_exhaust)%
end

spec ExtOrderedField[OrderedField] = %def
     pred __<=__: Elem * Elem
       forall x,y: Elem
       . x <= y  <=> Pos(y - x)
end

spec ExtFieldWithOrdering[FieldWithOrdering] = %def
       pred Pos: Elem
       forall x: Elem
       . Pos(x) <=> 0 <= x
end

view OrderedField_in_FieldWithOrdering :
     OrderedField to ExtFieldWithOrdering[FieldWithOrdering]
end

view FieldWithOrdering_in_OrderedField :
     FieldWithOrdering to ExtOrderedField[OrderedField]
end

spec Reals = FieldWithOrdering with Elem |-> Real
%%and Rat
then

%%  type Rat < Real

  ops
    inf : Pred(Real) ->? Real;
  . forall S:Pred(Real) . forall m:Real. inf(S)=m <=> (forall m2:Real. (forall x:Real. S(x)=>x<=m2) => m <=m2)
then %implies

  . forall S: Pred(Real). (exists x:Real. S(x)) /\ (exists B:Real . forall x:Real. S(x) => x <= B) => exists m:Real. m=inf(S) %(Real_completeness)%
%%If A is a non-empty subset of R, and if A has an upper bound, then A has a least upper bound u, such that for every upper bound v of A, u ≤ v.
end



spec SimpleReals = Reals hide NonZero

spec OrderedReals = ExtTotalOrder[Reals fit Elem |-> Real]
then %def
     type RealPos = {x:Real. x >= 0};

     op abs(x:Real):RealPos = x when 0 <= x else -x
end

spec FieldWithValuation =
     Field
and  OrderedReals
then
     op val: Elem -> RealPos
     forall x,y:Elem
     . val(x) >= 0              %(non-negative)%
     . val(x) = 0 <=> x = 0     %(pos-definite)%
     . val(x * y) = val(x) * val(y) %(multiplic)%
     . val(x + y) <= val(x) + val(y) %(triangle)%
then %implies
     . val(1) = 1
end

view OrderedReals_as_FieldWithValuation :
     FieldWithValuation to OrderedReals
=    Elem |-> Real, val |-> abs
end

%( some selected basic functions for the reals )%
spec RealFunctions = OrderedReals
then %def

     ops sqr: Real -> RealPos;
	 sqrt: RealPos -> Real;

     var r:Real;q:RealPos
     . sqr(r) = r * r    %(sqr_def)%
     %{ to see that this definition of sqrt is definitional one need the
        injectivity of sqr on RealPos e.g. via the intermediate value theorem }%
     . sqr(sqrt(q)) = q  %(sqrt_def)%
end


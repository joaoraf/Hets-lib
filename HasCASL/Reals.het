library HasCASL/Reals
version 0.2

%author: T. Mossakowski, S. Wölfl, E. Schulz, D.Dietrich
%date: 12-10-2005

from Basic/Numbers get
     Nat, Int, Rat
from Basic/RelationsAndOrders get
     TotalOrder, ExtTotalOrder, RichTotalOrder
from Basic/Algebra_I get
     Field |-> BasicField

logic CASL

spec Field = BasicField with e |-> 1
then %def
ops -__:Elem->Elem;
    __ - __:Elem*Elem->Elem;
    inv:Elem->?Elem;
    __ / __: Elem*Elem->?Elem;

vars x,y:Elem
     . -x + x = 0                     %(additive_inverse)%
     . x - y = x + -y                 %(minus)%
     . not(x=0) => inv(x) * x = 1     %(multiplicative_inverse)%
     . not(y=0) => x / y = x * inv(y) %(divided)%
     . not(def(inv(0)))               %(inverse_zero_undef)%
     . not(def(x / 0))                %(divide_by_zero_undef)%
     
end

spec FieldWithOrdering =
     Field and TotalOrder
then
    vars a, b, c:Elem
    . (a + c) <= (b + c) if a <= b              %(FWO_plus_left)%
    . (a * c) <= (b * c) if a <= b /\ 0 <= c    %(FWO_times_left)%
then %implies
    vars a, b, c, d: Elem
    . (a + b) <= (a + c) if b <= c              %(FWO_plus_right)%
    . (a * b) <= (a * c) if b <= c /\ 0 <= a    %(FWO_times_right)%
    . (a + b) <= (c + d) if a <= c /\ b <= d    %(FWO_plus)%
end


spec OrderedField =
     Field
then
     pred Pos: Elem
     forall x,y: Elem
     . Pos(x) /\ Pos(y) => Pos(x*y)             %(OF_plus)%
     . Pos(x) /\ Pos(y) => Pos(x+y)             %(OF_times)%
     . Pos(x) /\ Pos(-x) => x = 0               %(OF_mutex)%
     . Pos(x) \/ Pos(-x)                        %(OF_exhaust)%
end

view OrderedField_in_FieldWithOrdering :
      OrderedField to
     { FieldWithOrdering then %def
       pred Pos: Elem
       forall x: Elem
       . Pos(x) <=> 0 <= x
     }
end

view FieldWithOrdering_in_OrderedField :
      FieldWithOrdering to
     { OrderedField then %def
       pred __<=__: Elem * Elem
       forall x,y: Elem
       . x <= y  <=> Pos(y - x)
     }
end

logic HasCASL

spec Reals = FieldWithOrdering with Elem |-> Real
%[then]%
%[  ops]%
%[    inf : Pred(Real) ->? Real;]%
%[  . forall S:Pred(Real) . forall m:Real. inf(S)=m <=> (forall m2:Real. (forall x:Real. S(x)=>x<=m2) => m <=m2)]%
%[then %implies]%
%[  . forall S: Pred(Real). (exists x:Real. S(x)) /\ (exists B:Real . forall x:Real. S(x) => x <= B) => exists m:Real. m=inf(S) %(Real_completeness)%]%
%%If A is a non-empty subset of R, and if A has an upper bound, then A has a least upper bound u, such that for every upper bound v of A, u ≤ v.
end



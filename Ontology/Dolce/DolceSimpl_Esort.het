library Ontology/DOLCE/DolceSimpl
%%8621
%[
todo
- [Claudio] add theorems with %implies, %implied
- [Claudio] add views for theorems like T31, or equivalence of parthood + overlap
- [Claudio] add Dd and Ad labels or comments whenever possible
- [Claudio] add modalities, use "logic Modal" only where you really use modalities
- [Claudio, Stefano] check use of hybrid modal logic
- [Klaus, Till] prove theorems using Isabelle
- [Till] open question: how to form disjunctions (and negations) of specifications, like in
    spec SD[sort s] = ...
    spec GD[sort s] = ...
    spec D[sort s] = SD[sort s] or GD[sort s]
- [Klaus, Till] CASL extension
- [Klaus, Till] find out how to increase model size for consistency checks in Isabelle
- [Till] add further consistency checkers (look at workshop on disproving theorems), 
- [Klaus] check consistency of DOLCE
- [Till] mark imported theorems as proved theorems, not axioms
- [Till, Klaus] use underscores for label disambiguation
- [Klaus] automatic installer for Hets
paper:
ECAI, KI, FOIS
report on practical experiences
stress modularization
]%

%%logic Modal

%%from DOLCE/LaTeX get display_annotations

%%modality empty


%%--------------------------------------------------------------------------------
%% CASL translation of DOLCEv2.1 (see WonderWeb Deliverable D18 v1.0)
%%--------------------------------------------------------------------------------
%% CASL simplifications:
%%
%% - No explicit parameters are used to specify the DOLCE theory: only simple 
%%   specifications and imports of these specifications using the "with" operator.
%% - No "Views" are still used. 
%%
%%---------------------------------------------------------------------------------
%% DOLCE simplifications:
%%
%% 0.All the axioms involving a quantification on leaves (or other specific sorts
%%   in the taxonomy) are introduced only considering the actual taxonomy of DOLCE.
%%   (see for example the axiom (Ad44) or (Ad51)).
%%   In the case of axioms (Ad75)-(Ad82), all the Meta-relations NEP, CM, AT, etc.
%%   are defined in this CASL version, but there are not leaves in the actual DOLCE
%%   taxonomy that instantiate these properties. 
%% 1.(Ad9) and (Ad15) are weakened assuming only the existence of binary sum
%%   and difference (instead of a General Extensional Mereology, we have only a 
%%   Classical Extensional Mereology).
%% 2.The predicate PRE (being present),defined in DOLCEv2.1 by means of the fusion
%%   is here introduced as a primitive relation.
%% 3.The "spatial inclusion" relation is not defined here (originally it needs fusion)
%%   therefore axioms (Ad19),(Ad28), and (Ad68) can not be expressed.
%%   In the case of (Ad68) I introduced a simply mutual specific dependence.
%% 4.The quality relation (qt) is simplified considering only "direct qualities"(dqt)
%%   Therefore axiom (Ad42) is not considered.
%% 5.Axioms (Ad56),(Ad57),(Ad63), and (Ad64) are instantiated only by temporal and
%%   spatial locations (TL and SL) and by Time intervals (T) and Space Regions (S),
%%   i.e. all the leaves present in dolce.
%% 6.(Ad74) not introduced (I'm unable to do the logical OR between specific and 
%%   Generic dependence.
%%-----------------------------------------------------------------------------------



%%------------------------
%% Taxonomy
%%------------------------

spec Taxonomy =  
    

sorts     
EDorPDorQ,PT,AB,Q,PD,ED,R

esorts
TR,T,PR,S,AR,TQ,TL,PQ,SL,AQ,PED,M,F,POB,APO,NAPO,NPED,NPOB,
MOB,SOB,ASO,SAG,SC,NASO,AS,EV,ACH,ACC,STV,ST,PRO

%%
sorts AR, PR, R, S, T, TR < AB; SAG, SC < ASO;
      APO, AS, ASO, F, M, MOB, NAPO, NASO, NPED, NPOB, PED, POB, SAG, SC,
      SOB < ED;
      ACC, ACH, APO, AQ, AS, ASO, ED, EV, F, M, MOB, NAPO, NASO, NPED,
      NPOB, PD, PED, POB, PQ, PRO, Q, SAG, SC, SL, SOB, ST, STV, TL,
      TQ < EDorPDorQ;
      ACC, ACH < EV; ASO, MOB, NASO, NPOB, SAG, SC, SOB < NPED;
      ASO, MOB, NASO, SAG, SC, SOB < NPOB;
      ACC, ACH, EV, PRO, ST, STV < PD; APO, F, M, NAPO, POB < PED;
      APO, NAPO < POB; SL < PQ; S < PR;
      AB, ACC, ACH, APO, AQ, AR, AS, ASO, ED, EDorPDorQ, EV, F, M, MOB,
      NAPO, NASO, NPED, NPOB, PD, PED, POB, PQ, PR, PRO, Q, R, S, SAG,
      SC, SL, SOB, ST, STV, T, TL, TQ, TR < PT;
      AQ, PQ, SL, TL, TQ < Q; AR, PR, S, T, TR < R;
      ASO, NASO, SAG, SC < SOB; PRO, ST < STV; TL < TQ; T < TR

end


%%------------------------
%% Partial_Order (po)
%%------------------------

spec Partial_Order =

esort s
pred Rel:s * s
forall x,y,z: s
. Rel(x,x) %(reflexivity)%
. Rel(x,y) /\ Rel(y,x) => x = y %(antisymmetry)%
. Rel(x,y) /\ Rel(y,z) => Rel(x,z) %(transitivity)%
end

%%-------------------
%% Ext_Partial_Order
%%-------------------

spec Ext_Partial_Order =
     Partial_Order

then
forall x,y: s
. not Rel(x,y) => exists z:s.(Rel(z,x) /\ not exists w:s.(Rel(w,z) /\ Rel(w,y))) %(extensionality)%
end

%%------------------------------
%% Ext_Overlap_or_Connection
%%------------------------------

spec Ext_Overlap_or_Connection =

esort s
pred OvCn:s*s
forall x,y,z:s
.OvCn(x,x) %(reflexivity)%
.OvCn(x,y) => OvCn(y,x) %(simmetry)%
.(OvCn(z,x) <=> OvCn(z,y)) => x=y %(extensionality)%
end


%%---------------------------
%% Strict_Partial_Order (spo)
%%---------------------------

%[
spec Strict_Partial_Order =

esort s
pred Rel: s * s
forall x,y,z: s
. Rel(x,y) => not Rel(y,x) 
. Rel(x,y) /\ Rel(y,z) => Rel(x,z) %(transitivity)%
end
]%
%%-----------------------------------
%% Classical_Extensional_Parhood (p)
%%----------------------------------

spec Classical_Extensional_Parthood =
     Partial_Order with Rel |-> P
then

preds
%% Proper Part
PP(x:s; y:s) <=> P(x, y) /\  not  P(y, x); %(Dd14)%

%% Overlap
Ov(x:s; y:s) <=> exists z:s.(P(z, x) /\  P(z, y)); %(Dd15)%

%% Atom
At(x:s) <=> not exists y:s.(PP(y, x)); %(Dd16)%

%%  Atomic Part
AtP(x:s; y:s) <=> P(x, y) /\  At(x); %(Dd17)%
 
%%  Binary Sum
Sum(z:s; x:s; y:s) <=> forall w:s.(Ov(w,z) <=> (Ov(w, x) \/  Ov(w, y)));

%%  Binary Difference
Dif(z:s; x:s; y:s) <=> forall w:s.(P(w,z) <=> (P(w, x) /\ not Ov(w, y)));

forall x,y:s
. not  P(x,y) => exists z:s.(Dif(z,x,y)) %(Extensionality+existence of the difference)%
. exists z:s.(Sum(z,x,y)) %(Existence of the sum)%
end


%%---------------
%% Time_Mereology
%%---------------
%% Time_Mereology is needed in oder to specify the properties of perdurants

spec Time_Mereology =
     Taxonomy 
and  Classical_Extensional_Parthood with s |-> T
end


%%--------------------------------
%% Unary_Temporal_Dissective (utd)
%%--------------------------------

spec Unary_Temporal_Dissective = 
     Time_Mereology 
then
esort s
pred Rel: s * T

forall x:s; t1,t2:T
.(Rel(x,t1) /\ P(t2,t1)) => Rel(x,t2)
end


%%-------------------
%% Being_Present
%%-------------------

spec Being_Present =
     Unary_Temporal_Dissective with s |-> EDorPDorQ, Rel |-> PRE

then 
esort ED,PD,Q < EDorPDorQ

forall x:EDorPDorQ
.exists t:T.(PRE(x,t))
end


%%-----------
%% Mereology
%%-----------

spec Mereology =
     Time_Mereology
and  Classical_Extensional_Parthood with s |-> PD
and  Classical_Extensional_Parthood with s |-> S
and  Classical_Extensional_Parthood with s |-> AR
then %implies
     forall x:S . P(x,x) %(reflex_th)%
end

%%----------------------------
%% Mereology_and_TemporalPart
%%----------------------------

spec Mereology_and_TemporalPart =
     Mereology
and  Being_Present

then

pred

%% Temporal Part
P_T(x:PD; y:PD) <=> P(x,y) /\ forall z:PD.((P(z,y) /\ forall t:T.(PRE(z,t) => PRE(x,t))) => P(z,x)) 
end

%%---------------------
%% Binary_Present (bpre)
%%---------------------

spec Binary_Present =
     Being_Present
then

esorts s1<EDorPDorQ; s2<EDorPDorQ
pred Rel: s1 * s2 * T

forall x1:s1; x2:s2; t:T
.Rel(x1,x2,t) => PRE(x1,t) /\ PRE(x2,t)
end 


%%---------------------------------
%% Binary_Temporal_Dissective (btd)
%%---------------------------------

spec Binary_Temporal_Dissective = 
     Time_Mereology
then

esort s1,s2
pred Rel: s1 * s2 * T 

forall x1:s1; x2:s2; t1,t2:T
.(Rel(x1,x2,t1) /\ P(t2,t1)) => Rel(x1,x2,t2)
end


%%-----------------------------
%% Temporary_Partial_Order (tpo)
%%-----------------------------

spec Temporary_Partial_Order =
     Being_Present
then

esorts s<EDorPDorQ
pred Rel: s * s * T

forall x,y,z:s; t:T
.PRE(x,t) => Rel(x,x,t)
.Rel(x,y,t) /\ Rel(y,z,t) => Rel(x,z,t)
end 


%%-------------------------------------
%% Temporary_Strict_Partial_Order (tspo)
%%-------------------------------------

spec Temporary_Strict_Partial_Order =
%[     Taxonomy

then
]%     
esorts s<EDorPDorQ;T
pred Rel: s * s * T

forall x,y,z:s; t:T
.Rel(x,y,t) => not Rel(y,x,t) 
.Rel(x,y,t) /\ Rel(y,z,t) => Rel(x,z,t)
end 


%%-----------------------
%% Temporary_Parthood (tp)
%%-----------------------

spec Temporary_Parthood =
     Temporary_Partial_Order with Rel |-> tP
and  Binary_Temporal_Dissective with s1 |-> s, s2 |-> s, Rel |-> tP
and  Binary_Present with s1 |-> s, s2 |-> s, Rel |-> tP

then

preds
%% Temporary Proper Part
tPP(x:s; y:s; t:T) <=> tP(x,y,t) /\  not tP(y,x,t);

%% Temporary Overlap
tOv(x:s; y:s; t:T) <=> exists z:s.(tP(z,x,t) /\ tP(z,y,t)); 

%% Temporary Atom
%% At(x:s) <=> not exists y:s.(PP(y, x)); %(Dd16)%

%% Temporary Atomic Part
%% AtP(x:s; y:s) <=> P(x, y) /\  At(x); %(Dd17)%
 
%% Temporary Binary Sum
tSum(z:s; x:s; y:s) <=> forall w:s;t:T.(tOv(w,z,t) <=> (tOv(w,x,t) \/  tOv(w,y,t)));

%% Temporary Binary Difference
tDif(z:s; x:s; y:s) <=> forall w:s;t:T.(tP(w,z,t) <=> (tP(w,x,t) /\ not tOv(w,y,t)));

forall x,y:s; t:T
.PRE(x,t) /\ PRE(y,t) /\ not tP(x,y,t) => exists z:s.(tP(z,x,t) /\ not tOv(z,y,t)) 
.exists z:s.(tSum(z,x,y)) %(Existence of the sum)%

%% ----------------------------------------------------------------------------------------------------
%% The case of difference for temporary parthood is more complex.... I need to control in Peter Simons
%% .not tP(x,y) => exists z:s.(Dif(z,x,y)) %(Extensionality+existence of the difference)%
%% ----------------------------------------------------------------------------------------------------
end  


%%---------------------
%% Temporary_Mereology
%%---------------------

spec Temporary_Mereology =
     Temporary_Parthood with s |-> PED
and  Temporary_Parthood with s |-> NPED
end


%%-----------------------
%% Constitution_Spec (k)
%%----------------------

spec Constitution_Spec =
     Binary_Temporal_Dissective with s1 |-> s, s2 |-> s, Rel |-> K
and  Binary_Present with s1 |-> s, s2 |-> s, Rel |-> K
and  Temporary_Strict_Partial_Order with  Rel |-> K
and  Temporary_Parthood 

then

forall x,y,y1:s; t:T
.K(x,y,t) /\ tP(y1,y,t) => exists x1:s.(tP(x1,x,t) /\ K(x1,y1,t))
then %implies
     forall x:s; t: T
     . not K(x,x,t)       %(Td1)%
end


%%-----------------------------------------
%% Constantly_Generically_Constituted (cgc)
%%-----------------------------------------

spec Constantly_Generically_Constituted =
     Constitution_Spec

then

esorts s1 < s; s2 < s

forall x:s1
.exists t:T.(PRE(x,t))

forall x:s1; t:T
.At(t) /\ PRE(x,t) => exists y:s2.K(y,x,t)
end


%%--------------
%% Constitution
%%--------------

spec Constitution =
     Constitution_Spec with s |-> PED
and  Constitution_Spec with s |-> NPED
and  Constitution_Spec with s |-> PD
and  Constantly_Generically_Constituted with s |-> PED, s1 |-> NAPO, s2 |-> M
and  Constantly_Generically_Constituted with s |-> PED, s1 |-> APO, s2 |-> NAPO
and  Constantly_Generically_Constituted with s |-> NPED, s1 |-> SC, s2 |-> SAG
end


%%----------------
%% Participation
%%----------------

spec Participation =
     Binary_Temporal_Dissective with s1 |-> ED, s2 |-> PD, Rel |-> PC
and  Binary_Present with s1 |-> ED, s2 |-> PD,  Rel |-> PC

then
forall y:PD; t:T
.PRE(y,t) => exists x:ED.(PC(x,y,t))

forall x:ED
.exists y:PD;t:T.(PC(x,y,t)) 

then %implies 
     forall x:ED;y:PD;t:T
     . PC(x,y,t) => PRE(x,t) /\ PRE(y,t) %(T33)%
     %% the following theorem must be thought of again:
     %% if it is added in this form, Participation is inconsistent! 
     . (PRE(x,t) => exists y : PD . PC(x,y,t)) %(T35)% 
end     


%%--------------------------
%% Direct_Quality_Spec (dqt)
%%-------------------------

spec Direct_Quality_Spec =

esorts s1, s2
preds dqt : s1 * s2
     
forall x:s1; y1,y2:s2
.dqt(x,y1) /\ dqt(x,y2) => y1 = y2

forall x1,x2:s1; y:s2
.dqt(x1,y) /\ dqt(x2,y) => x1 = x2

forall x:s1
.exists! y:s2.dqt(x,y)
end
%% the first two axioms can be introduced as two separated specification for 
%% functions and inverse functions


%%----------------
%% Direct_Quality
%%----------------

spec Direct_Quality =
%[     Taxonomy
and ]% Direct_Quality_Spec with s1 |-> TQ, s2 |-> PD
and  Direct_Quality_Spec with s1 |-> PQ, s2 |-> PED
and  Direct_Quality_Spec with s1 |-> AQ, s2 |-> NPED

then
esorts TL < TQ; SL < PQ
forall y:PD
.exists x:TL.dqt(x,y)

forall y:PED
.exists x:SL.dqt(x,y)
end


%%---------------------------
%% Immediate_Quale_Spec (ql)
%%---------------------------

spec Immediate_Quale_Spec =

esorts s1, s2
preds ql : s1 * s2
     
forall x1,x2:s1; y:s2
.ql(x1,y) /\ ql(x2,y) => x1 = x2

forall y:s2
.exists x:s1.ql(x,y)
end


%%-----------------
%% Immediate_Quale
%%-----------------

spec Immediate_Quale =
%[     Taxonomy
and]%  Immediate_Quale_Spec with s1 |-> T, s2 |-> TL
and  Immediate_Quale_Spec with s1 |-> TR, s2 |-> TQ
end 
   

%%---------------------------
%% Temporary_Quale_Spec (tql)
%%---------------------------

spec Temporary_Quale_Spec =
     Being_Present
and  Binary_Temporal_Dissective with Rel |-> tql

then

esorts s2<EDorPDorQ

forall y:s2; t:T
.PRE(y,t) => exists x:s1.tql(x,y,t)

forall x:s1; y:s2; t:T
.tql(x,y,t) => PRE(y,t)
end


%%-------------------
%% Temporary_Quale
%%-------------------

spec Temporary_Quale =
     Temporary_Quale_Spec with s1 |-> PR, s2 |-> PQ
and  Temporary_Quale_Spec with s1 |-> AR, s2 |-> AQ
and  Temporary_Quale_Spec with s1 |-> S, s2 |-> SL
end


%%-------------------------
%% Specific_Dependence (sd)
%%-------------------------

spec Specific_Dependence =
     Being_Present

then

esorts s1<EDorPDorQ; s2<EDorPDorQ
preds
%% Specific Dependence
SD(x:s1; y:s2) <=> (exists t:T.(PRE(x,t))) /\ 
                   (forall t:T.(PRE(x,t) => PRE(y,t)));

forall x:s1
.exists y:s2.SD(x,y)
end


%%---------------------------------
%% Mutual_Specific_Dependence (msd)
%%---------------------------------

spec Mutual_Specific_Dependence =
     Specific_Dependence with s1 |-> s1, s2 |-> s2 
and  Specific_Dependence with s1 |-> s2, s2 |-> s1
end


%%----------------------------------
%% OneSide_Specific_Dependence (osd)
%%----------------------------------

spec OneSide_Specific_Dependence =
     Specific_Dependence

then

forall y:s2; t:T
.not PRE(y,t) \/ exists x:s1.(PRE(y,t) /\ not PRE(x,t))
%% DA CONTROLLARE, BISOGNA FARE LA NEGAZIONE PER BENE
end


%%------------------------
%% Generic_Dependence (gd)
%%------------------------

spec Generic_Dependence =
     Being_Present

then

esort s1 < EDorPDorQ; s2 < EDorPDorQ

forall x:s1
.exists t:T.PRE(x,t)

forall x:s1; t:T
.At(t) /\ PRE(x,t) => exists y:s2.PRE(y,t)
end

%%--------------------------------
%% Mutual_Generic_Dependence (mgd)
%%--------------------------------

spec Mutual_Generic_Dependence =
     Generic_Dependence with s1 |-> s1, s2 |-> s2 
and  Generic_Dependence with s1 |-> s2, s2 |-> s1
end


%%---------------------------------
%% OneSide_Generic_Dependence (ogd)
%%---------------------------------

spec OneSide_Generic_Dependence =
     Generic_Dependence with s1 |-> s1, s2 |-> s2

then

forall y:s2; t:T
.not PRE(y,t) \/ exists x:s1.(PRE(y,t) /\ not PRE(x,t))
%% DA CONTROLLARE, BISOGNA FARE LA NEGAZIONE PER BENE
end


%%------------
%% Dependence
%%------------

spec Dependence =
     Mutual_Specific_Dependence with s1 |-> TQ, s2 |-> PD
and  Mutual_Specific_Dependence with s1 |-> PQ, s2 |-> PED
and  Mutual_Specific_Dependence with s1 |-> AQ, s2 |-> NPED
and  OneSide_Specific_Dependence with s1 |-> MOB, s2 |-> APO
and  OneSide_Generic_Dependence with s1 |-> F, s2 |-> NAPO
and  OneSide_Generic_Dependence with s1 |-> SAG, s2 |-> APO
and  OneSide_Generic_Dependence with s1 |-> NASO, s2 |-> SC
end


%%-------------------------
%% Strongly_Non_Empty (nep)
%%-------------------------

spec Strongly_Non_Empty =
     Mereology

then

esort s<PD;

forall z:s
.exists x,y:s.(not P(x,y) /\ not P(y,x))
end

%%-----------------
%% Cumulative (cum)
%%-----------------

spec Cumulative =
     Mereology

then

esort s<PD
forall x,y:s
.exists z:s.Sum(z,x,y)
end


%%-----------------------
%% Anti_Cumulative (acum)
%%-----------------------

spec Anti_Cumulative =
     Mereology

then

esort s<PD
forall x,y:s
.exists z:PD.(Sum(z,x,y) /\ not z in s)
end


%%-------------------
%% Homeomerous (hom)
%%-------------------

spec Homeomerous =
     Mereology_and_TemporalPart

then

esort s<PD
forall x:s; y:PD
.P_T(y,x) => y in s
end


%%------------------------
%% Anti_Homeomerous (ahom)
%%------------------------

spec Anti_Homeomerous =
     Mereology_and_TemporalPart

then

esort s<PD
forall x:s
.exists y:PD.(P_T(y,x) /\ not y in s)
end


%%-------------
%% Atomic (at)
%%-------------

spec Atomic =
     Mereology

then

esort s<PD
forall x:s
.At(x)
end


%%------------------
%% Anti_Atomic (aat)
%%------------------

spec Anti_Atomic =
     Mereology

then

esort s<PD
forall x:s
.not At(x)
end


%[
%%--------------------------------
%% Conditions_On_Perdurant_Leaves
%%--------------------------------

spec Conditions_On_Perdurant_Leaves =     
esort s
%% rigth now there are no perdurant's leaves, therefore there are no conditions on these leaves
%% in any case, wa can express dolce's axioms (Ad79)-(ad82) using the specifications introduced before
end
]%


%%-------
%% Dolce
%%-------

spec PreDolce =
     Mereology_and_TemporalPart
and  Temporary_Mereology
and  Participation
and  Constitution
and  Dependence
and  Direct_Quality
and  Temporary_Quale
and  Immediate_Quale
end

spec Dolce =
     PreDolce
and
     Taxonomy
end

%[
view Td2 : Generic_Dependence to Constantly_Generically_Constituted  
end

view T31 : { Constantly_Generically_Constituted with s1 |-> phi, s2 |-> chi }
        to {    Constantly_Generically_Constituted with s1 |-> phi, s2 |-> psi
            and Constantly_Generically_Constituted with s1 |-> psi, s2 |-> chi }
end
          
spec CGC[esort s1][esort s2] =
     Constantly_Generically_Constituted
end

view T31a : { CGC[esort phi][esort chi] }
        to {    CGC[esort phi][esort psi]
            and CGC[esort psi][esort chi] }
end
]%

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------

spec Classical_Extensional_Parthood_1_model =
  free type s ::= a
 pred P:s*s
 . P(a,a)
  preds
  %% Proper Part
  PP(x:s; y:s) <=> P(x, y) /\  not  P(y, x); %(Dd14)%

  %% Overlap
  Ov(x:s; y:s) <=> exists z:s.(P(z, x) /\  P(z, y)); %(Dd15)%

  %% Atom
  At(x:s) <=> not exists y:s.(PP(y, x)); %(Dd16)%

  %%  Atomic Part
  AtP(x:s; y:s) <=> P(x, y) /\  At(x); %(Dd17)%
   
  %%  Binary Sum
  Sum(z:s; x:s; y:s) <=> forall w:s.(Ov(w,z) <=> (Ov(w, x) \/  Ov(w, y)));
  
  %%  Binary Difference
  Dif(z:s; x:s; y:s) <=> forall w:s.(P(w,z) <=> (P(w, x) /\ not Ov(w, y)));
end

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------

spec Classical_Extensional_Parthood_4_model =
  free type s ::= a | b | c | d | ab | ac | ad | bc | bd | cd | 
                  abc | abd | acd | bcd | abcd
 pred P:s*s
 . P(d,d)
 . not P(d,c)
 . P(d,cd)
 . not P(d,b)
 . P(d,bd)
 . not P(d,bc)
 . P(d,bcd)
 . not P(d,a)
 . P(d,ad)
 . not P(d,ac)
 . P(d,acd)
 . not P(d,ab)
 . P(d,abd)
 . not P(d,abc)
 . P(d,abcd)
 . not P(c,d)
 . P(c,c)
 . P(c,cd)
 . not P(c,b)
 . not P(c,bd)
 . P(c,bc)
 . P(c,bcd)
 . not P(c,a)
 . not P(c,ad)
 . P(c,ac)
 . P(c,acd)
 . not P(c,ab)
 . not P(c,abd)
 . P(c,abc)
 . P(c,abcd)
 . not P(cd,d)
 . not P(cd,c)
 . P(cd,cd)
 . not P(cd,b)
 . not P(cd,bd)
 . not P(cd,bc)
 . P(cd,bcd)
 . not P(cd,a)
 . not P(cd,ad)
 . not P(cd,ac)
 . P(cd,acd)
 . not P(cd,ab)
 . not P(cd,abd)
 . not P(cd,abc)
 . P(cd,abcd)
 . not P(b,d)
 . not P(b,c)
 . not P(b,cd)
 . P(b,b)
 . P(b,bd)
 . P(b,bc)
 . P(b,bcd)
 . not P(b,a)
 . not P(b,ad)
 . not P(b,ac)
 . not P(b,acd)
 . P(b,ab)
 . P(b,abd)
 . P(b,abc)
 . P(b,abcd)
 . not P(bd,d)
 . not P(bd,c)
 . not P(bd,cd)
 . not P(bd,b)
 . P(bd,bd)
 . not P(bd,bc)
 . P(bd,bcd)
 . not P(bd,a)
 . not P(bd,ad)
 . not P(bd,ac)
 . not P(bd,acd)
 . not P(bd,ab)
 . P(bd,abd)
 . not P(bd,abc)
 . P(bd,abcd)
 . not P(bc,d)
 . not P(bc,c)
 . not P(bc,cd)
 . not P(bc,b)
 . not P(bc,bd)
 . P(bc,bc)
 . P(bc,bcd)
 . not P(bc,a)
 . not P(bc,ad)
 . not P(bc,ac)
 . not P(bc,acd)
 . not P(bc,ab)
 . not P(bc,abd)
 . P(bc,abc)
 . P(bc,abcd)
 . not P(bcd,d)
 . not P(bcd,c)
 . not P(bcd,cd)
 . not P(bcd,b)
 . not P(bcd,bd)
 . not P(bcd,bc)
 . P(bcd,bcd)
 . not P(bcd,a)
 . not P(bcd,ad)
 . not P(bcd,ac)
 . not P(bcd,acd)
 . not P(bcd,ab)
 . not P(bcd,abd)
 . not P(bcd,abc)
 . P(bcd,abcd)
 . not P(a,d)
 . not P(a,c)
 . not P(a,cd)
 . not P(a,b)
 . not P(a,bd)
 . not P(a,bc)
 . not P(a,bcd)
 . P(a,a)
 . P(a,ad)
 . P(a,ac)
 . P(a,acd)
 . P(a,ab)
 . P(a,abd)
 . P(a,abc)
 . P(a,abcd)
 . not P(ad,d)
 . not P(ad,c)
 . not P(ad,cd)
 . not P(ad,b)
 . not P(ad,bd)
 . not P(ad,bc)
 . not P(ad,bcd)
 . not P(ad,a)
 . P(ad,ad)
 . not P(ad,ac)
 . P(ad,acd)
 . not P(ad,ab)
 . P(ad,abd)
 . not P(ad,abc)
 . P(ad,abcd)
 . not P(ac,d)
 . not P(ac,c)
 . not P(ac,cd)
 . not P(ac,b)
 . not P(ac,bd)
 . not P(ac,bc)
 . not P(ac,bcd)
 . not P(ac,a)
 . not P(ac,ad)
 . P(ac,ac)
 . P(ac,acd)
 . not P(ac,ab)
 . not P(ac,abd)
 . P(ac,abc)
 . P(ac,abcd)
 . not P(acd,d)
 . not P(acd,c)
 . not P(acd,cd)
 . not P(acd,b)
 . not P(acd,bd)
 . not P(acd,bc)
 . not P(acd,bcd)
 . not P(acd,a)
 . not P(acd,ad)
 . not P(acd,ac)
 . P(acd,acd)
 . not P(acd,ab)
 . not P(acd,abd)
 . not P(acd,abc)
 . P(acd,abcd)
 . not P(ab,d)
 . not P(ab,c)
 . not P(ab,cd)
 . not P(ab,b)
 . not P(ab,bd)
 . not P(ab,bc)
 . not P(ab,bcd)
 . not P(ab,a)
 . not P(ab,ad)
 . not P(ab,ac)
 . not P(ab,acd)
 . P(ab,ab)
 . P(ab,abd)
 . P(ab,abc)
 . P(ab,abcd)
 . not P(abd,d)
 . not P(abd,c)
 . not P(abd,cd)
 . not P(abd,b)
 . not P(abd,bd)
 . not P(abd,bc)
 . not P(abd,bcd)
 . not P(abd,a)
 . not P(abd,ad)
 . not P(abd,ac)
 . not P(abd,acd)
 . not P(abd,ab)
 . P(abd,abd)
 . not P(abd,abc)
 . P(abd,abcd)
 . not P(abc,d)
 . not P(abc,c)
 . not P(abc,cd)
 . not P(abc,b)
 . not P(abc,bd)
 . not P(abc,bc)
 . not P(abc,bcd)
 . not P(abc,a)
 . not P(abc,ad)
 . not P(abc,ac)
 . not P(abc,acd)
 . not P(abc,ab)
 . not P(abc,abd)
 . P(abc,abc)
 . P(abc,abcd)
 . not P(abcd,d)
 . not P(abcd,c)
 . not P(abcd,cd)
 . not P(abcd,b)
 . not P(abcd,bd)
 . not P(abcd,bc)
 . not P(abcd,bcd)
 . not P(abcd,a)
 . not P(abcd,ad)
 . not P(abcd,ac)
 . not P(abcd,acd)
 . not P(abcd,ab)
 . not P(abcd,abd)
 . not P(abcd,abc)
 . P(abcd,abcd)
  preds
  %% Proper Part
  PP(x:s; y:s) <=> P(x, y) /\  not  P(y, x); %(Dd14)%

  %% Overlap
  Ov(x:s; y:s) <=> exists z:s.(P(z, x) /\  P(z, y)); %(Dd15)%

  %% Atom
  At(x:s) <=> not exists y:s.(PP(y, x)); %(Dd16)%

  %%  Atomic Part
  AtP(x:s; y:s) <=> P(x, y) /\  At(x); %(Dd17)%
   
  %%  Binary Sum
  Sum(z:s; x:s; y:s) <=> forall w:s.(Ov(w,z) <=> (Ov(w, x) \/  Ov(w, y)));
  
  %%  Binary Difference
  Dif(z:s; x:s; y:s) <=> forall w:s.(P(w,z) <=> (P(w, x) /\ not Ov(w, y)));
end

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------

spec sp = {}

%%----------------------------------------------------------------------------

%%--------------------------------
%%--------------------------------

spec DolceModel =
%%
sorts     
EDorPDorQ,PT,AB,Q,PD,ED,R

esorts
TR,T,PR,S,AR,TQ,TL,PQ,SL,AQ,PED,M,F,POB,APO,NAPO,NPED,NPOB,
MOB,SOB,ASO,SAG,SC,NASO,AS,EV,ACH,ACC,STV,ST,PRO

%%----------------------------------- instantiated leaves 

		free type   TL ::= tl; 
		free type   SL ::= sl;
		
		free type   ST ::= st;
		
		free type   M ::= ma;

		free type   S ::= sp;
		free type   T ::= ti;
		
%%----------------------------------

%%---------------------------------- declare empty leaves					

forall x : AQ . false
forall x : PRO . false
forall x : ACH . false
forall x : ACC . false
forall x : NAPO . false
forall x : APO . false
forall x : F . false
forall x : SC . false
forall x : SAG . false
forall x : NASO . false
forall x : MOB . false
forall x : AS . false
forall x : AR . false

forall x : EV . false
forall x : POB . false
forall x : ASO . false
forall x : SOB . false
forall x : NPOB . false
forall x : NPED . false

%%-------------------------------- Generated Sorts

free type   TQ ::= tl;
free type   PQ ::= sl;

free type   Q ::= tl | sl;
	

free type   STV ::= st;

free type   PD ::= st;
			
free type   PED ::= ma;
			
free type   ED ::= ma;
			
free type   PR ::= sp;
free type   TR ::= ti;
free type   R ::= sp | ti;	
			
%% free type   EDorPDorQ ::= sort Q | sort PD | sort ED;
%% . forall x : EDorPDorQ . x = tl \/ x = sl \/ x = st \/ x = ma;

free type   EDorPDorQ ::= tl | sl | st | ma;
 
free type   AB ::= sp | ti;
			
free type   PT ::= tl | sl | st | ma | sp | ti;

%%
sorts AR, PR, R, S, T, TR < AB; SAG, SC < ASO;
      APO, AS, ASO, F, M, MOB, NAPO, NASO, NPED, NPOB, PED, POB, SAG, SC,
      SOB < ED;
      ACC, ACH, APO, AQ, AS, ASO, ED, EV, F, M, MOB, NAPO, NASO, NPED,
      NPOB, PD, PED, POB, PQ, PRO, Q, SAG, SC, SL, SOB, ST, STV, TL,
      TQ < EDorPDorQ;
      ACC, ACH < EV; ASO, MOB, NASO, NPOB, SAG, SC, SOB < NPED;
      ASO, MOB, NASO, SAG, SC, SOB < NPOB;
      ACC, ACH, EV, PRO, ST, STV < PD; APO, F, M, NAPO, POB < PED;
      APO, NAPO < POB; SL < PQ; S < PR;
      AB, ACC, ACH, APO, AQ, AR, AS, ASO, ED, EDorPDorQ, EV, F, M, MOB,
      NAPO, NASO, NPED, NPOB, PD, PED, POB, PQ, PR, PRO, Q, R, S, SAG,
      SC, SL, SOB, ST, STV, T, TL, TQ, TR < PT;
      AQ, PQ, SL, TL, TQ < Q; AR, PR, S, T, TR < R;
      ASO, NASO, SAG, SC < SOB; PRO, ST < STV; TL < TQ; T < TR

%%-------------------------------------------

pred At : AR
pred At : PD
pred At : S
pred At : T
pred AtP : AR * AR
pred AtP : PD * PD
pred AtP : S * S
pred AtP : T * T
pred Dif : AR * AR * AR
pred Dif : PD * PD * PD
pred Dif : S * S * S
pred Dif : T * T * T
pred K : NPED * NPED * T
pred K : PD * PD * T
pred K : PED * PED * T
pred Ov : AR * AR
pred Ov : PD * PD
pred Ov : S * S
pred Ov : T * T
pred P : AR * AR
pred P : PD * PD
pred P : S * S
pred P : T * T
pred PC : ED * PD * T
pred PP : AR * AR
pred PP : PD * PD
pred PP : S * S
pred PP : T * T
pred PRE : EDorPDorQ * T
pred P_T : PD * PD
pred SD : AQ * NPED
pred SD : MOB * APO
pred SD : NPED * AQ
pred SD : PD * TQ
pred SD : PED * PQ
pred SD : PQ * PED
pred SD : TQ * PD
pred Sum : AR * AR * AR
pred Sum : PD * PD * PD
pred Sum : S * S * S
pred Sum : T * T * T
pred dqt : AQ * NPED
pred dqt : PQ * PED
pred dqt : TQ * PD
pred ql : T * TL
pred ql : TR * TQ
pred tDif : NPED * NPED * NPED
pred tDif : PD * PD * PD
pred tDif : PED * PED * PED
pred tOv : NPED * NPED * T
pred tOv : PD * PD * T
pred tOv : PED * PED * T
pred tP : NPED * NPED * T
pred tP : PD * PD * T
pred tP : PED * PED * T
pred tPP : NPED * NPED * T
pred tPP : PD * PD * T
pred tPP : PED * PED * T
pred tSum : NPED * NPED * NPED
pred tSum : PD * PD * PD
pred tSum : PED * PED * PED
pred tql : AR * AQ * T
pred tql : PR * PQ * T
pred tql : S * SL * T


%%--------------- 6 Point Model -------------
 
%% Parthood

. P(ti,ti)
. P(sp,sp)
. tP((op ma:PED),(op ma:PED),ti)
. tP((op st:PD),(op st:PD),ti)

. P((op st:PD),(op st:PD))

%% Being Present

. PRE((op ma:EDorPDorQ),ti)
. PRE((op st:EDorPDorQ),ti)
. PRE((op tl:EDorPDorQ),ti)
. PRE((op sl:EDorPDorQ),ti)

. PRE((op ma:PED),ti)
. PRE((op ma:ED),ti)
. PRE((op st:PD),ti)

%% Participation

. PC((op ma:ED),(op st:PD),ti)

%% Quality

. dqt(tl,st)

. dqt((op sl:SL),(op ma:PED))
. dqt((op sl:PQ),(op ma:PED))

%% Quale

. ql(ti,tl)
. tql(sp,sl,ti)

%% Specific Dependence

. SD((op tl:TQ), (op st:PD))

%% Constitution: trivialise K

 . forall x,y : NPED; z :T . not K(x,y,z)
 . forall x,y : PED; z :T . not K(x,y,z)
 . forall x,y : PD; z :T . not K(x,y,z) 

%%----------------- Definitorial Axioms----------
%%-----------------------------------------------
%%-----------------------------------------------

%%--preds PP(x,y:T) <=> ...

forall x : T; y : T . PP(x, y) <=> P(x, y) /\ not P(y, x) 						%(Dd14)% 

forall x : T; y : T
. Ov(x, y) <=> exists z : T . P(z, x) /\ P(z, y)   						        %(Dd15)%

forall x : T . At(x) <=> not exists y : T . PP(y, x)  							%(Dd16)%

forall x : T; y : T . AtP(x, y) <=> P(x, y) /\ At(x)						    %(Dd17)%

forall z : T; x : T; y : T
. Sum(z, x, y) <=> forall w : T . Ov(w, z) <=> Ov(w, x) \/ Ov(w, y)             %(Ax5)%

forall z : T; x : T; y : T
. Dif(z, x, y)
  <=> forall w : T . P(w, z) <=> P(w, x) /\ not Ov(w, y)   						%(Ax6)%

forall x : PD; y : PD . PP(x, y) <=> P(x, y) /\ not P(y, x)		                %(Dd14_2)%

forall x : PD; y : PD
. Ov(x, y) <=> exists z : PD . P(z, x) /\ P(z, y)       						%(Dd15_2)%

forall x : PD . At(x) <=> not exists y : PD . PP(y, x) 							%(Dd16_2)%

forall x : PD; y : PD . AtP(x, y) <=> P(x, y) /\ At(x) 							%(Dd17_2)%

forall z : PD; x : PD; y : PD
. Sum(z, x, y)
  <=> forall w : PD . Ov(w, z) <=> Ov(w, x) \/ Ov(w, y)  						%(Ax5_2)%

forall z : PD; x : PD; y : PD
. Dif(z, x, y)
  <=> forall w : PD . P(w, z) <=> P(w, x) /\ not Ov(w, y) 	                    %(Ax6_2)%


%%-------------------------------------------------------


forall x : S; y : S . PP(x, y) <=> P(x, y) /\ not P(y, x) 				        %(Dd14_2_1)%

forall x : S; y : S
. Ov(x, y) <=> exists z : S . P(z, x) /\ P(z, y)  							    %(Dd15_2_1)%

forall x : S . At(x) <=> not exists y : S . PP(y, x) 							%(Dd16_2_1)%

forall x : S; y : S . AtP(x, y) <=> P(x, y) /\ At(x) 							%(Dd17_2_1)%

forall z : S; x : S; y : S
. Sum(z, x, y) <=> forall w : S . Ov(w, z) <=> Ov(w, x) \/ Ov(w, y)	            %(Ax5_2_1)%

forall z : S; x : S; y : S
. Dif(z, x, y)
  <=> forall w : S . P(w, z) <=> P(w, x) /\ not Ov(w, y)                        %(Ax6_2_1)%

%%-------------------------------------------------------

forall x : AR; y : AR . PP(x, y) <=> P(x, y) /\ not P(y, x)
                                                        						%(Dd14_1)%

forall x : AR; y : AR
. Ov(x, y) <=> exists z : AR . P(z, x) /\ P(z, y)       						%(Dd15_1)%

forall x : AR . At(x) <=> not exists y : AR . PP(y, x) 							%(Dd16_1)%

forall x : AR; y : AR . AtP(x, y) <=> P(x, y) /\ At(x) 							%(Dd17_1)%

forall z : AR; x : AR; y : AR
. Sum(z, x, y)
  <=> forall w : AR . Ov(w, z) <=> Ov(w, x) \/ Ov(w, y)  						%(Ax5_1)%

forall z : AR; x : AR; y : AR
. Dif(z, x, y)
  <=> forall w : AR . P(w, z) <=> P(w, x) /\ not Ov(w, y)                       %(Ax6_1)%

%%-------------------------------------------------------

forall x : PD; y : PD
. P_T(x, y)
  <=> P(x, y)
      /\ forall z : PD
         . (P(z, y) /\ forall t : T . PRE(z, t) => PRE(x, t)) => P(z, x) 		%(Ax1_2)%


forall x : PED; y : PED; t : T
. tPP(x, y, t) <=> tP(x, y, t) /\ not tP(y, x, t)       						%(Ax1_4)%

forall x : PED; y : PED; t : T
. tOv(x, y, t) <=> exists z : PED . tP(z, x, t) /\ tP(z, y, t)	                %(Ax2_1)%

forall z : PED; x : PED; y : PED
. tSum(z, x, y)
  <=> forall w : PED; t : T
      . tOv(w, z, t) <=> tOv(w, x, t) \/ tOv(w, y, t)     						%(Ax3)%

forall z : PED; x : PED; y : PED
. tDif(z, x, y)
  <=> forall w : PED; t : T
      . tP(w, z, t) <=> tP(w, x, t) \/ not tOv(w, y, t)    						%(Ax4)%


forall x : NPED; y : NPED; t : T
. tPP(x, y, t) <=> tP(x, y, t) /\ not tP(y, x, t)      %(Ax1_4_1)%

forall x : NPED; y : NPED; t : T
. tOv(x, y, t) <=> exists z : NPED . tP(z, x, t) /\ tP(z, y, t)
                                                       %(Ax2_1_1)%

forall z : NPED; x : NPED; y : NPED
. tSum(z, x, y)
  <=> forall w : NPED; t : T
      . tOv(w, z, t) <=> tOv(w, x, t) \/ tOv(w, y, t)    %(Ax3_1)%

forall z : NPED; x : NPED; y : NPED
. tDif(z, x, y)
  <=> forall w : NPED; t : T
      . tP(w, z, t) <=> tP(w, x, t) \/ not tOv(w, y, t)  %(Ax4_1)%


forall x : PD; y : PD; t : T
. tPP(x, y, t) <=> tP(x, y, t) /\ not tP(y, x, t)      %(Ax1_4_2)%

forall x : PD; y : PD; t : T
. tOv(x, y, t) <=> exists z : PD . tP(z, x, t) /\ tP(z, y, t)
                                                       %(Ax2_1_2)%

forall z : PD; x : PD; y : PD
. tSum(z, x, y)
  <=> forall w : PD; t : T
      . tOv(w, z, t) <=> tOv(w, x, t) \/ tOv(w, y, t)    %(Ax3_2)%

forall z : PD; x : PD; y : PD
. tDif(z, x, y)
  <=> forall w : PD; t : T
      . tP(w, z, t) <=> tP(w, x, t) \/ not tOv(w, y, t)  %(Ax4_2)%


forall x : TQ; y : PD
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)         %(Ax1_2_5)%

forall x : PD; y : TQ
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)       %(Ax1_2_1_4)%


forall x : PQ; y : PED
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)       %(Ax1_2_3_1)%


forall x : PED; y : PQ
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)     %(Ax1_2_1_3_1)%


forall x : AQ; y : NPED
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)         %(Ax1_2_2)%


forall x : NPED; y : AQ
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)     %(Ax1_2_1_2_1)%

forall x : MOB; y : APO
. SD(x, y)
  <=> (exists t : T . PRE(x, t))
      /\ forall t : T . PRE(x, t) => PRE(y, t)       %(Ax1_2_2_1)%



%%---
forall x : PT . not (x in AB /\ x in EDorPDorQ)
                                %(ga_disjoint_sorts_AB_EDorPDorQ)%

%% free
generated type PT ::= sort AB | sort EDorPDorQ 


forall x : EDorPDorQ . not (x in ED /\ x in PD)
                                       %(ga_disjoint_sorts_ED_PD)%

forall x : EDorPDorQ . not (x in ED /\ x in Q)
                                        %(ga_disjoint_sorts_ED_Q)%

forall x : EDorPDorQ . not (x in PD /\ x in Q)
                                        %(ga_disjoint_sorts_PD_Q)%

%% free
generated type EDorPDorQ ::= sort ED | sort PD | sort Q

forall x : ED . not (x in PED /\ x in NPED)
                                    %(ga_disjoint_sorts_PED_NPED)%

forall x : ED . not (x in PED /\ x in AS)
                                      %(ga_disjoint_sorts_PED_AS)%

forall x : ED . not (x in NPED /\ x in AS)
                                     %(ga_disjoint_sorts_NPED_AS)%

%% free
generated type  ED ::= sort AS | sort NPED | sort PED

forall x : PD . not (x in EV /\ x in STV)
                                      %(ga_disjoint_sorts_EV_STV)%

%% free
generated type  PD ::= sort EV | sort STV

forall x : Q . not (x in TQ /\ x in PQ) %(ga_disjoint_sorts_TQ_PQ)%

forall x : Q . not (x in TQ /\ x in AQ) %(ga_disjoint_sorts_TQ_AQ)%

forall x : Q . not (x in PQ /\ x in AQ) %(ga_disjoint_sorts_PQ_AQ)%

%% free
generated type  Q ::= sort AQ | sort PQ | sort TQ

forall x : R . not (x in TR /\ x in PR) %(ga_disjoint_sorts_TR_PR)%

forall x : R . not (x in TR /\ x in AR) %(ga_disjoint_sorts_TR_AR)%

forall x : R . not (x in PR /\ x in AR) %(ga_disjoint_sorts_PR_AR)%

%% free
generated type  R ::= sort AR| sort  PR | sort TR

forall x : PED . not (x in M /\ x in F) %(ga_disjoint_sorts_M_F)%

forall x : PED . not (x in M /\ x in POB)
                                       %(ga_disjoint_sorts_M_POB)%

forall x : PED . not (x in F /\ x in POB)
                                       %(ga_disjoint_sorts_F_POB)%

%% free
generated type  PED ::= sort F | sort M | sort POB


forall x : EV . not (x in ACH /\ x in ACC)
                                     %(ga_disjoint_sorts_ACH_ACC)%

%% free
generated type  EV ::= sort ACC | sort ACH

forall x : STV . not (x in ST /\ x in PRO)
                                      %(ga_disjoint_sorts_ST_PRO)%

%% free
generated type  STV ::= sort PRO | sort ST

forall x : NPOB . not (x in MOB /\ x in SOB)
                                     %(ga_disjoint_sorts_MOB_SOB)%

%% free
generated type  NPOB ::= sort MOB | sort SOB


forall x : POB . not (x in APO /\ x in NAPO)
                                    %(ga_disjoint_sorts_APO_NAPO)%

%% free
generated type  POB ::= sort APO | sort NAPO

forall x : SOB . not (x in ASO /\ x in NASO)
                                    %(ga_disjoint_sorts_ASO_NASO)%

%% free
generated type  SOB ::= sort ASO | sort NASO


forall x : ASO . not (x in SAG /\ x in SC)
                                      %(ga_disjoint_sorts_SAG_SC)%

%% free
generated type  ASO ::= sort SAG | sort SC
					
%%---------------------------------------------------------		
		
end

%%--------------------------------

%%----------------------------------------------------------------------------
%%----------------------------------------------------------------------------

view consistent_cpm1 : sp to Classical_Extensional_Parthood_1_model
view consistent_cpm4 : sp to Classical_Extensional_Parthood_4_model


view cpm1: Classical_Extensional_Parthood to 
           Classical_Extensional_Parthood_1_model

view cpm4: Classical_Extensional_Parthood to 
           Classical_Extensional_Parthood_4_model

spec Mereology_Model =
  Classical_Extensional_Parthood_1_model with s |-> T
and  Classical_Extensional_Parthood_4_model with s |-> PD
and  Classical_Extensional_Parthood_1_model with s |-> S
and  Classical_Extensional_Parthood_1_model with s |-> AR
end

view m : Mereology to Mereology_Model 

 view Correctness : Dolce to DolceModel end		
sort U
ops AONOrder, ATMMachine, ATMSlot, Abstract, AccountFn, Active,
    Address, AdjustableRateAccount, Agent, AmericanExpressCard,
    AmericanStyleOption, Annuity, AssetAllocation, AsymmetricRelation,
    Attribute, AuthorizationOfTransaction, AutomaticTransaction,
    BalloonLoan, BankCard, BankStatement, BankTermLoan, Bearish,
    BinaryPredicate, BlueChipStock, Bond, BorrowedStock, Borrowing,
    BridgeLoan, Broker, BrokerLoan, BrokerageAccount, Bullish,
    ButterflySpread, Buying, Call, CallOption, CallableBond,
    CallableLoan, CancellingAnOrder, Cash, Certificate,
    CertificateOfDeposit, ChargingAFee, Check, CheckingAccount,
    ClosedService, ClosingAnAccount, CognitiveAgent, Collateral,
    CommercialService, CommonStock, Communication, ConsolidationLoan,
    ConstantQuantity, ConsumerPriceIndex, ContentBearingObject,
    ContentDevelopment, Contract, ControllingAnAccount,
    ConventionalMortgage, ConventionalOption, CorporateAccount,
    CorporateBond, Corporation, CorpuscularObject, CouponBond,
    CreditAccount, CreditCard, CreditCardAccount, CreditUnion,
    CurrencyFn, CurrencyMeasure, Day, DayDuration, DayLoan, DayOrder,
    DebitCard, Decoding, DefensiveStock, DefinedContributionPlan,
    Deposit, DepositAccount, DepositingACheck, Device, DirectRollover,
    DiscoverCard, Dividend, Downtick, DrawingACheck, EconomicIndicator,
    Employment, Encoding, EnteringAPin, EnteringAPing, EquityOption,
    EuropeanStyleOption, EvergreenLoan, ExerciseAnOption, ExpiredCard,
    ExternalTransfer, FHALoan, FOKOrder, False, Fax, FaxMachine,
    FederalHousingAdministration, FillingAnOrder, FinancialAccount,
    FinancialAsset, FinancialContract, FinancialDefault,
    FinancialInstrument, FinancialOrder, FinancialOrganization,
    FinancialRating, FinancialRequest, FinancialResponse,
    FinancialService, FinancialTransaction, FixedAnnuity,
    FixedRateAccount, FunctionQuantity, GTCOrder, Giving, Government,
    GovernmentBond, GrowthStock, HighLiquidity, HighRisk, HighYield,
    Hole, Human, IOCOrder, Index, IndexBond, IndexOption, IndexedLoan,
    IndividualRetirementAccount, Inflation, InflationIndex, Integer,
    Interest, InterestBearingAccount, InterestOnlyLoan, InterestRate,
    InternalTransfer, Investing, Investment, InvestmentAccount,
    InvestmentAttribute, Investor, IrreflexiveRelation, JointAccount,
    JunkBond, LEAPS, LandArea, Lending, Liability, LiabilityAccount,
    LimitOrder, Liquidation, LiquidityAttribute, Loan, LoanCommitment,
    Locked, LongStraddle, LowLiquidity, LowRisk, LowYield, MNHOrder,
    MOCOrder, Manager, MarketOrder, MarketShareWeightedIndex,
    MarketValueWeightedIndex, MasterCard, MoneyMarket, Month,
    MonthDuration, Mortgage, MortgageBond, MunicipalBond,
    MutualFundAccount, NASDAQ, NASDAQCompositeIndex, NHOrder, New,
    NikkeiIndex, Note, OCOOrder, Object, Offering, OpenService,
    OpeningAnAccount, Option, OptionStrategy, Organization,
    OrganizationalProcess, PayCheck, Payment, Penalty, Pending,
    PennyStock, PensionPlan, PerformanceBond, PerformanceMeasure,
    PersonalAccount, Physical, PhysicalQuantity, PiggybankLoan,
    PlacingAnOrder, Planning, Position, PositiveInteger,
    PreferredStock, Prepayment, PriceWeightedIndex, ProcessingACheck,
    ProducerPriceIndex, ProfitSharingPlan, Proposition, PutOption,
    Putting, RealEstate, RealNumber, Receipt, Refinancing, Region,
    RegisteredBond, RegulatoryProcess, RestrictedStock, Retired,
    RiskAttribute, Rollover, RothIRAAccount, SARSEPPlan,
    SavingsAccount, SavingsAndLoans, SecuredBond, SecuredLoan,
    Security, Selling, ServiceAttribute, ServiceContract, Share,
    ShortSale, SingleOption, SinglePaymentLoan, SingleValuedRelation,
    SpreadOption, StationaryArtifact, StatusAttribute, Stock,
    StockIndex, StockMarket, StockMarketTransaction, StockOption,
    StockSplit, StopOrder, Straddle, SymbolicString, Tax,
    TaxFreeInvestment, TaxableInvestment, Telephone, TernaryPredicate,
    TimeDuration, TimeInterval, TimePosition, Title,
    TraditionalSavingsAccount, TreasuryBill, TreasuryBond, True,
    UnaryFunction, UnitOfMeasure, UnitedStatesDollar, UnsecuredLoan,
    Update, Uptick, UsingAnAccount, ValidCard, ValueStock,
    VariableAnnuity, VerifyingCardCode, VisaCard, Withdrawal, Working,
    YearDuration, YieldAttribute, ZeroCouponBond, a_0, a_1, a_1_0_0,
    a_1_8, a_2, a_3, a_3_9, a_4_0_1_K_Minus_P_l_a_n,
    a_4_0_3_B_Minus_P_l_a_n, a_4_0_8_K_Minus_P_l_a_n, a_5, a_6, a_9,
    a_A_A_A_Minus_R_a_t_i_n_g, a_B_Minus_R_a_t_i_n_g,
    a_B_a_n_k_Minus_F_i_n_a_n_c_i_a_l_O_r_g_a_n_i_z_a_t_i_o_n,
    a_C_Minus_R_a_t_i_n_g, a_D_Minus_R_a_t_i_n_g, accountAt,
    accountHolder, accountNumber, accountStatus, accruedInterest,
    administrator, administratorStatus, afterTaxIncome, agent,
    agreementActive, agreementMember, agreementPeriod, amountCharged,
    amountDue, appraisedValue, askPrice, atTheMoney, attribute,
    availableBalance, availableCash, bankAccount, beforeTaxIncome,
    benchmark, bidPrice, bondRating, borrower, buyingPowerAmount,
    callDate, cardAccount, cardCode, checkAccount, checkNumber,
    closingPrice, compensationPackage, compoundInterest,
    confirmationNumber, couponInterest, creditLimit, creditRanking,
    creditsPerPeriod, currentAccountBalance, currentInterestRate,
    customer, customerRepresentative, dailyLimit, date,
    dateOfStatement, dayPhone, downPayment, effectiveDate,
    emailAddress, employeeContribution, eveningPhone, expirationDate,
    faceValue, finalPrice, financialResponseTo, firstName,
    fixedInterestRate, floorLoan, inTheMoney, income, incomeEarned,
    inflationRate, insured, interestEarned, interestRatePerPeriod,
    issuedBy, lastStatement, lastStatementBalance, lender, limitPrice,
    liquidity, listedOn, loanFeeAmount, loanForPurchase, loanInterest,
    marginBalanceAmount, marketValueAmount, maturityDate,
    minimumBalance, minimumPayment, monetaryValue, monthlyIncome,
    names, netAmount, netWorth, optionHolder, optionSeller, orderFor,
    originalBalance, outOfTheMoney, overdraft, paymentsPerPeriod,
    periodicPayment, phoneNumber, pin, postalCode, potentialLoss,
    premium, price, primeInterestRate, principalAmount, profit,
    purchasesPerPeriod, refers, represents, riskLevel, riskTolerance,
    securedBy, serviceFee, shareHolder, shareOf, shortBalanceAmount,
    signedBy, simpleInterest, splitFor, statementAccount,
    statementInterest, statementPeriod, stockSymbol, strikePrice,
    taxDeferredIncome, totalBalance, transactionAmount, underlier,
    yield, yieldLevel
        : U;
    AccountFn, BeginFn, CardinalityFn, CurrencyFn, EndFn, FutureFn,
    ImmediateFutureFn, ImmediatePastFn, MagnitudeFn, WealthFn, WhenFn,
    a_n_o_t
        : U -> U;
    AdditionFn, DivisionFn, ExponentiationFn, HourFn, KappaFn,
    MeasureFn, MereologicalSumFn, MultiplicationFn, SubtractionFn,
    a_a_n_d, accountHolder, agent, beforeOrEqual, date, destination,
    equal, instance, lender, measure, or, origin, overlapsTemporally,
    part, patient, possesses, time, transactionAmount
        : U * U -> U;
    a_a_n_d : U * U * U -> U;
    a_a_n_d : U * U * U * U * U -> U
preds a_r_e_s_u_l_t, accountAt, accountHolder, afterTaxIncome,
      agent, agreementActive, agreementMember, agreementPeriod,
      amountCharged, atTheMoney, attribute, bankAccount, before,
      benchmark, bondRating, borrower, callDate, cardAccount, cardCode,
      causes, checkAccount, containsInformation, contraryAttribute,
      couponInterest, customer, date, dateOfStatement, dayPhone,
      destination, disjoint, downPayment, duration, earlier,
      effectiveDate, employs, eveningPhone, expirationDate, finishes,
      fixedInterestRate, frequency, greaterThan, greaterThanOrEqualTo,
      hasPurpose, holdsDuring, holdsObligation, holdsRight, hole,
      inTheMoney, instance, instrument, insured, issuedBy, lastStatement,
      lastStatementBalance, lender, lessThan, lessThanOrEqualTo,
      limitPrice, liquidity, listedOn, loanFeeAmount, loanForPurchase,
      loanInterest, located, maturityDate, measure, meetsTemporally,
      monetaryValue, monthlyIncome, optionHolder, optionSeller, origin,
      originalBalance, outOfTheMoney, overlapsTemporally, part, patient,
      phoneNumber, pin, possesses, premium, primeInterestRate,
      principalAmount, profit, property, range, realization, riskLevel,
      riskTolerance, securedBy, signedBy, starts, statementAccount,
      statementInterest, statementPeriod, strikePrice, subAttribute,
      subProcess, subclass, subrelation, temporalPart, time,
      totalBalance, transactionAmount, underlier, uses, yieldLevel : U *
                                                                     U;
      amountDue, askPrice, availableBalance, availableCash, bidPrice,
      capability, compensationPackage, compoundInterest,
      currentAccountBalance, currentInterestRate, customerRepresentative,
      domain, domainSubclass, employeeContribution, exhaustiveAttribute,
      income, incomeEarned, interestEarned, interestRatePerPeriod,
      minimumBalance, minimumPayment, netWorth, orderFor, overdraft,
      paymentsPerPeriod, periodicPayment, potentialLoss, price,
      serviceFee, simpleInterest, splitFor, taxDeferredIncome : U * U * U
vars a_v_R_a_t_e_Minus_D_e_c_i_m_a_l, vATIncome, vATM, vAccount,
     vAccountPeriod, vAccountType, vAction, vActivity, vAdd, vAgent,
     vAgent1, vAgent2, vAgreement, vAmount, vAmount1, vAmount2,
     vAmountDue, vArea, vArtifact, vAsset, vAttribute, vAuthorization,
     vBAL, vBalance, vBalance1, vBalance2, vBank, vBond, vBondAccount,
     vBondHolder, vBorrower, vBorrowing, vBroker, vBuy, vBuyer, vBuying,
     vBuyingTime, vCD, vCPI, vCall, vCall1, vCall2, vCall3, vCall4,
     vCancel, vCard, vCash, vCheck, vClosing, vCode, vCollateral,
     vCommitment, vCompensation, vContract, vControlling, vCopy,
     vCurrency, vCustomer, vDate, vDateOfWithdrawal, vDay, vDebitCard,
     vDebt, vDecode, vDefault, vDeposit, vDepositTime, vDepositing,
     vDividend, vDowntick, vDrawing, vDrawingTime, vDuation, vDueDate,
     vDuration, vEmployment, vEncoding, vEnd, vEnter, vEstate, vEvent,
     vExecute, vExercise, vExpDate, vExponent, vFax, vFaxMachine, vFee,
     vFill, vFinancialAccount, vGive, vGovernment, vIncome, vIndex,
     vInflation, vInsert, vInterest, vInvesting, vInvestment, vKill,
     vLOAN, vLender, vLending, vLevel, vLimitPrice, vLoan, vLoan1,
     vLoan2, vMarket, vMaturity, vMaturityDate, vMinPayment, vMoney,
     vMonth, vMortgage, vMultiply, vN1, vN2, vN3, vNewLoan, vNewNumber,
     vNumber, vObj, vObject, vOffering, vOpening, vOpeningTime, vOption,
     vOption1, vOption2, vOrder, vOrg, vOrganization, vOrganization1,
     vOrganization2, vOverdraft, vPIN, vPPI, vPayment, vPayment1,
     vPayment2, vPenalty, vPerformance, vPeriod, vPerson1, vPerson2,
     vPhone, vPin, vPlace, vPlan, vPremium, vPrice, vPrice1, vPrice2,
     vPrice3, vPrice4, vPrimeRate, vPrincipal, vProcesing, vProcessing,
     vProcessingTime, vProfit, vProperty, vPurchase, vPut, vQuantity,
     vRate, vRealEstate, vRefinancing, vSTART, vSecurity, vSell,
     vSeller, vSelling, vSellingTime, vService, vShares, vSlot, vSpread,
     vStartDate, vStatement, vStock, vStockPrice, vStocks, vStraddle,
     vStrategy, vStrikePrice, vTax, vTaxAmount, vTime, vTime1, vTime2,
     vTimeAfterSplit, vTimeOfDeposit, vTimeOfSplit, vTimeOfWithdrawal,
     vTitle, vTotal, vTransaction, vTransaction1, vTransaction2,
     vTransactionType, vTransfer, vType, vUptick, vUsing, vValue,
     vWithdrawal, vWithdrawalTime, vfee, vorganization2: U
. subclass(FinancialOrganization, Organization)
%{FinancialOrganization
"The class &%FinancialOrganization includes, 
as subclasses, &%Bank-FinancialOrganization, &%CreditUnion and &%SavingsAnLoans."}%
. subclass(a_B_a_n_k_Minus_F_i_n_a_n_c_i_a_l_O_r_g_a_n_i_z_a_t_i_o_n,
           FinancialOrganization)
%{Bank-FinancialOrganization
"An organization, chartered by a state or 
federal government, which does most or all of the following: receives &%Deposits, 
honors &%FinancialInstruments drawn on them, and pays &%Interest on them; discounts 
&%Notes, makes &%Loans,  and invests in &%SecuredLoans; collects &%Checks, &%Drafts 
and &%Notes, certifies depositor's checks; and issues drafts and Cashier's checks."}%
. subclass(CreditUnion, FinancialOrganization)
%{CreditUnion
"Credit unions are non-profit, member-owned, financial 
cooperatives. They are operated entirely by and for their members. When you deposit 
money in a credit union, you become a member of the union because your deposit is 
considered partial ownership in the credit union. Many large organizations have 
established credit unions for their employees."}%
. subclass(SavingsAndLoans, FinancialOrganization)
%{SavingsAndLoans
"A federally or state chartered &%FinancialOrganization 
that takes &%Deposits from individuals, funds &%Mortgages, and pays &%Dividends."}%
. instance(FinancialAsset, Physical)
%{FinancialAsset
"Any item of economic value owned by an individual or 
corporation, especially that which could be converted to cash.  Examples are cash, 
securities, accounts receivable, inventory, office equipment, a house, a car, and 
other property."}%
. instance(vAsset, FinancialAsset) =>
      exists vValue: U . monetaryValue(vAsset, vValue)
. subAttribute(FinancialContract, Contract)
%{FinancialContract
"A financial agreement between two or more parties"}%
. subAttribute(FinancialAccount, Contract)
%{FinancialAccount
"A formal banking, brokerage, or business relationship 
established to provide for regular services, dealings, and other financial 
transactions."}%
. instance(vAccount, FinancialAccount) =>
      property(vAccount, FinancialContract)
      /\ property(vAccount, ServiceContract)
. instance(vAccount, FinancialAccount) =>
      exists vOrganization: U
          . instance(vOrganization, FinancialOrganization)
            /\ accountAt(vAccount, vOrganization)
. property(vAccount, FinancialAccount)
  /\ accountAt(vAccount, vBank) =>
      exists vActivity: U
          . instance(vActivity, ControllingAnAccount)
            /\ patient(vActivity, vAccount)
            /\ agent(vActivity, vBank)
. subclass(Note, FinancialInstrument)
%{Note
"A legal document that obligates a borrower to repay a loan 
at a specified interestRate during a specified period of time or on demand"}%
. subclass(Check, FinancialInstrument)
%{Check
"A &%FinancialInstrument drawn against deposited funds, 
to pay a specified amount of money to a specific person upon demand."}%
. instance(vCheck, Check) =>
      exists vValue: U . monetaryValue(vCheck, vValue)
. instance(vCheck, Check) =>
      exists vAccount: U . checkAccount(vCheck, vAccount)
. monetaryValue(vCheck, vAmount)
  /\ checkAccount(vCheck, vAccount)
  /\ instance(vProcessing, ProcessingACheck)
  /\ patient(vProcessing, vCheck)
  /\ WhenFn(vProcessing) = vProcessingTime =>
      exists vWithdrawal: U
          . instance(vWithdrawal, Withdrawal)
            /\ instrument(vWithdrawal, vCheck)
            /\ WhenFn(vWithdrawal) = vWithdrawalTime
            /\ meetsTemporally(vProcessingTime, vWithdrawalTime)
            /\ transactionAmount(vWithdrawal, vAmount)
            /\ origin(vWithdrawal, vAccount)
. monetaryValue(vCheck, vAmount)
  /\ instance(vProcessing, ProcessingACheck)
  /\ patient(vProcessing, vCheck)
  /\ destination(vProcessing, CurrencyFn(vAccount))
  /\ instance(vAccount, FinancialAccount)
  /\ WhenFn(vProcessing) = vProcessingTime =>
      exists vDeposit: U
          . instance(vDeposit, Deposit)
            /\ instrument(vDeposit, vCheck)
            /\ WhenFn(vDeposit) = vDepositTime
            /\ meetsTemporally(vProcessingTime, vDepositTime)
            /\ transactionAmount(vDeposit, vAmount)
            /\ destination(vDeposit, CurrencyFn(vAccount))
. instance(vCheck, Check)
  /\ instance(vProcessing, ProcessingACheck)
  /\ patient(vProcessing, vCheck) =>
      exists vDepositing: U
          . instance(vDepositing, DepositingACheck)
            /\ patient(vDepositing, vCheck)
            /\ time(vDepositing, ImmediatePastFn(WhenFn(vProcessing)))
. instance(vDepositing, DepositingACheck)
  /\ instance(vCheck, Check)
  /\ agent(vDepositing, vAgent) =>
      signedBy(vCheck, vAgent)
. instance(vDrawing, DrawingACheck)
  /\ patient(vDrawing, vCheck)
  /\ instance(vProcessing, ProcessingACheck)
  /\ patient(vProcessing, vCheck)
  /\ WhenFn(vDrawing) = vDrawingTime
  /\ WhenFn(vProcesing) = vProcessingTime
  /\ meetsTemporally(vDrawingTime, vTime)
  /\ meetsTemporally(vTime, vProcessingTime)
  /\ duration(vTime, vDuation) =>
      lessThan(vDuration, MeasureFn(a_6, MonthDuration))
. subclass(PayCheck, Check)
%{PayCheck
"A check issued to an employee in payment of salary or wages"}%
. instance(vCheck, PayCheck)
  /\ issuedBy(vCheck, vOrganization)
  /\ instance(vGive, Giving)
  /\ destination(vGive, vAgent) =>
      employs(vAgent, vOrganization)
. subclass(BankCard, FinancialInstrument)
%{BankCard
"A &%CreditCard or a &%DebitCard issued by a 
&%FinancialOrganization."}%
. instance(vCard, BankCard) =>
      exists vOrganization: U . issuedBy(vCard, vOrganization)
. instance(vCard, BankCard) /\ issuedBy(vCard, vBank) =>
      exists vAccount: U
          . instance(vAccount, FinancialAccount)
            /\ cardAccount(vCard, vAccount)
            /\ accountAt(vAccount, vBank)
. subclass(DebitCard, BankCard)
%{DebitCard
"A card which allows customers to access their funds 
immediately, electronically. Unlike a credit card, a debit card does not have 
any float."}%
. instance(vCard, DebitCard) /\ possesses(vAgent, vCard) =>
      exists vAccount: U
          . instance(vAccount, DepositAccount)
            /\ cardAccount(vCard, vAccount)
            /\ accountHolder(vAccount, vAgent)
. subclass(CreditCard, BankCard)
%{CreditCard
"Any card that may be used repeatedly to borrow money 
or buy products and services on credit.  Issued by banks, savings and loans, retail 
stores, and other businesses."}%
. instance(vCard, CreditCard) /\ possesses(vAgent, vCard) =>
      exists vAccount: U
          . instance(vAccount, CreditCardAccount)
            /\ cardAccount(vCard, vAccount)
            /\ accountHolder(vAccount, vAgent)
. subrelation(accountAt, agreementMember)
. domain(accountAt, a_1, FinancialAccount)
. domain(accountAt, a_2, FinancialOrganization)
%{accountAt
"(&%accountAt ?Account ?Bank) means that ?Account is a 
&%FinancialAccount opened in the &%FinancialOrganization ?Bank."}%
. instance(cardAccount, BinaryPredicate)
. domain(cardAccount, a_1, BankCard)
. domain(cardAccount, a_2, FinancialAccount)
%{cardAccount
"(&%cardAccount ?Card ?Account) means that ?Account is 
the &%FinancialAccount linked to a BankCard ?Card."}%
. instance(checkAccount, BinaryPredicate)
. domain(checkAccount, a_1, Check)
. domain(checkAccount, a_2, FinancialAccount)
%{checkAccount
"(&%checkAccount ?Check ?Account) means that ?Account 
is the &%FinancialAccount from which the amount specifed on the check is paid."}%
. subrelation(accountHolder, agreementMember)
. domain(accountHolder, a_1, FinancialAccount)
. domain(accountHolder, a_2, CognitiveAgent)
%{accountHolder
"(&%accountHolder ?Account ?Agent) means that ?Agent 
is the account holder of the &%FinancialAccount ?Account."}%
. instance(issuedBy, BinaryPredicate)
. domain(issuedBy, a_1, FinancialInstrument)
. domain(issuedBy, a_2, CognitiveAgent)
%{issuedBy
"(&%issuedBy ?Instrument ?Agent) means that a 
&%FinancialInstrument ?Instrument is produced and offered by ?Agent."}%
. instance(signedBy, BinaryPredicate)
. domain(signedBy, a_1, Certificate)
. domain(signedBy, a_2, CognitiveAgent)
%{signedBy
"(&%signedBy ?Instrument ?Agent) means that ?Instrument 
has been signed by ?Agent."}%
. instance(agreementMember, BinaryPredicate)
. domain(agreementMember, a_1, Contract)
. domain(agreementMember, a_2, CognitiveAgent)
%{agreementMember
"(&%agreementMember ?Agreement ?Agent) means that 
?Agent is one of the participants of the Agreement."}%
. instance(CurrencyFn, UnaryFunction)
. domain(CurrencyFn, a_1, FinancialAccount)
. range(CurrencyFn, FinancialInstrument)
%{CurrencyFn
"A unary function that maps a &%FinancialAccount to the 
currency linked to the account."}%
. subclass(OpeningAnAccount, FinancialTransaction)
%{OpeningAnAccount
"An activity of opening a financial account"}%
. instance(vOpening, OpeningAnAccount)
  /\ located(vOpening, vBank)
  /\ instance(vBank, FinancialOrganization)
  /\ agent(vOpening, vAgent)
  /\ WhenFn(vOpening) = vOpeningTime =>
      exists vAccount: U; vAccountPeriod: U
          . agreementPeriod(vAccount, vAccountPeriod)
            /\ meetsTemporally(vOpeningTime, vAccountPeriod)
            /\ instance(vAccount, FinancialAccount)
            /\ accountAt(vAccount, vBank)
            /\ accountHolder(vAccount, vAgent)
. subclass(UsingAnAccount, FinancialTransaction)
%{UsingAnAccount
"An activity of using a financial account"}%
. instance(vUsing, UsingAnAccount)
  /\ patient(vUsing, vAccount)
  /\ accountHolder(vAccount, vAgent) =>
      agent(vUsing, vAgent)
. subclass(DrawingACheck, UsingAnAccount)
%{DrawingACheck
"An activity of paying by a check."}%
. instance(vDrawing, DrawingACheck)
  /\ patient(vDrawing, vCheck)
  /\ agent(vDrawing, vAgent)
  /\ checkAccount(vCheck, vAccount) =>
      accountHolder(vAccount, vAgent)
. subclass(DepositingACheck, UsingAnAccount)
%{DepositingACheck
"An activity of depositing a check into a 
&%FinancialOrganization."}%
. instance(vDepositing, DepositingACheck) =>
      exists vCheck: U
          . instance(vCheck, Check) /\ patient(vDepositing, vCheck)
. instance(vDepositing, DepositingACheck)
  /\ patient(vDepositing, vCheck)
  /\ instance(vCheck, Check)
  /\ checkAccount(vCheck, vAccount)
  /\ monetaryValue(vCheck, vAmount) =>
      exists vDeposit: U
          . instance(vDeposit, Deposit)
            /\ destination(vDeposit, CurrencyFn(vAccount))
            /\ transactionAmount(vDeposit, vAmount)
. subclass(ControllingAnAccount, FinancialTransaction)
%{ControllingAnAccount
"An activity of controlling a financial account"}%
. instance(vControlling, ControllingAnAccount)
  /\ patient(vControlling, vAccount)
  /\ accountAt(vAccount, vBank) =>
      agent(vControlling, vBank)
. subclass(ProcessingACheck, ControllingAnAccount)
. subclass(ProcessingACheck, AuthorizationOfTransaction)
%{ProcessingACheck
"An activity of paying the amount specified on the 
check from funds on deposit."}%
. instance(vProcessing, ProcessingACheck) =>
      exists vCheck: U
          . instance(vCheck, Check) /\ patient(vProcesing, vCheck)
. instance(vProcessing, ProcessingACheck) =>
      exists vAuthorization: U
          . instance(vAuthorization, AuthorizationOfTransaction)
            /\ subProcess(vAuthorization, vProcessing)
. subclass(AuthorizationOfTransaction, ControllingAnAccount)
. subclass(AuthorizationOfTransaction, RegulatoryProcess)
. subclass(AuthorizationOfTransaction, FinancialService)
%{AuthorizationOfTransaction
"An activity which approves or 
disapproves a transaction."}%
. subclass(ClosingAnAccount, FinancialTransaction)
%{ClosingAnAccount
"An activity of closing a financial account"}%
. instance(vClosing, ClosingAnAccount)
  /\ patient(vClosing, vAccount) =>
      holdsDuring(ImmediatePastFn(WhenFn(vClosing)),
                  instance(vAccount, FinancialAccount))
      /\ holdsDuring(ImmediateFutureFn(WhenFn(vClosing)),
                     a_n_o_t(instance(vAccount, FinancialAccount)))
. subclass(Payment, FinancialTransaction)
%{Payment
"The partial or complete discharge of an obligation by 
its settlement in the form of the transfer of funds, assets, or services equal 
to the monetary value of part or all of the debtor's obligation."}%
. instance(vPayment, Payment)
  /\ origin(vPayment, CurrencyFn(vAccount))
  /\ instance(vAccount, FinancialAccount)
  /\ transactionAmount(vPayment, vAmount)
  /\ currentAccountBalance(vAccount,
                           ImmediatePastFn(WhenFn(vPayment)), vBalance1)
  /\ vBalance2 = SubtractionFn(vBalance1, vAmount) =>
      currentAccountBalance(vAccount,
                            ImmediateFutureFn(WhenFn(vPayment)), vBalance2)
. subclass(Deposit, FinancialTransaction)
. disjoint(Deposit, Withdrawal)
%{Deposit
"An Activity of money being transferred into a customer's 
account at a financial institution."}%
. instance(vDeposit, Deposit) =>
      exists vAccount: U . destination(vDeposit, CurrencyFn(vAccount))
. instance(vDeposit, Deposit)
  /\ time(vDeposit, vTimeOfDeposit)
  /\ instance(vAccount, FinancialAccount)
  /\ destination(vDeposit, CurrencyFn(vAccount))
  /\ transactionAmount(vDeposit, vAmount)
  /\ currentAccountBalance(vAccount,
                           ImmediatePastFn(WhenFn(vDeposit)), vBalance1)
  /\ vBalance2 = AdditionFn(vBalance1, vAmount) =>
      currentAccountBalance(vAccount,
                            ImmediateFutureFn(FutureFn(vDeposit)), vBalance2)
. subclass(Withdrawal, FinancialTransaction)
%{Withdrawal
"An activity of money being transferred from a customer's 
account at a financial institution."}%
. instance(vWithdrawal, Withdrawal) =>
      exists vAccount: U
          . instance(vAccount, FinancialAccount)
            /\ origin(vWithdrawal, CurrencyFn(vAccount))
. instance(vWithdrawal, Withdrawal)
  /\ time(vWithdrawal, vTimeOfWithdrawal)
  /\ instance(vAccount, FinancialAccount)
  /\ origin(vWithdrawal, vAccount)
  /\ transactionAmount(vWithdrawal, vAmount)
  /\ currentAccountBalance(vAccount,
                           ImmediatePastFn(WhenFn(vWithdrawal)), vBalance1)
  /\ vBalance2 = SubtractionFn(vBalance1, vAmount) =>
      currentAccountBalance(vAccount,
                            ImmediateFutureFn(FutureFn(vWithdrawal)), vBalance2)
. subclass(Investing, FinancialTransaction)
%{Investing
"An activity of commiting money or capital in order to 
gain a financial return."}%
. agent(vPurchase, vBuyer)
  /\ origin(vPurchase, vSeller)
  /\ patient(vPurchase, vObject)
  /\ monetaryValue(vObject, vMoney) =>
      exists vPayment: U
          . subProcess(vPayment, vPurchase)
            /\ instance(vPayment, Payment)
            /\ transactionAmount(vPayment, vMoney)
            /\ destination(vPayment, vSeller)
. subclass(AutomaticTransaction, FinancialTransaction)
%{AutomaticTransaction
"&%Transactions which occur through computer 
networks and which do not require direct management."}%
. subclass(Interest, CurrencyMeasure)
%{Interest
"Money paid for the use of money."}%
. subclass(InterestRate, ConstantQuantity)
. subclass(InterestRate, EconomicIndicator)
%{InterestRate
"The usual way of calculating Interest, as a 
percentage of the sum borrowed."}%
. instance(interestEarned, TernaryPredicate)
. domain(interestEarned, a_1, FinancialAccount)
. domain(interestEarned, a_2, Interest)
. domain(interestEarned, a_3, TimeInterval)
%{interestEarned
"(&%interestEarned ?Account ?Interest ?Period) means 
that ?Interest is the amount earned on the &%FinancialAccount ?Account, for the 
duration ?Period."}%
. instance(simpleInterest, TernaryPredicate)
. subrelation(simpleInterest, interestEarned)
. domain(simpleInterest, a_1, FinancialAccount)
. domain(simpleInterest, a_2, Interest)
. domain(simpleInterest, a_3, TimeInterval)
%{simpleInterest
"(&%simpleInterest ?Account ?Amount ?Time) means 
that ?Amount is the interest calculated on a principal sum, not compounded on 
earned interest, for the duration ?Time."}%
. principalAmount(vAccount, vBalance)
  /\ fixedInterestRate(vAccount, vRate)
  /\ simpleInterest(vAccount, vAmount, vPeriod)
  /\ a_v_R_a_t_e_Minus_D_e_c_i_m_a_l =
         DivisionFn(MagnitudeFn(vRate), a_1_0_0) =>
      vAmount =
          MultiplicationFn(MultiplicationFn(MagnitudeFn(vPeriod), vBalance),
                           a_v_R_a_t_e_Minus_D_e_c_i_m_a_l)
. instance(compoundInterest, TernaryPredicate)
. subrelation(compoundInterest, interestEarned)
. domain(compoundInterest, a_1, FinancialAccount)
. domain(compoundInterest, a_2, Interest)
. domain(compoundInterest, a_3, TimeInterval)
%{compoundInterest
"(&%compoundInterest ?Account ?Amount ?Time) means 
that ?Amount is the interest which is calculated not only on the initial principal 
but also the accumulated interest of prior periods. Compound interest can be 
calculated annually, semi-annually, quartely, monthly, or daily."}%
. principalAmount(vAccount, vBalance)
  /\ fixedInterestRate(vAccount, vRate)
  /\ compoundInterest(vAccount, vInterest, vPeriod)
  /\ a_v_R_a_t_e_Minus_D_e_c_i_m_a_l = DivisionFn(vRate, a_1_0_0)
  /\ vAdd = AdditionFn(a_1, a_v_R_a_t_e_Minus_D_e_c_i_m_a_l)
  /\ vExponent = ExponentiationFn(vAdd, MagnitudeFn(vPeriod))
  /\ vMultiply = MultiplicationFn(vExponent, vBalance) =>
      vInterest = SubtractionFn(vMultiply, vBalance)
. instance(interestRatePerPeriod, TernaryPredicate)
. domain(interestRatePerPeriod, a_1, FinancialAccount)
. domain(interestRatePerPeriod, a_2, InterestRate)
. domain(interestRatePerPeriod, a_3, TimeInterval)
%{interestRatePerPeriod
"(interestRatePerPeriod ?ACCOUNT ?RATE ?TIME) means that ?RATE is the interest 
per the period TIME divided by principal amount, expressed as a percentage"}%
. simpleInterest(vAccount, vInterest, vPeriod)
  /\ principalAmount(vAccount, vPrincipal)
  /\ a_v_R_a_t_e_Minus_D_e_c_i_m_a_l =
         DivisionFn(vInterest, vPrincipal)
  /\ vRate =
         MultiplicationFn(a_v_R_a_t_e_Minus_D_e_c_i_m_a_l, a_1_0_0) =>
      interestRatePerPeriod(vAccount, vRate, vPeriod)
. instance(primeInterestRate, BinaryPredicate)
. domain(primeInterestRate, a_1, Day)
. domain(primeInterestRate, a_2, InterestRate)
%{primeInterestRate
"The interest rate that commercial banks charge 
their most creditworthy borrowers, such as large corporations.  The prime rate is 
a lagging indicator."}%
. instance(vAccount, PersonalAccount)
  /\ currentInterestRate(vAccount, vDate, vRate)
  /\ primeInterestRate(vDate, vPrimeRate) =>
      greaterThan(vRate, vPrimeRate)
. instance(currentInterestRate, TernaryPredicate)
. domain(currentInterestRate, a_1, FinancialAccount)
. domain(currentInterestRate, a_2, Day)
. domain(currentInterestRate, a_3, InterestRate)
%{currentInterestRate
"(&%currentInterestRate ?Account ?Day ?Rate) 
means that ?Rate is the interest rate of the Account on a specific day ?Day."}%
. instance(fixedInterestRate, BinaryPredicate)
. domain(fixedInterestRate, a_1, FinancialAccount)
. domain(fixedInterestRate, a_2, InterestRate)
%{fixedInterestRate
"(&%fixedInterestRate ?Account ?Rate) holds if 
?Rate is the interest rate that does not change during the entire term of the 
account."}%
. instance(agreementActive, BinaryPredicate)
. domain(agreementActive, a_1, Contract)
. domain(agreementActive, a_2, TimePosition)
%{agreementActive
"(&%agreementActive ?Agreement ?Date) holds if 
?Agreement is in force at the time specified by ?Date."}%
. agreementPeriod(vAgreement, vPeriod)
  /\ overlapsTemporally(vDate, vPeriod) <=>
      agreementActive(vAgreement, vDate)
. instance(maturityDate, BinaryPredicate)
. subrelation(maturityDate, expirationDate)
. domain(maturityDate, a_1, FinancialAccount)
. domain(maturityDate, a_2, Day)
%{maturityDate
"The date on which the principal amount of the account 
becomes due and payable."}%
. maturityDate(vAccount, vDate)
  /\ principalAmount(vAccount, vPrincipal) =>
      amountDue(vAccount, vPrincipal, vDate)
. agreementPeriod(vAccount, vPeriod) /\ finishes(vEnd, vPeriod) <=>
      maturityDate(vAccount, vEnd)
. instance(amountDue, TernaryPredicate)
. domain(amountDue, a_1, FinancialAccount)
. domain(amountDue, a_2, CurrencyMeasure)
. domain(amountDue, a_3, TimePosition)
%{amountDue
"(&%amountDue ?ACCOUNT ?AMOUNT ?DATE) means ?DATE is the 
date on which the amount of Money ?AMOUNT of a particular ?ACCOUNT is due and payable"}%
. amountDue(vAccount, vAmount, vDueDate)
  /\ accountHolder(vAccount, vAgent) =>
      holdsObligation(KappaFn(vPayment,
                              a_a_n_d(instance(vPayment, Payment),
                                      transactionAmount(vPayment, vAmount),
                                      or(destination(vPayment,
                                                     CurrencyFn(vAccount)),
                                         origin(vPayment,
                                                CurrencyFn(vAccount))),
                                      date(vPayment, vDate),
                                      beforeOrEqual(EndFn(vDate),
                                                    BeginFn(vDueDate)))),
                      vAgent)
. instance(agreementPeriod, BinaryPredicate)
. domain(agreementPeriod, a_1, Contract)
. domain(agreementPeriod, a_2, TimeInterval)
%{agreementPeriod
"(&%agreementPeriod ?Agreement ?Period) holds if 
?Period specifies a Time interval during which ?Agreement is in force."}%
. instance(currentAccountBalance, TernaryPredicate)
. domain(currentAccountBalance, a_1, FinancialAccount)
. domain(currentAccountBalance, a_2, Day)
. domain(currentAccountBalance, a_3, CurrencyMeasure)
%{currentAccountBalance
"(&%currentAccountBalance ?Account ?Date ?Amount) means that ?Amount is the balance of the FinancialAccount ?Account as of the date 
?Date."}%
. instance(minimumBalance, TernaryPredicate)
. domain(minimumBalance, a_1, FinancialAccount)
. domainSubclass(minimumBalance, a_2, FinancialTransaction)
. domain(minimumBalance, a_3, CurrencyMeasure)
%{minimumBalance
"(&%minimumBalance ?Account ?ActivityType ?Amount) 
means that ?Amount is the mimimum amount required by the type of 
&%FinancialTransaction ?ActivityType."}%
. instance(vAccount, vFinancialAccount)
  /\ minimumBalance(vAccount, OpeningAnAccount, vBalance) =>
      exists vPayment: U
          . destination(vPayment, CurrencyFn(vAccount))
            /\ transactionAmount(vPayment, vAmount)
            /\ greaterThanOrEqualTo(vAmount, vBalance)
            /\ effectiveDate(vAccount, vDate)
            /\ date(vPayment, vDate)
. (exists vDate: U
       . instance(vAccount, vFinancialAccount)
         /\ minimumBalance(vAccount, UsingAnAccount, vBalance)
         /\ currentAccountBalance(vAccount, vDate, vAmount)
         /\ lessThan(vAmount, vBalance)) =>
      exists vPenalty: U
          . instance(vPenalty, Penalty)
            /\ date(vPenalty, vDate)
            /\ destination(vPenalty, CurrencyFn(vAccount))
. instance(originalBalance, BinaryPredicate)
. domain(originalBalance, a_1, FinancialAccount)
. domain(originalBalance, a_2, CurrencyMeasure)
%{originalBalance
"(&%originalBalance ?ACCOUNT ?BALANCE) means that 
?BALANCE is the balance of the account at the time the account is opened."}%
. effectiveDate(vAccount, vDate)
  /\ currentAccountBalance(vAccount, vDate, vBalance) =>
      originalBalance(vAccount, vBalance)
. instance(principalAmount, BinaryPredicate)
. domain(principalAmount, a_1, FinancialAccount)
. domain(principalAmount, a_2, CurrencyMeasure)
%{principalAmount
"(&%principalAmount ?ACCOUNT ?BALANCE) means 
that ?BALANCE is the amount borrowed, or the part of the amount borrowed 
which remains unpaid (excluding interest)."}%
. instance(periodicPayment, TernaryPredicate)
. domain(periodicPayment, a_1, FinancialAccount)
. domain(periodicPayment, a_2, CurrencyMeasure)
. domain(periodicPayment, a_3, TimeDuration)
%{periodicPayment
"(&%periodicPayment ?Pay ?Amount ?Period) holds if 
?Pay is one of the periodic payments for the amount ?Amount."}%
. periodicPayment(vAccount, vAmount, vPeriod) =>
      exists vPayment: U
          . instance(vPayment, Payment)
            /\ origin(vPayment, CurrencyFn(vAccount))
            /\ transactionAmount(vPayment, vAmount)
            /\ frequency(vPayment, vPeriod)
. instance(minimumPayment, TernaryPredicate)
. domain(minimumPayment, a_1, LiabilityAccount)
. domain(minimumPayment, a_2, CurrencyMeasure)
. domain(minimumPayment, a_3, TimeDuration)
%{minimumPayment
"The smallest amount which can be paid on a revolving 
charge account to avoid a penalty."}%
. instance(vAccount, LiabilityAccount)
  /\ minimumPayment(vAccount, vMinPayment, MonthDuration)
  /\ (exists vPayment: U; vMonth: U
          . instance(vMonth, Month)
            /\ destination(vPayment, CurrencyFn(vAccount))
            /\ paymentsPerPeriod(vAccount, vAmount, vMonth)
            /\ lessThan(vAmount, vMinPayment)) =>
      exists vPenalty: U
          . instance(vPenalty, Penalty)
            /\ destination(vPenalty, CurrencyFn(vAccount))
. instance(overdraft, TernaryPredicate)
. domain(overdraft, a_1, FinancialAccount)
. domain(overdraft, a_2, CurrencyMeasure)
. domain(overdraft, a_3, Day)
%{overdraft
"The amount by which withdrawals exceed deposits."}%
. currentAccountBalance(vAccount, vDate,
                        MeasureFn(vBalance, UnitedStatesDollar))
  /\ lessThan(vBalance, a_0)
  /\ vOverdraft = SubtractionFn(a_0, vBalance) =>
      overdraft(vAccount, MeasureFn(vOverdraft, UnitedStatesDollar),
                vDate)
. instance(creditLimit, BinaryPredicate)
. domain(creditLimit, a_1, CreditAccount)
. domain(creditLimit, a_2, CurrencyMeasure)
%{creditLimit
"(&%creditLimit ?ACCOUNT ?AMNT) holds if ?AMNT is the 
maximum amount of credit that a bank or other lender will extend to a customer."}%
. instance(floorLoan, BinaryPredicate)
. domain(floorLoan, a_1, Loan)
. domain(floorLoan, a_2, CurrencyMeasure)
%{floorLoan
"A minimum amount that a lender is willing to loan"}%
. instance(downPayment, BinaryPredicate)
. domain(downPayment, a_1, Loan)
. domain(downPayment, a_2, CurrencyMeasure)
%{downPayment
"The part of the purchase price paid in cash up front, 
reducing the amount of the loan or mortgage."}%
. downPayment(vLoan, vAmount) /\ effectiveDate(vLoan, vDate) =>
      exists vPayment: U
          . transactionAmount(vPayment, vAmount)
            /\ date(vPayment, vDate)
            /\ destination(vPayment, CurrencyFn(vLoan))
. downPayment(vLoan, vAmount)
  /\ loanForPurchase(vLoan, vPurchase)
  /\ monetaryValue(vPurchase, vValue)
  /\ vBalance = SubtractionFn(vValue, vAmount) =>
      originalBalance(vLoan, vBalance)
. subclass(Prepayment, Payment)
%{Prepayment
"Prepayment is the payment of all or part of a debt 
prior to its due date."}%
. transactionAmount(vPayment, vAmount)
  /\ date(vPayment, vDate)
  /\ instance(vAccount, FinancialAccount)
  /\ destination(vPayment, CurrencyFn(vAccount))
  /\ amountDue(vAccount, vAmountDue, vDueDate)
  /\ before(EndFn(vDate), BeginFn(vDueDate)) =>
      instance(vPayment, Prepayment)
. instance(netWorth, TernaryPredicate)
. instance(netWorth, SingleValuedRelation)
. domain(netWorth, a_1, CognitiveAgent)
. domain(netWorth, a_2, CurrencyMeasure)
. domain(netWorth, a_3, Day)
%{netWorth
"Total assets minus total liabilities of an individual or company."}%
. netWorth(vAgent, vAmount, vDate) =>
      holdsDuring(vDate, equal(vAmount, WealthFn(vAgent)))
. subclass(ChargingAFee, FinancialTransaction)
%{ChargingAFee
"An activity of a fee being charged"}%
. instance(serviceFee, TernaryPredicate)
. domain(serviceFee, a_1, FinancialOrganization)
. domain(serviceFee, a_2, FinancialTransaction)
. domain(serviceFee, a_3, CurrencyMeasure)
%{serviceFee
"A charge to the customer levied by a &%FinancialOrganization 
for a &%FinancialTransaction, such as &%OpeningAnAccount or &%UsingAnAccount."}%
. serviceFee(vBank, vAction, vAmount) =>
      exists vFee: U
          . instance(vFee, ChargingAFee)
            /\ agent(vFee, vBank)
            /\ causes(vAction, vfee)
            /\ amountCharged(vFee, vAmount)
. subrelation(amountCharged, transactionAmount)
. domain(amountCharged, a_1, ChargingAFee)
. domain(amountCharged, a_2, CurrencyMeasure)
%{amountCharged
"(&%amountCharged ?Fee ?Amount) means that ?Amount is the amount of 
the fee charged."}%
. subclass(Penalty, ChargingAFee)
%{Penalty
"A fee charged as a penalty."}%
. subclass(Tax, ChargingAFee)
%{Tax
"A fee charged by a government on a product, income, or activity."}%
. instance(vTax, Tax) =>
      exists vOrg: U . instance(vOrg, Government) /\ agent(vTax, vOrg)
. subclass(InterestBearingAccount, FinancialAccount)
%{InterestBearingAccount
"FinancialAccounts that have a fixed or adjustable interest rate."}%
. instance(vAccount, InterestBearingAccount) =>
      exists vRate: U; vPeriod: U
          . interestRatePerPeriod(vAccount, vRate, vPeriod)
. subclass(FixedRateAccount, InterestBearingAccount)
. disjoint(FixedRateAccount, AdjustableRateAccount)
%{FixedRateAccount
"An &%InterestBearingAccount in which the interest rate does not 
change during the entire term of the loan."}%
. (exists vRate: U . fixedInterestRate(vAccount, vRate)) <=>
      instance(vAccount, FixedRateAccount)
. subclass(AdjustableRateAccount, InterestBearingAccount)
%{AdjustableRateAccount
"An &%InterestBearingAccount in which 
the interest rate is adjusted periodically, usually based on a standard 
market rate outside the control of the bank or savings institution, such 
as that prevailing on &%TreasuryBill or the &%primeInterestRate."}%
. subclass(PersonalAccount, FinancialAccount)
%{PersonalAccount
"This is the class of personal accounts, as opposed to 
&%CorporateAccounts."}%
. accountHolder(vAccount, vAgent) /\ instance(vAgent, Human) <=>
      instance(vAccount, PersonalAccount)
. subclass(JointAccount, PersonalAccount)
%{JointAccount
"An account owned by two or more people, usually sharing a household 
and expenses. Each co-owner has equal access to the account. Most types of accounts, whether it's 
basic checking, savings or money market, allow for joint use"}%
. instance(vAccount, PersonalAccount)
  /\ greaterThan(CardinalityFn(KappaFn(vAgent,
                                       accountHolder(vAccount, vAgent))),
                 a_1) <=>
      instance(vAccount, JointAccount)
. subclass(CorporateAccount, FinancialAccount)
. disjoint(CorporateAccount, PersonalAccount)
%{CorporateAccount
"This is the class of accounts held by corporations.  This class 
is disjoint with &%PersonalAccounts."}%
. accountHolder(vAccount, vAgent)
  /\ instance(vAgent, Corporation) <=>
      instance(vAccount, CorporateAccount)
. subclass(DepositAccount, FinancialAccount)
%{DepositAccount
"An account where money is deposited for checking, savings or 
brokerage use."}%
. subclass(SavingsAccount, InterestBearingAccount)
. subclass(SavingsAccount, DepositAccount)
%{SavingsAccount
"An account in a bank on which interest is usually paid and from 
which withdrawals can be made usually only by presentation of a passbook or by written authorization 
on a prescribed form."}%
. instance(vAccount, SavingsAccount)
  /\ instance(vTransaction, FinancialTransaction)
  /\ origin(vTransaction, CurrencyFn(vAccount)) =>
      exists vAuthorization: U
          . instance(vAuthorization, AuthorizationOfTransaction)
            /\ subProcess(vAuthorization, vTransaction)
. instance(vAccount, SavingsAccount)
  /\ accountHolder(vAccount, vAgent)
  /\ interestEarned(vAccount, vInterest, vPeriod) =>
      exists vPayment: U
          . destination(vPayment, CurrencyFn(vAccount))
            /\ transactionAmount(vPayment, vInterest)
            /\ destination(vPayment, vAgent)
. subclass(MoneyMarket, SavingsAccount)
%{MoneyMarket
"&%MoneyMarket is for borrowing and lending money for three years 
or less. The securities in a money market can be U.S. government bonds, TreasuryBills and commercial 
paper from banks and companies."}%
. instance(vAccount, MoneyMarket) =>
      liquidity(vAccount, HighLiquidity)
. instance(vAccount, MoneyMarket) => riskLevel(vAccount, LowRisk)
. subclass(TreasuryBill, SavingsAccount)
%{TreasuryBill
"A negotiable debt obligation issued by the U.S. government and backed 
by its full faith and credit, having a maturity of one year or less. Exempt from state and local taxes"}%
. instance(vAccount, TreasuryBill) => riskLevel(vAccount, LowRisk)
. subclass(CertificateOfDeposit, SavingsAccount)
%{CertificateOfDeposit
"CDs (certificates of deposit) are bank, credit union or savings 
and loan instruments that allow the depositor to lock in an interest rate for a specific period of 
time (e.g. six months, one year, five years).  If the money is withdrawn from the CD before the CD 
matures, there is likely to be an early-withdrawal penalty -- often three month's interest. Generally, 
the longer the time period of the CD, the higher the interest paid."}%
. instance(vCD, CertificateOfDeposit) =>
      exists vDate: U . maturityDate(vCD, vDate)
. instance(vCD, CertificateOfDeposit)
  /\ maturityDate(vCD, vMaturityDate)
  /\ instance(vWithdrawal, Withdrawal)
  /\ origin(vWithdrawal, CurrencyFn(vCD))
  /\ date(vWithdrawal, vDateOfWithdrawal)
  /\ before(EndFn(vDateOfWithdrawal), BeginFn(vMaturityDate)) =>
      exists vPenalty: U
          . instance(vPenalty, Penalty)
            /\ destination(vPenalty, CurrencyFn(vCD))
            /\ causes(vWithdrawal, vPenalty)
. subclass(TraditionalSavingsAccount, SavingsAccount)
%{TraditionalSavingsAccount
"Accounts that pay interest, usually at below-market 
interest rates, that do not have a specific maturity, and that usually can be withdrawn upon demand"}%
. instance(vAccount, TraditionalSavingsAccount) =>
      liquidity(vAccount, HighLiquidity)
. instance(vAccount, TraditionalSavingsAccount) =>
      not (exists vDate: U . maturityDate(vAccount, vDate))
. instance(vAccount, TraditionalSavingsAccount)
  /\ instance(vWithdrawal, Withdrawal)
  /\ origin(vWithdrawal, CurrencyFn(vAccount)) =>
      not (exists vPenalty: U
               . instance(vPenalty, Penalty)
                 /\ destination(vPenalty, CurrencyFn(vAccount))
                 /\ causes(vWithdrawal, vPenalty))
. subclass(CheckingAccount, DepositAccount)
%{CheckingAccount
"A bank account against which the depositor can draw checks"}%
. instance(vAccount, CheckingAccount)
  /\ instance(vTransaction, FinancialTransaction)
  /\ origin(vTransaction, CurrencyFn(vAccount)) =>
      (exists vCheck: U
           . instance(vCheck, Check) /\ instrument(vTransaction, vCheck))
      \/ (exists vDebitCard: U
              . instance(vDebitCard, DebitCard)
                /\ instrument(vTransaction, vDebitCard))
. subclass(InvestmentAccount, DepositAccount)
%{InvestmentAccount
"An account acquired for future financial return or benefit"}%
. subclass(MutualFundAccount, InvestmentAccount)
%{MutualFundAccount
"An open-ended fund operated by an investment company which 
raises money from shareholders and invests in a group of assets, in accordance with a stated 
set of objectives. Benefits include diversification and professional money management. Shares 
are issued and redeemed on demand, based on the fund's net asset value which is determined at 
the end of each trading session."}%
. subclass(Liability, FinancialContract)
%{Liability
"A financial obligation, debt, claim, or potential loss"}%
. subclass(LiabilityAccount, FinancialAccount)
%{LiabilityAccount
"An account for which a person is liable"}%
. instance(vAccount, LiabilityAccount)
  /\ accountHolder(vAccount, vAgent)
  /\ accountAt(vAccount, vBank) =>
      exists vDebt: U
          . instance(vDebt, Liability)
            /\ agreementMember(vDebt, vAgent)
            /\ agreementMember(vDebt, vBank)
. subclass(CreditAccount, LiabilityAccount)
%{CreditAccount
"Credit extended by a business to a customer"}%
. instance(vAccount, CreditAccount)
  /\ accountAt(vAccount, vOrganization)
  /\ accountHolder(vAccount, vAgent)
  /\ interestEarned(vAccount, vInterest, vPeriod) =>
      exists vPayment: U
          . origin(vPayment, vAgent)
            /\ transactionAmount(vPayment, vInterest)
            /\ destination(vPayment, vOrganization)
. instance(vAccount, CreditAccount)
  /\ accountHolder(vAccount, vAgent)
  /\ principalAmount(vAccount, vPrincipal)
  /\ agreementPeriod(vAccount, vPeriod)
  /\ interestEarned(vAccount, vInterest, vPeriod)
  /\ vTotal = AdditionFn(vPrincipal, vInterest) =>
      holdsObligation(KappaFn(vPayment,
                              transactionAmount(vPayment, vTotal)),
                      vAgent)
. subclass(CreditCardAccount, CreditAccount)
%{CreditCardAccount
"A type of &%CreditAccount which uses a &%CreditCard for 
&%FinancialTransactions."}%
. instance(vAccount, CreditCardAccount)
  /\ instance(vTransaction, FinancialTransaction)
  /\ origin(vTransaction, CurrencyFn(vAccount)) =>
      exists vCard: U
          . instance(vCard, CreditCard) /\ instrument(vTransaction, vCard)
. subclass(Loan, LiabilityAccount)
%{Loan
"An arrangement in which a lender gives money or property to a borrower, 
and the borrower agrees to return the property or repay the money, usually along with interest, 
at some future point(s) in time."}%
. instance(vLoan, Loan) =>
      exists vBorrower: U; vLender: U
          . borrower(vLoan, vBorrower) /\ lender(vLoan, vLender)
. borrower(vLoan, vBorrower)
  /\ lender(vLoan, vLender)
  /\ agreementPeriod(vLoan, vPeriod)
  /\ interestEarned(vLoan, vInterest, vPeriod) =>
      exists vPayment: U
          . origin(vPayment, vBorrower)
            /\ transactionAmount(vPayment, vInterest)
            /\ destination(vPayment, vLender)
. instance(vAccount, Loan)
  /\ borrower(vAccount, vAgent)
  /\ principalAmount(vAccount, vPrincipal)
  /\ agreementPeriod(vAccount, vPeriod)
  /\ interestEarned(vAccount, vInterest, vPeriod)
  /\ vTotal = AdditionFn(vPrincipal, vInterest) =>
      holdsObligation(KappaFn(vPayment,
                              transactionAmount(vPayment, vTotal)),
                      vAgent)
. subrelation(lender, agreementMember)
. domain(lender, a_1, Loan)
. domain(lender, a_2, CognitiveAgent)
%{lender
"(&%lender ?Loan ?Agent) means that ?Agent is a private, public or 
institutional entity that put up the funds for the ?Loan."}%
. lender(vLoan, vAgent) =>
      exists vLending: U
          . instance(vLending, Lending) /\ agent(vLending, vAgent)
. subrelation(borrower, agreementMember)
. domain(borrower, a_1, Loan)
. domain(borrower, a_2, CognitiveAgent)
%{borrower
"(&%borrower ?Loan ?Agent) means that ?Agent is a borrower of the ?Loan"}%
. borrower(vLoan, vAgent) =>
      exists vBorrowing: U
          . instance(vBorrowing, Borrowing) /\ agent(vBorrowing, vAgent)
. instance(loanForPurchase, BinaryPredicate)
. domain(loanForPurchase, a_1, Loan)
. domain(loanForPurchase, a_2, Object)
%{loanForPurchase
"(&%loanForPurchase ?ACCOUNT ?PRODUCT) means that ?ACCOUNT is a 
loan to finance the purchase of ?PRODUCT."}%
. subclass(Collateral, FinancialAsset)
%{Collateral
"Assets pledged by a borrower to secure a loan or other credit, and 
subject to seizure in the event of &%FinancialDefault."}%
. instance(vCollateral, Collateral) <=>
      (exists vLoan: U
           . instance(vLoan, SecuredLoan) /\ securedBy(vLoan, vCollateral))
%{securedBy
"Assets pledged by a borrower to secure a loan 
or other credit, and subject to seizure in the event of FinancialDefault."}%
. instance(securedBy, BinaryPredicate)
. domain(securedBy, a_1, FinancialAccount)
. domain(securedBy, a_2, Collateral)
. instance(vLoan, Loan)
  /\ securedBy(vLoan, vSecurity)
  /\ lender(vLoan, vBank)
  /\ (exists vDefault: U
          . instance(vDefault, FinancialDefault)
            /\ patient(vDefault, vLoan)) =>
      holdsDuring(ImmediateFutureFn(WhenFn(vDefault)),
                  possesses(vBank, vSecurity))
. subclass(SecuredLoan, Loan)
. disjoint(SecuredLoan, UnsecuredLoan)
. instance(vLoan, SecuredLoan) <=>
      (exists vSecurity: U . securedBy(vLoan, vSecurity))
. subclass(UnsecuredLoan, Loan)
. subclass(RealEstate, Region)
. subclass(RealEstate, FinancialAsset)
. subclass(RealEstate, CorpuscularObject)
%{RealEstate
"Land, including all the natural resources and permanent buildings on it."}%
. instance(vEstate, RealEstate) =>
      instance(vEstate, StationaryArtifact)
      \/ instance(vEstate, LandArea)
      \/ (exists vArtifact: U; vArea: U
              . instance(vArtifact, StationaryArtifact)
                /\ instance(vArea, LandArea)
                /\ vEstate = MereologicalSumFn(vArtifact, vArea))
. subclass(Mortgage, SecuredLoan)
%{Mortgage
"A loan to finance the purchase of real estate, usually with specified payment 
periods and interest rates."}%
. instance(vLoan, Mortgage) =>
      exists vEstate: U
          . instance(vEstate, RealEstate) /\ loanForPurchase(vLoan, vEstate)
. instance(vLoan, Mortgage)
  /\ loanForPurchase(vLoan, vRealEstate) =>
      securedBy(vLoan, vRealEstate)
. instance(totalBalance, BinaryPredicate)
%{totalBalance
"The initial balance of a loan, which is the
amount borrowed."}%
. instance(vLOAN, Loan)
  /\ vSTART = BeginFn(vLOAN)
  /\ totalBalance(vLOAN, vBAL) =>
      currentAccountBalance(vLOAN, vSTART, vBAL)
. subclass(BalloonLoan, Loan)
%{BalloonLoan
"A long-term loan, often a mortgage, that has 
one large payment (the balloon payment) due upon maturity.  Often done 
when refinancing or a major cash flow event is anticipated."}%
. instance(vLoan, BalloonLoan)
  /\ maturityDate(vLoan, vDate)
  /\ totalBalance(vLoan, vAmount)
  /\ borrower(vLoan, vAgent) =>
      holdsObligation(KappaFn(vPayment,
                              a_a_n_d(date(vPayment, vDate),
                                      transactionAmount(vPayment, vAmount),
                                      destination(vPayment,
                                                  CurrencyFn(vLoan)))),
                      vAgent)
. subclass(Call, FinancialTransaction)
. subclass(CallableLoan, Loan)
%{CallableLoan
"A loan that must repaid upon the lender's demand."}%
. instance(vLoan, CallableLoan)
  /\ lender(vLoan, vLender)
  /\ borrower(vLoan, vBorrower)
  /\ totalBalance(vLoan, vAmount)
  /\ (exists vCall: U
          . instance(vCall, Call)
            /\ agent(vCall, vLender)
            /\ time(vCall, vTime)
            /\ patient(vCall, vLoan)) =>
      holdsObligation(KappaFn(vPayment,
                              a_a_n_d(destination(vPayment, vLender),
                                      time(vPayment,
                                           ImmediateFutureFn(WhenFn(vCall))),
                                      transactionAmount(vPayment, vAmount))),
                      vBorrower)
. subclass(Refinancing, FinancialTransaction)
%{Refinancing
"Paying off an existing loan with the proceeds from a new loan, using 
the same property as collateral."}%
. instance(vRefinancing, Refinancing)
  /\ time(vRefinancing, vTime)
  /\ instance(vLoan, Loan)
  /\ securedBy(vLoan, vCollateral)
  /\ borrower(vLoan, vBorrower)
  /\ currentAccountBalance(vLoan, vDate, vAmount)
  /\ patient(vRefinancing, vLoan) =>
      exists vNewLoan: U; vPayment: U
          . instance(vNewLoan, Loan)
            /\ borrower(vNewLoan, vBorrower)
            /\ securedBy(vLoan, vCollateral)
            /\ destination(vPayment, CurrencyFn(vLoan))
            /\ time(vPayment, vTime)
            /\ origin(vPayment, CurrencyFn(vNewLoan))
            /\ transactionAmount(vPayment, vAmount)
. subclass(LoanCommitment, Contract)
%{LoanCommitment
"A formal offer by a lender making explicit 
the terms under which it agrees to lend money to a borrower over a certain 
period of time."}%
. instance(vCommitment, LoanCommitment) =>
      exists vLoan: U; vLender: U; vBorrower: U
          . instance(vLoan, Loan)
            /\ lender(vLoan, vLender)
            /\ borrower(vLoan, vBorrower)
            /\ agreementMember(vCommitment, vLender)
            /\ agreementMember(vCommitment, vBorrower)
. subrelation(appraisedValue, monetaryValue)
. domain(appraisedValue, a_1, Collateral)
. domain(appraisedValue, a_2, CurrencyMeasure)
. subclass(BankTermLoan, Loan)
%{BankTermLoan
"A bank loan terminating in one year or more."}%
. instance(vLoan, BankTermLoan) /\ lender(vLoan, vLender) =>
      instance(vLender,
               a_B_a_n_k_Minus_F_i_n_a_n_c_i_a_l_O_r_g_a_n_i_z_a_t_i_o_n)
. instance(vLoan, BankTermLoan)
  /\ agreementPeriod(vLoan, vPeriod)
  /\ duration(vPeriod, MeasureFn(vDuration, YearDuration)) =>
      greaterThanOrEqualTo(vDuration, a_1)
. subclass(BridgeLoan, Loan)
%{BridgeLoan
"Short-term financing which is expected to be paid back relatively 
quickly, such as by a subsequent longer-term loan."}%
. subclass(BrokerLoan, Loan)
%{BrokerLoan
"Money lent to brokers by banks, for financing 
the underwriting of new issues, financing customer margin accounts, and 
other purposes."}%
. instance(vLoan, BrokerLoan) /\ borrower(vLoan, vBorrower) =>
      instance(vBorrower, Broker)
. subclass(ConsolidationLoan, Loan)
%{ConsolidationLoan
"The replacement of multiple loans with a single loan, often 
with a lower monthly payment and a longer repayment period."}%
. instance(vLoan, ConsolidationLoan) =>
      exists vLoan1: U; vLoan2: U; vPayment1: U; vPayment2: U
          . instance(vLoan1, Loan)
            /\ instance(vLoan2, Loan)
            /\ destination(vPayment1, CurrencyFn(vLoan1))
            /\ destination(vPayment2, CurrencyFn(vLoan2))
            /\ origin(vPayment1, CurrencyFn(vLoan))
            /\ origin(vPayment2, CurrencyFn(vLoan))
. subclass(FHALoan, Mortgage)
. disjoint(FHALoan, ConventionalMortgage)
%{FHALoan
"A government mortgage that is insured by the Federal Housing 
Administration (FHA)."}%
. instance(vLoan, FHALoan) =>
      insured(vLoan, FederalHousingAdministration)
. instance(insured, BinaryPredicate)
. instance(insured, AsymmetricRelation)
. domain(insured, a_1, Contract)
. domain(insured, a_2, Organization)
%{insured
"(insured ?Contract ?Org) means that ?Contract is insured 
by the ?Organization."}%
. subclass(FederalHousingAdministration, Government)
. subclass(ConventionalMortgage, Mortgage)
%{ConventionalMortgage
"A mortgage that is not insured or guaranteed 
by the government."}%
. instance(vMortgage, ConventionalMortgage) =>
      not (exists vGovernment: U
               . instance(vGovernment, Government)
                 /\ insured(vMortgage, vGovernment))
. subclass(DayLoan, Loan)
%{DayLoan
"A bank loan to a broker for the purchase of securities pending delivery 
through clearing later the same day."}%
. instance(vLoan, DayLoan) /\ lender(vLoan, vLender) =>
      instance(vLender,
               a_B_a_n_k_Minus_F_i_n_a_n_c_i_a_l_O_r_g_a_n_i_z_a_t_i_o_n)
. instance(vLoan, DayLoan) /\ borrower(vLoan, vBorrower) =>
      instance(vBorrower, Broker)
. instance(vLoan, DayLoan) =>
      agreementPeriod(vLoan, vPeriod)
      /\ duration(vPeriod, MeasureFn(a_1, DayDuration))
. subclass(PiggybankLoan, Loan)
%{PiggybankLoan
"Two lenders participating in the same loan."}%
. instance(vLoan, PiggybankLoan) =>
      CardinalityFn(KappaFn(vLender, lender(vLoan, vLender))) = a_2
. subclass(SinglePaymentLoan, Loan)
%{SinglePaymentLoan
"A loan whose principal is due in total with a single 
payment at maturity."}%
. instance(vLoan, SinglePaymentLoan)
  /\ principalAmount(vLoan, vPrincipal)
  /\ maturityDate(vLoan, vMaturity) =>
      amountDue(vLoan, vPrincipal, vMaturity)
. subclass(EvergreenLoan, Loan)
%{EvergreenLoan
"A short-term loan which is continually renewed rather than repaid."}%
. subclass(IndexedLoan, Loan)
%{IndexedLoan
"A loan in which payments change in response to 
changes in an index such as the Consumer Price Index."}%
. subclass(InterestOnlyLoan, Loan)
%{InterestOnlyLoan
"A non-amortized loan in which interest is 
due at regular intervals until maturity, when the full principal on the 
loan is due."}%
. instance(vLoan, InterestOnlyLoan)
  /\ agreementPeriod(vLoan, vPeriod)
  /\ principalAmount(vLoan, vPrincipal)
  /\ interestEarned(vLoan, vInterest, vPeriod) =>
      amountDue(vLoan, vPrincipal, EndFn(vPeriod))
      /\ amountDue(vLoan, vInterest, vDate)
      /\ before(EndFn(vDate), EndFn(vPeriod))
. subclass(Index, PerformanceMeasure)
%{Index
"A benchmark against which financial or economic performance is measured, 
such as the S&P 500 or the Consumer Price Index."}%
. instance(vIndex, Index) =>
      exists vPerformance: U
          . benchmark(vPerformance, vIndex)
            /\ instance(vPerformance, EconomicIndicator)
. subclass(EconomicIndicator, Proposition)
%{EconomicIndicator
"Data which provide information about or 
predict the overall health of the economy or the financial markets; 
examples are inflation, interest rates, employment, etc."}%
. subclass(PerformanceMeasure, PhysicalQuantity)
. instance(benchmark, BinaryPredicate)
. domain(benchmark, a_1, Abstract)
. domain(benchmark, a_2, PerformanceMeasure)
%{benchmark
"A standard by which something can be measured or judged."}%
. subclass(Inflation, EconomicIndicator)
%{Inflation
"The overall general upward price movement of 
goods and services in an economy, usually as measured by the Consumer 
Price Index and the Producer Price Index."}%
. instance(vInflation, Inflation) =>
      (benchmark(vInflation, vCPI) /\ instance(vCPI, ConsumerPriceIndex))
      \/ (benchmark(vInflation, vPPI)
          /\ instance(vPPI, ProducerPriceIndex))
. subclass(InflationIndex, Index)
. instance(vIndex, InflationIndex) <=>
      (exists vInflation: U
           . instance(vInflation, Inflation) /\ benchmark(vInflation, vIndex))
. instance(inflationRate, BinaryPredicate)
. domain(inflationRate, a_1, Inflation)
. domain(inflationRate, a_2, RealNumber)
%{inflationRate
"The percentage increase in the price of goods and services, 
usually annually."}%
. subclass(ConsumerPriceIndex, InflationIndex)
%{ConsumerPriceIndex
"An inflationary indicator that measures 
the change in the cost of a fixed basket of products and services, 
including housing, electricity, food, and transportation.  The CPI is 
published monthly."}%
. subclass(ProducerPriceIndex, InflationIndex)
%{ProducerPriceIndex
"An inflationary indicator published by the U.S. Bureau 
of Labor Statistics to evaluate wholesale price levels in the economy."}%
. subclass(StockIndex, Index)
%{StockIndex
"Any index which is intended to gauge upward or downward trends 
in stock prices."}%
. instance(vIndex, StockIndex) <=>
      (exists vStock: U
           . instance(vStock, Stock) /\ benchmark(vIndex, vStock))
. instance(listedOn, AsymmetricRelation)
. domain(listedOn, a_1, Stock)
. domain(listedOn, a_2, Organization)
. subclass(NASDAQCompositeIndex, Index)
%{NASDAQCompositeIndex
"A market-value weighted index of all common stocks 
listed on NASDAQ."}%
. instance(vIndex, NASDAQCompositeIndex)
  /\ benchmark(vIndex, vStock) =>
      listedOn(vStock, NASDAQ)
. instance(NASDAQ, Organization)
%{NASDAQ
"National Association of Securities Dealers Automated Quotations 
system."}%
. subclass(MarketShareWeightedIndex, Index)
%{MarketShareWeightedIndex
"A stock index in which each stock affects the 
index in proportion to its number of shares outstanding."}%
. subclass(MarketValueWeightedIndex, Index)
%{MarketValueWeightedIndex
"A stock index in which each stock 
affects the index in proportion to its market value.  Examples include 
NASDAQ Composite Index, S&P 500, Wilshire 5000 Equity Index, Hang Seng 
Index, and EAFE Index."}%
. subclass(StockMarket, Organization)
%{StockMarket
"General term for the organized trading of stocks through 
exchanges and over-the-counter."}%
. subclass(PriceWeightedIndex, Index)
%{PriceWeightedIndex
"A stock index in which each stock affects the index 
in proportion to its price per share."}%
. subclass(NikkeiIndex, Index)
%{NikkeiIndex
"Index of 225 leading stocks traded on the Tokyo Stock 
Exchange."}%
. subclass(Investment, FinancialAsset)
%{Investment
"An item of value purchased for income or capital appreciation."}%
. instance(vInvestment, Investment) =>
      exists vInvesting: U; vAgent: U
          . agent(vInvesting, vAgent) /\ possesses(vAgent, vInvestment)
. subclass(Investor, CognitiveAgent)
%{Investor
"A person who purchases income-producing assets."}%
. instance(vAgent, Investor) <=>
      (exists vInvesting: U . agent(vInvesting, vAgent))
. instance(vAgent, Investor) <=>
      (exists vInvestment: U
           . instance(vInvestment, Investment)
             /\ possesses(vAgent, vInvestment))
. instance(profit, AsymmetricRelation)
. domain(profit, a_1, FinancialTransaction)
. domain(profit, a_2, CurrencyMeasure)
%{profit
"The positive gain from an investment or business operation after 
subtracting for all expenses."}%
. instance(vInvesting, Investing) =>
      hasPurpose(vInvesting,
                 True
                     when exists vProfit: U . profit(vInvesting, vProfit)
                     else False)
. subclass(AssetAllocation, FinancialTransaction)
%{AssetAllocation
"The process of dividing investments among different kinds of 
assets, such as Stocks, Bonds, RealEstate and cash, to optimize the risk/reward tradeoff based 
on an individual's or institution's specific situation and goals."}%
. subclass(InvestmentAttribute, Attribute)
. instance(vAttribute, InvestmentAttribute) =>
      exists vAccount: U
          . attribute(vAccount, vAttribute)
            /\ instance(vAccount, InvestmentAccount)
. instance(liquidity, AsymmetricRelation)
. domain(liquidity, a_1, FinancialAccount)
. domain(liquidity, a_2, LiquidityAttribute)
%{liquidity
"Degree to which accounts can be easily converted to cash."}%
. instance(vWithdrawal, Withdrawal)
  /\ instance(vAccount, FinancialAccount)
  /\ origin(vWithdrawal, CurrencyFn(vAccount))
  /\ not (exists vPenalty: U
              . instance(vPenalty, Penalty)
                /\ destination(vPenalty, CurrencyFn(vAccount))
                /\ causes(vWithdrawal, vPenalty)) <=>
      liquidity(vAccount, HighLiquidity)
. subclass(LiquidityAttribute, Attribute)
. exhaustiveAttribute(LiquidityAttribute, HighLiquidity,
                      LowLiquidity)
%{LiquidityAttribute
"A class of attributes which describe the degree to 
which accounts can be easily converted to cash."}%
. instance(HighLiquidity, LiquidityAttribute)
. contraryAttribute(HighLiquidity, LowLiquidity)
%{HighLiquidity
"An &%Attribute of &%FinancialAccounts which can be easily 
converted to cash."}%
. instance(LowLiquidity, LiquidityAttribute)
%{LowLiquidity
"An &%Attribute of &%FinancialAccounts which cannot be easily 
converted to cash."}%
. instance(riskLevel, AsymmetricRelation)
. domain(riskLevel, a_1, Investment)
. domain(riskLevel, a_2, RiskAttribute)
%{riskLevel
"Relates an instance of &%Investing to the level of risk associated 
with the investment."}%
. subclass(RiskAttribute, Attribute)
. exhaustiveAttribute(RiskAttribute, HighRisk, LowRisk)
%{RiskAttribute
"A class of attributes which describe the degree of risk 
of a particular investment."}%
. instance(HighRisk, RiskAttribute)
. contraryAttribute(HighRisk, LowRisk)
%{HighRisk
"An &%Attribute that characterizes investments which are likely 
to lose their principal."}%
. instance(LowRisk, RiskAttribute)
. instance(yieldLevel, AsymmetricRelation)
. domain(yieldLevel, a_1, FinancialAccount)
. domain(yieldLevel, a_2, YieldAttribute)
%{yieldLevel
"A profit obtained from an investment."}%
%{yieldLevel
"Relates a &%FinancialAccount to the yield level (i.e. the type of profit) 
which can be expected from the account."}%
. subclass(YieldAttribute, Attribute)
. exhaustiveAttribute(YieldAttribute, HighYield, LowYield)
%{YieldAttribute
"A class of attributes which describe the degree to which 
accounts are profitable."}%
. instance(HighYield, YieldAttribute)
. contraryAttribute(HighYield, LowYield)
%{HighYield
"An &%Attribute that characterizes accounts that are very profitable."}%
. instance(LowYield, YieldAttribute)
%{LowYield
"An &%Attribute that characterizes accounts that are not very profitable."}%
. instance(potentialLoss, TernaryPredicate)
. domain(potentialLoss, a_1, CognitiveAgent)
. domain(potentialLoss, a_2, Investment)
. domain(potentialLoss, a_3, CurrencyMeasure)
%{potentialLoss
"The maximum amount of money the Agent can lose by choosing 
this type of Investment."}%
. instance(price, TernaryPredicate)
. domain(price, a_1, Physical)
. domain(price, a_2, CurrencyMeasure)
. domain(price, a_3, Agent)
%{price
"(&%price ?Obj ?Money ?Agent) means that ?Agent pays the amount of 
money ?Money for ?Obj."}%
. price(vObj, vMoney, vAgent) =>
      exists vBuying: U
          . instance(vBuying, Buying)
            /\ agent(vBuying, vAgent)
            /\ patient(vBuying, vObj)
            /\ transactionAmount(vBuying, vMoney)
. subrelation(bidPrice, price)
. domain(bidPrice, a_1, Object)
. domain(bidPrice, a_2, CurrencyMeasure)
. domain(bidPrice, a_3, Agent)
%{bidPrice
"(bidPrice ?Obj ?Money ?Agent) means that ?Agent offers to buy 
?Obj for the amount of ?Money."}%
. bidPrice(vObj, vMoney, vAgent) =>
      exists vOffering: U
          . instance(vOffering, Offering)
            /\ patient(vOffering,
                       True
                           when exists vBuying: U
                                    . instance(vBuying, Buying)
                                      /\ agent(vBuying, vAgent)
                                      /\ patient(vBuying, vObj)
                                      /\ transactionAmount(vBuying, vMoney)
                           else False)
. subrelation(askPrice, price)
. domain(askPrice, a_1, Object)
. domain(askPrice, a_2, CurrencyMeasure)
. domain(askPrice, a_3, Agent)
%{askPrice
"(askPrice ?Obj ?Money ?Agent) means that ?Agent offers to sell 
?Obj for the amount of ?Money."}%
. askPrice(vObj, vMoney, vAgent) =>
      exists vOffering: U
          . instance(vOffering, Offering)
            /\ patient(vOffering,
                       True
                           when exists vSelling: U
                                    . instance(vSelling, Selling)
                                      /\ agent(vSelling, vAgent)
                                      /\ patient(vSelling, vObj)
                                      /\ transactionAmount(vSelling, vMoney)
                           else False)
. subclass(FinancialOrder, ServiceContract)
%{FinancialOrder
"A request from a client to a broker to buy (buy order) or sell 
(sell order) a specified amount of a particular security or commodity at a specific 
price or at the market price."}%
. subclass(PlacingAnOrder, FinancialTransaction)
. instance(vPlace, PlacingAnOrder) /\ WhenFn(vPlace) = vTime =>
      exists vOrder: U; vPeriod: U
          . WhenFn(vOrder) = vPeriod /\ meetsTemporally(vTime, vPeriod)
. subclass(MarketOrder, FinancialOrder)
%{MarketOrder
"An order to buy or sell security at the best prices available."}%
. instance(orderFor, TernaryPredicate)
. domain(orderFor, a_1, FinancialTransaction)
. domainSubclass(orderFor, a_2, FinancialTransaction)
. domain(orderFor, a_3, Security)
%{orderFor
"(&%orderFor ?Order ?Transaction ?Security) means that the content of ?Order 
is to realize an instance of ?Transaction where ?Security is the patient of ?Transaction."}%
. instance(vOrder, PlacingAnOrder)
  /\ orderFor(vOrder, vTransactionType, vShares) =>
      hasPurpose(vOrder,
                 True
                     when exists vTransaction: U
                              . instance(vTransaction, vTransactionType)
                                /\ patient(vTransaction, vShares)
                     else False)
. instance(vOrder, MarketOrder)
  /\ instance(vBroker, Broker)
  /\ agreementMember(vOrder, vBroker)
  /\ orderFor(vOrder, vTransactionType, vShares) =>
      holdsObligation(KappaFn(vTransaction,
                              a_a_n_d(instance(vTransaction, vTransactionType),
                                      patient(vTransaction, vShares))),
                      vBroker)
. subclass(LimitOrder, FinancialOrder)
%{LimitOrder
"LimitOrder is an order to a &%Broker  to buy a specified quantity 
of a &%Security at or below a specified price, or to sell it at or above a specified &%limitPrice."}%
. instance(limitPrice, BinaryPredicate)
. instance(limitPrice, AsymmetricRelation)
. domain(limitPrice, a_1, LimitOrder)
. domain(limitPrice, a_2, CurrencyMeasure)
%{limitPrice
"(&%limitPrice ?Order ?Money) means that ?Money is the limit price 
for the limit order ?Order.  If ?Order is a buy order, then ?Money specifies the maximum price
to be paid.  If ?Order is a sell order, then ?Money specifies the minimum price to be paid."}%
. instance(vOrder, LimitOrder) =>
      exists vPrice: U . limitPrice(vOrder, vPrice)
. instance(vOrder, LimitOrder)
  /\ agreementMember(vOrder, vBroker)
  /\ instance(vBroker, Broker)
  /\ orderFor(vOrder, Buying, vObject)
  /\ measure(vObject, vQuantity)
  /\ limitPrice(vOrder, vLimitPrice)
  /\ (exists vTime: U
          . askPrice(vObject, vPrice, vTime)
            /\ lessThanOrEqualTo(vPrice, vLimitPrice)) =>
      holdsObligation(KappaFn(vBuy,
                              a_a_n_d(instance(vBuy, Buying),
                                      patient(vBuy, vObject),
                                      measure(vObject, vQuantity),
                                      equal(WhenFn(vBuy), vBuyingTime),
                                      overlapsTemporally(vTime, vBuyingTime))),
                      vBroker)
. instance(vOrder, LimitOrder)
  /\ agreementMember(vOrder, vBroker)
  /\ instance(vBroker, Broker)
  /\ orderFor(vOrder, Selling, vObject)
  /\ measure(vObject, vQuantity)
  /\ limitPrice(vOrder, vLimitPrice)
  /\ (exists vTime: U
          . bidPrice(vObject, vPrice, vTime)
            /\ greaterThanOrEqualTo(vPrice, vLimitPrice)) =>
      holdsObligation(KappaFn(vSell,
                              a_a_n_d(instance(vSell, Selling),
                                      patient(vSell, vObject),
                                      measure(vObject, vQuantity),
                                      equal(WhenFn(vSell), vSellingTime),
                                      overlapsTemporally(vSellingTime, vTime))),
                      vBroker)
. subclass(Broker, CognitiveAgent)
%{Broker
"An individual or firm which acts as an intermediary between 
a buyer and seller, usually charging a commisssion."}%
. instance(vBroker, Broker) =>
      exists vContract: U
          . instance(vContract, ServiceContract)
            /\ agreementMember(vContract, vBroker)
. subclass(StopOrder, FinancialOrder)
%{StopOrder
"A market order to buy or sell a certain quantity of 
a certain security if a specified price (the stopPrice) is reached or passed."}%
. subclass(Liquidation, FinancialTransaction)
%{Liquidation
"The class of events of selling all of a company's assets, 
paying outstanding debts, and distribution of the remainder to shareholders, and them 
going out of business."}%
. subclass(Dividend, Payment)
%{Dividend
"A taxable payment declared by a company's board of directors 
and given to its &%shareHolders out of the company's current or retained earnings. 
Usually quarterly. Usually given as cash, but it can also take the form of &%Stock or 
other property."}%
. subclass(Security, FinancialInstrument)
%{Security
"An investment instrument, other than an insurance policy or 
&%FixedAnnuity insurance policy or fixed annuity issued by a corporation, government, 
or other organization which offers evidence of debt or equity."}%
. subclass(Annuity, FinancialContract)
%{Annuity
"A contract sold by an insurance company designed to provide 
payments to the holder at specified intervals, usually after retirement. &%FixedAnnuities 
guarantee a certain payment amount, while &%VariableAnnuities do not, but do have the 
potential for greater returns; but both are relatively safe, low-yielding investments."}%
. subclass(FixedAnnuity, Annuity)
%{FixedAnnuity
"An investment vehicle offered by an insurance company, that 
guarantees a stream of fixed payments over the life of the annuity. The insurer, not the 
insured, takes the investment risk."}%
. subclass(VariableAnnuity, Annuity)
%{VariableAnnuity
"An investment vehicle offered by an insurance company that 
does not guarantee a payment amount but does have the potential for greater returns than  
a &%FixedAnnuity."}%
. subclass(Share, Security)
. instance(Share, UnitOfMeasure)
. subclass(Share, CurrencyMeasure)
%{Share
"Certificate, representing one unit of ownership in a corporation, 
&%MutualFund, or limited partnership."}%
. subrelation(shareOf, BinaryPredicate)
. domain(shareOf, a_1, Share)
. domain(shareOf, a_2, Organization)
. instance(shareHolder, BinaryPredicate)
. domain(shareHolder, a_1, Share)
. domain(shareHolder, a_2, CognitiveAgent)
%{shareHolder
"(&%shareHolder ?Stock ?Agent) means that ?Agent possesses 
shares of &%Stock in a corporation or mutual fund."}%
. subclass(TaxFreeInvestment, Investment)
. instance(vInvestment, TaxFreeInvestment) =>
      not (exists vTax: U
               . instance(vTax, Tax) /\ origin(vTax, vInvestment))
. subclass(TaxableInvestment, Investment)
. instance(vInvestment, TaxableInvestment) =>
      exists vTax: U . instance(vTax, Tax) /\ origin(vTax, vInvestment)
. subclass(FinancialDefault, FinancialTransaction)
%{FinancialDefault
"Failure to make required debt payments on a timely basis 
or to comply with other conditions of an obligation or agreement."}%
. subclass(Stock, FinancialInstrument)
. subclass(Stock, Investment)
%{Stock
"An instrument that signifies an ownership position, 
or equity, in a &%Corporation, and represents a claim on its proportionate 
share in the corporation's assets and profits."}%
. subclass(CommonStock, Stock)
%{CommonStock
"Securities representing equity, ownership in a 
Corporation, providing voting rights, and entitling the holder to a share 
of the company's success through dividends and/or capital appreciation.  
In the event of liquidation, common stock holders have rights to a 
company's assets only after bondholders, other debt holders, and 
&%PreferredStock holders have been satisfied."}%
. subclass(PreferredStock, Stock)
%{PreferredStock
"&%CapitalStock which provides a specific &%Dividend 
that is paid before any dividends are paid to common stock holders, and which takes 
precedence over common stock in the event of a liquidation.  Usually does not carry 
voting rights."}%
. instance(vStock, PreferredStock) =>
      exists vDividend: U; vAmount: U
          . instance(vDividend, Dividend)
            /\ transactionAmount(vDividend, vAmount)
. subclass(BlueChipStock, Stock)
%{BlueChipStock
"&%Stock with a solid and stable earnings record from a 
company that either leads or dominates or is a major player in a specific industry."}%
. subclass(GrowthStock, Stock)
%{GrowthStock
"Investment term that is applied to a &%Stock that is expected 
to appreciate in value at a high rate, pay big dividends or split."}%
. subclass(ValueStock, Stock)
%{ValueStock
"When the shares in a company are considered attractive because 
the company is undervalue, usually because it has a low P/E ratio."}%
. subclass(DefensiveStock, Stock)
%{DefensiveStock
"&%DefensiveStocks are stocks of food companies, drug 
manufacturers and utility companies."}%
. subclass(RestrictedStock, Stock)
%{RestrictedStock
"&%Securities, usually issued in private placements, that 
have limited transferability."}%
. subclass(PennyStock, Stock)
%{PennyStock
"Extremely speculative, high-risk &%Stock, usually 
with a price of less than 5 dollars per share.  In the U.S., nearly all 
are traded on the over-the-counter bulletin board."}%
. instance(vStock, PennyStock) => riskLevel(vStock, HighRisk)
. instance(vStock, PennyStock)
  /\ askPrice(vStock, MeasureFn(vPrice, UnitedStatesDollar),
              vDate) =>
      lessThan(vPrice, a_5)
. subclass(StockSplit, FinancialTransaction)
%{StockSplit
"Exchange of the number of shares of stock outstanding 
for a larger number."}%
. instance(splitFor, TernaryPredicate)
. domain(splitFor, a_1, StockSplit)
. domain(splitFor, a_2, Integer)
. domain(splitFor, a_3, Integer)
. possesses(vAgent, vStocks)
  /\ measure(vStocks, MeasureFn(vNumber, Share))
  /\ (exists vEvent: U . splitFor(vEvent, vN1, vN2)) =>
      holdsDuring(ImmediateFutureFn(WhenFn(vEvent)),
                  a_a_n_d(equal(vN3, MultiplicationFn(vNumber, vN2)),
                          equal(vNewNumber, DivisionFn(vN3, vN1)),
                          measure(vStocks, MeasureFn(vNewNumber, Share))))
. price(vStocks, MeasureFn(vNumber, UnitedStatesDollar), vTime)
  /\ (exists vEvent: U
          . splitFor(vEvent, vN1, vN2) /\ WhenFn(vEvent) = vTimeOfSplit) =>
      vN3 = MultiplicationFn(vNumber, vN1)
      /\ vNewNumber = DivisionFn(vN3, vN2)
      /\ price(vStocks, MeasureFn(vNewNumber, UnitedStatesDollar),
               vTimeAfterSplit)
      /\ meetsTemporally(vTime, vTimeOfSplit)
      /\ meetsTemporally(vTimeOfSplit, vTimeAfterSplit)
. subclass(Bond, Investment)
. subclass(Bond, FinancialInstrument)
%{Bond
"A debt instrument issued for a period of more than one year with 
the purpose of raising capital by borrowing. The Federal government, states, cities, 
corporations, and many other types of institutions sell bonds. A bond is generally a 
promise to repay the principal along with interest on a specified &%maturityDate."}%
. instance(vBond, Bond) =>
      exists vDate: U . maturityDate(vBond, vDate)
. instance(vBond, Bond)
  /\ couponInterest(vBond, vInterest)
  /\ possesses(vBondHolder, vBond) =>
      exists vPeriod: U; vPayment: U
          . periodicPayment(AccountFn(vBond), vInterest, vPeriod)
            /\ destination(vPayment, vBondHolder)
. instance(yield, BinaryPredicate)
. domain(yield, a_1, Investment)
. domain(yield, a_2, FunctionQuantity)
%{yield
"The annual rate of return on an investment, expressed as a 
percentage. For bonds and notes, it is the coupon rate divided by the market price."}%
. instance(couponInterest, BinaryPredicate)
. domain(couponInterest, a_1, Bond)
. domain(couponInterest, a_2, Interest)
%{couponInterest
"(&%couponInterest ?BOND ?INTEREST) means that ?INTEREST is 
the periodic interest payment made to bondholders during the life of the ?BOND."}%
. instance(accruedInterest, BinaryPredicate)
. domain(accruedInterest, a_1, Bond)
. domain(accruedInterest, a_2, Interest)
%{accruedInterest
"The accumulated coupon interest, paid to the seller of a 
bond by the buyer unless the bond is in default."}%
. instance(faceValue, BinaryPredicate)
. domain(faceValue, a_1, Collateral)
. domain(faceValue, a_2, CurrencyMeasure)
%{faceValue
"The nominal dollar amount assigned to a security by the issuer. 
For an equity security, par is usually a very small amount that bears no relationship to 
its market price, except for preferred stock, in which case par is used to calculate dividend 
payments. For a debt security, par is the amount repaid to the investor when the bond matures 
(usually, corporate bonds have a par value of $1000, municipal bonds $5000, and federal bonds 
$10,000)."}%
. subclass(CouponBond, Bond)
%{CouponBond
"An unregistered, negotiable bond on which interest and principal 
are payable to the holder, regardless of whom it was originally issued to. The coupons are 
attached to the bond, and each coupon represents a single interest payment. The holder submits 
a coupon, usually semi-annually, to the issuer or paying agent to receive payment. Coupon bonds 
are being phased out in favor of registered bonds."}%
. instance(AccountFn, UnaryFunction)
. domain(AccountFn, a_1, FinancialAsset)
. range(AccountFn, FinancialAccount)
%{AccountFn
"A unary function that maps a &%FinancialAsset to the &%FinancialAccount 
associated with the Asset."}%
. instance(vAccount, FinancialAccount)
  /\ possesses(vAgent, vAsset)
  /\ vAccount = AccountFn(vAsset) <=>
      accountHolder(vAccount, vAgent)
. subclass(ZeroCouponBond, Bond)
%{ZeroCouponBond
"A bond in which no periodic coupon is paid over the 
life of the contract. Instead, both the principal and the interest are paid at the 
maturity date."}%
. instance(vBond, ZeroCouponBond)
  /\ maturityDate(AccountFn(vBond), vDate)
  /\ possesses(vBondHolder, vBond)
  /\ principalAmount(AccountFn(vBond), vPrincipal)
  /\ agreementPeriod(AccountFn(vBond), vPeriod)
  /\ interestEarned(AccountFn(vBond), vInterest, vPeriod)
  /\ vTotal = AdditionFn(vPrincipal, vInterest) =>
      exists vPayment: U
          . instance(vPayment, Payment)
            /\ destination(vPayment, vBondHolder)
            /\ origin(vPayment, CurrencyFn(vBondAccount))
            /\ transactionAmount(vPayment, vTotal)
. subclass(RegisteredBond, Bond)
%{RegisteredBond
"A bond issued with the name of the owner printed on the 
face of the certificate. It can be transferred to another individual only with the 
owner's endorsement."}%
. subclass(MunicipalBond, Bond)
. subclass(MunicipalBond, TaxFreeInvestment)
%{MunicipalBond
"Bond issued by a state, city, or local government to 
finance operations or special projects; interest on it is often tax-free."}%
. instance(vBond, MunicipalBond) =>
      exists vAgent: U
          . instance(vAgent, Government) /\ issuedBy(vBond, vAgent)
. subclass(CorporateBond, Bond)
. subclass(CorporateBond, TaxableInvestment)
%{CorporateBond
"A bond issued by a corporation. Such bonds usually have 
a par value of $1,000, are taxable, have a term maturity, are paid for out of a sinking 
fund accumulated for that purpose, and are traded on major exchanges."}%
. instance(vBond, CorporateBond) =>
      exists vAgent: U
          . instance(vAgent, Corporation) /\ issuedBy(vBond, vAgent)
. subclass(SecuredBond, Bond)
%{SecuredBond
"Bond backed by collateral, such as a mortgage 
or lien, the title to which would be transferred to the bondholders in the 
event of default."}%
. instance(vBond, SecuredBond) =>
      exists vSecurity: U . securedBy(vBond, vSecurity)
. instance(vBond, SecuredBond)
  /\ securedBy(vBond, vSecurity)
  /\ possesses(vAgent, vBond)
  /\ (exists vDefault: U
          . instance(vDefault, FinancialDefault)
            /\ patient(vDefault, vBond)) =>
      holdsDuring(ImmediateFutureFn(WhenFn(vDefault)),
                  possesses(vAgent, vSecurity))
. subclass(MortgageBond, CorporateBond)
%{MortgageBond
"These are bonds generally bought through a 
government agency that deals in the real estate market.  They are bonds 
issued by mortgage lenders."}%
. subclass(JunkBond, CorporateBond)
%{JunkBond
"A high-risk, non-investment-grade bond with a low 
credit rating, usually BB or lower; as a consequence, it usually has a high 
yield."}%
. instance(vBond, JunkBond) => riskLevel(vBond, HighRisk)
. instance(vBond, JunkBond) => yieldLevel(vBond, HighYield)
. instance(vBond, JunkBond) =>
      bondRating(vBond, a_D_Minus_R_a_t_i_n_g)
. subclass(GovernmentBond, Bond)
%{GovernmentBond
"A bond sold by the U.S. government."}%
. instance(vBond, GovernmentBond) =>
      exists vAgent: U
          . issuedBy(vBond, vAgent) /\ instance(vAgent, Government)
. instance(vBond, GovernmentBond) => riskLevel(vBond, LowRisk)
. instance(vBond, GovernmentBond) => yieldLevel(vBond, LowYield)
. instance(vBond, GovernmentBond) =>
      bondRating(vBond, a_A_A_A_Minus_R_a_t_i_n_g)
. subclass(IndexBond, Bond)
%{IndexBond
"A bond whose cash flow is inflation-adjusted, by 
being linked to the purchasing power of a particular currency."}%
. subclass(PerformanceBond, Bond)
%{PerformanceBond
"A bond issued by an insurance company to 
guarantee satisfactory completion of a project by a contractor."}%
. subclass(TreasuryBond, Bond)
%{TreasuryBond
"A negotiable, coupon-bearing debt obligation 
issued by the U.S. government and backed by its full faith and credit, having 
a maturity of more than 7 years. Interest is paid semi-annually. Exempt from 
state and local taxes."}%
. instance(vBond, TreasuryBond) =>
      exists vAgent: U
          . issuedBy(vBond, vAgent) /\ instance(vAgent, Government)
. subclass(CallableBond, Bond)
%{CallableBond
"A bond which the issuer has the right to redeem 
prior to its maturity date, under certain conditions."}%
. instance(vBond, CallableBond) /\ issuedBy(vBond, vAgent) =>
      capability(Call, agent, vAgent)
. instance(callDate, BinaryPredicate)
. domain(callDate, a_1, Bond)
. domain(callDate, a_2, Day)
%{callDate
"Date, prior to maturity, on which a callable bond 
may be redeemed."}%
. instance(vBond, CallableBond)
  /\ currentAccountBalance(AccountFn(vBond), vDate, vAmount)
  /\ callDate(vBond, vDate) =>
      amountDue(AccountFn(vBond), vAmount, vDate)
. subclass(FinancialRating, Attribute)
%{FinancialRating
"The highest rating is usually AAA-Rating, 
and the lowest is D-Rating."}%
. instance(creditRanking, BinaryPredicate)
. subrelation(creditRanking, attribute)
. domain(creditRanking, a_1, CognitiveAgent)
. domain(creditRanking, a_2, FinancialRating)
%{creditRanking
"(&%creditRanking ?Agent ?Rating) holds if 
?Rating is a &%FinancialRating based on financial analysis by a credit 
bureau, of one's financial history, specifically as it relates to one's 
ability to meet debt obligations. Lenders use this information to decide 
whether to approve a loan."}%
. subrelation(bondRating, attribute)
. domain(bondRating, a_1, Bond)
. domain(bondRating, a_2, FinancialRating)
%{bondRating
"A measure of the quality and safety of a bond, 
based on the issuer's financial condition.  More specifically, an 
evaluation from a rating service indicating the likelihood that a debt 
issuer will be able to meet scheduled interest and principal repayments.  
Typically, AAA is highest (best), and D is lowest (worst)."}%
. instance(a_A_A_A_Minus_R_a_t_i_n_g, FinancialRating)
%{AAA-Rating
"The highest rating given by bond rating agencies"}%
. instance(a_B_Minus_R_a_t_i_n_g, FinancialRating)
%{B-Rating
"A mid-range rating given by bond rating agencies."}%
. instance(a_C_Minus_R_a_t_i_n_g, FinancialRating)
%{C-Rating
"A mid-range rating given by bond rating agencies."}%
. instance(a_D_Minus_R_a_t_i_n_g, FinancialRating)
%{D-Rating
"The lowest rating given by bond rating agencies."}%
. subclass(Option, FinancialContract)
%{Option
"An option is a contract to buy or sell 100 shares 
of a stock at a fixed price (the strike price) on or before a fixed date."}%
. instance(vOption, Option) =>
      exists vType: U; vDate: U; vStock: U; vPrice: U
          . (vType = CallOption \/ vType = PutOption)
            /\ instance(vOption, vType)
            /\ expirationDate(vOption, vDate)
            /\ strikePrice(vOption, vPrice)
            /\ underlier(vOption, vStocks)
            /\ measure(vStock, MeasureFn(a_1_0_0, Share))
. subclass(ConventionalOption, Option)
%{ConventionalOption
"Short-term option contracts."}%
. instance(vOption, ConventionalOption) =>
      exists vNumber: U
          . agreementPeriod(vOption, vPeriod)
            /\ duration(vPeriod, MeasureFn(vNumber, MonthDuration))
            /\ lessThan(vNumber, a_9)
. subclass(LEAPS, Option)
%{LEAPS
"Calls and puts with an expiration as long as 
thirty-nine months. Currently, equity LEAPS have two series at any 
time with a January expiration. For example, in October 2000, LEAPS 
are available with expirations of January 2002 and January 2003."}%
. instance(vOption, ConventionalOption) =>
      exists vNumber: U
          . agreementPeriod(vOption, vPeriod)
            /\ duration(vPeriod, MeasureFn(vNumber, MonthDuration))
            /\ lessThan(vNumber, a_3_9)
. subrelation(optionHolder, agreementMember)
. domain(optionHolder, a_1, Option)
. domain(optionHolder, a_2, CognitiveAgent)
%{optionHolder
"(&%optionHolder ?Option ?Agent) means that 
?Agent is the holder of the option."}%
. subrelation(optionSeller, agreementMember)
. domain(optionSeller, a_1, Option)
. domain(optionSeller, a_2, CognitiveAgent)
%{optionSeller
"(&%optionSeller ?Option ?Agent) means that 
?Agent is the writer of the option."}%
. instance(strikePrice, BinaryPredicate)
. domain(strikePrice, a_1, FinancialInstrument)
. domain(strikePrice, a_2, CurrencyMeasure)
%{strikePrice
"The specified price on an option contract at 
which the contract may be exercised, whereby a call option buyer can buy 
the underlier or a put option buyer can sell the underlier."}%
. subrelation(expirationDate, date)
. domain(expirationDate, a_1, Contract)
. domain(expirationDate, a_2, Day)
%{expirationDate
"(&%expirationDate ?Contract ?Date) means that 
?Date is the date on which ?Contract expires."}%
. expirationDate(vContract, vDate) =>
      exists vPeriod: U
          . agreementPeriod(vContract, vPeriod) /\ finishes(vDate, vPeriod)
. subclass(CallOption, Option)
%{CallOption
"An option contract that gives the holder the 
right to buy a certain quantity (usually 100 shares) of an underlying 
security from the writer of the option, at a specified price (the strike 
price) up to a specified date (the expiration date)."}%
. instance(vOption, Option)
  /\ optionHolder(vOption, vAgent)
  /\ strikePrice(vOption, vPrice)
  /\ expirationDate(vOption, vExpDate)
  /\ underlier(vOption, vStocks)
  /\ price(vStocks, vPrice, vTime)
  /\ instance(vTime, TimeInterval)
  /\ before(EndFn(vTime), BeginFn(vExpDate)) =>
      holdsRight(KappaFn(vBuy,
                         a_a_n_d(instance(vBuy, Buying), patient(vBuy, vStocks),
                                 time(vBuy, vTime),
                                 measure(vStocks, MeasureFn(a_1_0_0, Share)),
                                 agent(vBuy, vAgent))),
                 vAgent)
. instance(vOption, Option)
  /\ optionSeller(vOption, vSeller)
  /\ strikePrice(vOption, vPrice)
  /\ expirationDate(vOption, vExpDate)
  /\ underlier(vOption, vStocks)
  /\ price(vStocks, vPrice, vTime)
  /\ instance(vTime, TimeInterval)
  /\ before(EndFn(vTime), BeginFn(vExpDate)) =>
      holdsObligation(KappaFn(vSell,
                              a_a_n_d(instance(vSell, Selling),
                                      patient(vSell, vStocks),
                                      time(vSell, vTime),
                                      measure(vStocks,
                                              MeasureFn(a_1_0_0, Share)),
                                      agent(vSell, vAgent))),
                      vSeller)
. subclass(PutOption, Option)
%{PutOption
"An option contract that gives the holder the 
right to sell a certain quantity of an underlying security to the writer 
of the option, at a specified price (strike price) up to a specified date 
(expiration date)."}%
. instance(vOption, Option)
  /\ optionHolder(vOption, vAgent)
  /\ strikePrice(vOption, vPrice)
  /\ expirationDate(vOption, vExpDate)
  /\ price(vStocks, vPrice, vTime)
  /\ instance(vTime, TimeInterval)
  /\ before(EndFn(vTime), BeginFn(vExpDate))
  /\ underlier(vOption, vStocks) =>
      holdsRight(KappaFn(vSell,
                         a_a_n_d(instance(vSell, Selling),
                                 patient(vSell, vStocks), time(vSell, vTime),
                                 measure(vStocks, MeasureFn(a_1_0_0, Share)),
                                 agent(vSell, vAgent))),
                 vAgent)
. instance(vOption, Option)
  /\ optionSeller(vOption, vAgent)
  /\ strikePrice(vOption, vPrice)
  /\ expirationDate(vOption, vExpDate)
  /\ price(vStocks, vPrice, vTime)
  /\ instance(vTime, TimeInterval)
  /\ before(EndFn(vTime), BeginFn(vExpDate))
  /\ underlier(vOption, vStocks) =>
      holdsObligation(KappaFn(vBuy,
                              a_a_n_d(instance(vBuy, Buying),
                                      patient(vBuy, vStocks), time(vBuy, vTime),
                                      measure(vStocks,
                                              MeasureFn(a_1_0_0, Share)),
                                      agent(vBuy, vAgent))),
                      vAgent)
. subclass(StockOption, Option)
%{StockOption
"An option in which the underlier is the 
common stock of a corporation, giving the holder the right to buy or 
sell its stock, at a specified price, by a specific date."}%
. instance(vOption, StockOption) /\ underlier(vOption, vStock) =>
      instance(vStock, CommonStock)
. instance(premium, BinaryPredicate)
. domain(premium, a_1, Option)
. domain(premium, a_2, CurrencyMeasure)
%{premium
"Total price of an option."}%
. premium(vOption, vPremium) /\ optionHolder(vOption, vAgent) =>
      potentialLoss(vAgent, vOption, vPremium)
. instance(underlier, BinaryPredicate)
. domain(underlier, a_1, Option)
. domain(underlier, a_2, FinancialInstrument)
%{underlier
"(&%underlier ?Option ?Instrument) means that 
?Instrument is a security which is subject to delivery upon exercise of 
?Option."}%
. instance(ExerciseAnOption, FinancialTransaction)
%{ExerciseAnOption
"An activity when the owner of the the &%Option 
contract invokes his rights.  In the case of a call, the option owner buys the 
underlying stock. In the case of a put, the option owner sells the underlying stock."}%
. instance(vExercise, ExerciseAnOption)
  /\ patient(vExercise, vOption)
  /\ instance(vOption, CallOption)
  /\ time(vExercise, vTime)
  /\ underlier(vOption, vStocks) =>
      exists vBuy: U
          . instance(vBuy, Buying)
            /\ patient(vBuy, vStocks)
            /\ time(vBuy, vTime)
            /\ measure(vStocks, MeasureFn(a_1_0_0, Share))
. instance(vExercise, ExerciseAnOption)
  /\ patient(vExercise, vOption)
  /\ instance(vOption, PutOption)
  /\ time(vExercise, vTime)
  /\ underlier(vOption, vStocks) =>
      exists vSell: U
          . instance(vSell, Selling)
            /\ patient(vSell, vStocks)
            /\ time(vSell, vTime)
            /\ measure(vStocks, MeasureFn(a_1_0_0, Share))
. instance(AmericanStyleOption, Option)
%{AmericanStyleOption
"An option that can be exercised at any time 
prior to its expiration date"}%
. instance(vOption, AmericanStyleOption)
  /\ optionHolder(vOption, vAgent)
  /\ expirationDate(vOption, vDay) =>
      holdsRight(True
                     when exists vExercise: U
                              . instance(vExercise, ExerciseAnOption)
                                /\ patient(vExercise, vOption)
                                /\ before(EndFn(WhenFn(vExercise)), EndFn(vDay))
                     else False,
                 vAgent)
. instance(EuropeanStyleOption, Option)
%{EuropeanStyleOption
"An option that can be exercised only during 
a specified period of time just prior to its expiration."}%
. instance(vOption, EuropeanStyleOption)
  /\ expirationDate(vOption, vDate) =>
      exists vPeriod: U
          . instance(vPeriod, TimeInterval)
            /\ finishes(vPeriod, vDate)
            /\ ((exists vTime: U
                     . instance(vExercise, ExerciseAnOption)
                       /\ WhenFn(vExercise) = vTime) =>
                    temporalPart(vTime, vPeriod))
. subclass(EquityOption, Option)
%{EquityOption
"An option on shares of an individual common stock."}%
. subclass(FillingAnOrder, FinancialTransaction)
%{FillingAnOrder
"Execute an order or buy or sell a security 
or commodity."}%
. subclass(CancellingAnOrder, FinancialTransaction)
. instance(vKill, CancellingAnOrder) /\ patient(vKill, vOrder) =>
      not agreementActive(vOrder, ImmediateFutureFn(WhenFn(vKill)))
. subclass(IOCOrder, FinancialOrder)
%{IOCOrder
"Immediate or cancel Order is a type of option order 
which gives the trading crowd one opportunity to take the other side of the 
trade. After being announced, the order will be either partially or totally 
filled with any remaining balance immediately cancelled. An IOC order, which 
can be considered a type of day order, cannot be used as part of a GTC order 
since it will be cancelled shortly after being entered. The difference between 
fill-or-kill (FOK) orders and IOC orders is that a IOC order may be partially 
executed."}%
. instance(vOrder, IOCOrder) /\ agreementPeriod(vOrder, vPeriod) =>
      (exists vFill: U; vTime1: U
           . instance(vFill, FillingAnOrder)
             /\ patient(vFill, vOrder)
             /\ WhenFn(vFill) = vTime1
             /\ starts(vTime1, vPeriod))
      \/ (exists vKill: U; vTime2: U
              . instance(vKill, CancellingAnOrder)
                /\ patient(vKill, vOrder)
                /\ WhenFn(vKill) = vTime2
                /\ starts(vTime2, vPeriod))
. subclass(FOKOrder, FinancialOrder)
%{FOKOrder
"Fill-or-kill order is a type of option order 
which requires that the order be executed completely or not at all.  A 
fill-or-kill order is similar to an all-or-none (AON) order.  The 
difference is that if the order cannot be completely executed (i.e., 
filled in its entirety) as soon as it is announced in the trading crowd, 
it is to be 'killed' (i.e., cancelled) immediately.  Unlike an AON order, 
a FOK order cannot be used as part of a GTC order."}%
. instance(vOrder, FOKOrder) /\ agreementPeriod(vOrder, vPeriod) =>
      (exists vFill: U; vTime1: U
           . instance(vFill, FillingAnOrder)
             /\ patient(vFill, vOrder)
             /\ WhenFn(vFill) = vTime1
             /\ starts(vTime1, vPeriod))
      \/ (exists vKill: U; vTime2: U
              . instance(vKill, CancellingAnOrder)
                /\ patient(vKill, vOrder)
                /\ WhenFn(vKill) = vTime2
                /\ starts(vTime2, vPeriod))
. subclass(AONOrder, FinancialOrder)
%{AONOrder
"All-or-none order (AON) is a type of option order 
which requires that the order be executed completely or not at all. An AON 
order may be either a day order or a GTC order."}%
. instance(vOrder, AONOrder) =>
      instance(vOrder, DayOrder) \/ instance(vOrder, GTCOrder)
. subclass(GTCOrder, FinancialOrder)
%{GTCOrder
"Good-'til-cancelled (GTC) order is a type of limit order 
that remains in effect until it is either executed (filled) or cancelled, as opposed 
to a day order, which expires if not executed by the end of the trading day. A GTC 
option order is an order which if not executed will be automatically cancelled at the 
option's expiration"}%
. instance(vOrder, GTCOrder) /\ agreementPeriod(vOrder, vPeriod) =>
      (exists vExecute: U
           . instance(vExecute, FillingAnOrder)
             /\ patient(vExecute, vOrder)
             /\ WhenFn(vExecute) = vTime
             /\ overlapsTemporally(vTime, vPeriod))
      \/ (exists vCancel: U
              . instance(vCancel, CancellingAnOrder)
                /\ patient(vCancel, vOrder)
                /\ WhenFn(vCancel) = vEnd
                /\ finishes(vEnd, vPeriod))
. subclass(DayOrder, FinancialOrder)
%{DayOrder
"A type of option order which instructs the broker 
to cancel any unfilled portion of the order at the close of trading on the 
day the order is first entered."}%
. instance(vOrder, DayOrder) =>
      agreementPeriod(vOrder, vPeriod)
      /\ duration(vPeriod, MeasureFn(a_1, DayDuration))
. subclass(MNHOrder, FinancialOrder)
%{MNHOrder
"A Market-not-held order is a type of market order 
which allows the investor to give discretion to the floor broker regarding 
the price and/or time at which a trade is executed."}%
. subclass(MOCOrder, FinancialOrder)
%{MOCOrder
"A Market-on-close order is a type of option order 
which requires that an order be executed at or near the close of trading on 
the day the order is entered. A MOC order, which can be considered a type of 
day order, cannot be used as part of a GTC order"}%
. instance(vOrder, MOCOrder) => instance(vOrder, DayOrder)
. subclass(NHOrder, FinancialOrder)
%{NHOrder
"A not-held order is a type of order which releases 
normal obligations implied by the other terms of the order. For example, a 
limit order designated as 'not-held' allows discretion to the floor trader in 
filling the order when the market trades at the limit price of the order. In 
this case, there is no obligation to provide the customer with an execution if 
the market trades through the limit price on the order."}%
. subclass(OCOOrder, FinancialOrder)
%{OCOOrder
"One-cancels-other order (OCO) is a type of option 
order which treats two or more option orders as a package, whereby the execution 
of any one of the orders causes all the orders to be reduced by the same amount. 
For example, the investor would enter an OCO order if he/she wished to buy 
10 May 60 calls or 10 June 60 calls or any combination of the two which when 
summed equaled 10 contracts. An OCO order may be either a day order or a GTC order"}%
. instance(vOrder, OCOOrder) =>
      instance(vOrder, DayOrder) \/ instance(vOrder, GTCOrder)
. subclass(Bullish, InvestmentAttribute)
%{Bullish
"An attribute describing the opinion that a stock, or the 
market in general, will rise in price -- a positive or optimistic outlook."}%
. subclass(Bearish, InvestmentAttribute)
%{Bearish
"An adjective describing the opinion that a stock, or 
a market in general, will decline in price -- a negative or pessimistic outlook."}%
. subclass(IndexOption, Option)
%{IndexOption
"An option whose underlying interest is an index. 
Generally, index options are cash-settled."}%
. instance(inTheMoney, BinaryPredicate)
. domain(inTheMoney, a_1, Option)
. domain(inTheMoney, a_2, TimePosition)
%{inTheMoney
"A call option is in the money if the stock 
price is above the strike price.  A put option is in the money if the 
stock price is below the strike price."}%
. (exists vStock: U; vStockPrice: U; vStrikePrice: U
       . instance(vOption, CallOption)
         /\ underlier(vOption, vStock)
         /\ price(vStock, vStockPrice, vTime)
         /\ strikePrice(vOption, vStrikePrice)
         /\ lessThan(vStrikePrice, vStockPrice)) <=>
      inTheMoney(vOption, vTime)
. (exists vStock: U; vStockPrice: U; vStrikePrice: U
       . instance(vOption, PutOption)
         /\ underlier(vOption, vStock)
         /\ price(vStock, vStockPrice, vTime)
         /\ strikePrice(vOption, vStrikePrice)
         /\ lessThan(vStockPrice, vStrikePrice)) <=>
      inTheMoney(vOption, vTime)
. instance(atTheMoney, BinaryPredicate)
. domain(atTheMoney, a_1, Option)
. domain(atTheMoney, a_2, TimePosition)
%{atTheMoney
"A term that describes an option with a strike 
price that is equal to the current market price of the underlying stock."}%
. (exists vStock: U; vStockPrice: U; vStrikePrice: U
       . instance(vOption, Option)
         /\ underlier(vOption, vStock)
         /\ price(vStock, vStockPrice, vTime)
         /\ strikePrice(vOption, vStrikePrice)
         /\ vStockPrice = vStrikePrice) <=>
      atTheMoney(vOption, vTime)
. instance(outOfTheMoney, BinaryPredicate)
. domain(outOfTheMoney, a_1, Option)
. domain(outOfTheMoney, a_2, TimePosition)
%{outOfTheMoney
"A call option is out of the money if the 
stock price is below its strike price. A put option is out of the money 
if the stock price is above its strike price."}%
. (exists vStock: U; vStockPrice: U; vStrikePrice: U
       . instance(vOption, CallOption)
         /\ underlier(vOption, vStock)
         /\ price(vStock, vStockPrice, vTime)
         /\ strikePrice(vOption, vStrikePrice)
         /\ lessThan(vStockPrice, vStrikePrice)) <=>
      outOfTheMoney(vOption, vTime)
. (exists vStock: U; vStockPrice: U; vStrikePrice: U
       . instance(vOption, PutOption)
         /\ underlier(vOption, vStock)
         /\ price(vStock, vStockPrice, vTime)
         /\ strikePrice(vOption, vStrikePrice)
         /\ lessThan(vStrikePrice, vStockPrice)) <=>
      outOfTheMoney(vOption, vTime)
. subclass(OptionStrategy, FinancialTransaction)
%{OptionStrategy
"A collection of buying/selling options 
whose purpose is to result in an optimal profit for the investor."}%
. subclass(SingleOption, OptionStrategy)
%{SingleOption
"A put or call option by itself, as opposed to 
multiple options as used in a spread or straddle."}%
. instance(vStrategy, SingleOption) =>
      CardinalityFn(KappaFn(vOption, patient(vStrategy, vOption))) = a_1
. subclass(SpreadOption, OptionStrategy)
%{SpreadOption
"The purchase of one option and the 
simultaneous sale of a related option, such as two options of the same 
class but different strike prices and/or expiration dates."}%
. instance(vSpread, SpreadOption) =>
      exists vOption1: U; vOption2: U; vBuy: U; vSell: U; vTime: U
          . instance(vOption1, Option)
            /\ instance(vOption2, Option)
            /\ instance(vBuy, Buying)
            /\ instance(vSell, Selling)
            /\ patient(vBuy, vOption1)
            /\ patient(vSell, vOption2)
            /\ time(vBuy, vTime)
            /\ time(vSell, vTime)
. subclass(ButterflySpread, SpreadOption)
%{ButterflySpread
"A complex option strategy that involves 
selling two calls and buying two calls on the same or different markets, 
with several maturity dates.  One of the options has a higher exercise 
price and the other has a lower exercise price than the other two options.  
The payoff diagram resembles the shape of a butterfly."}%
. instance(vSpread, ButterflySpread) =>
      exists vCall1: U; vCall2: U; vCall3: U; vCall4: U; vPrice1: U;
             vPrice2: U; vPrice3: U; vPrice4: U
          . instance(vCall1, CallOption)
            /\ instance(vCall2, CallOption)
            /\ instance(vCall3, CallOption)
            /\ instance(vCall4, CallOption)
            /\ strikePrice(vCall1, vPrice1)
            /\ strikePrice(vCall2, vPrice2)
            /\ strikePrice(vCall3, vPrice3)
            /\ strikePrice(vCall4, vPrice4)
            /\ lessThan(vPrice1, vPrice2)
            /\ lessThan(vPrice1, vPrice3)
            /\ greaterThan(vPrice4, vPrice2)
            /\ greaterThan(vPrice4, vPrice2)
. subclass(Straddle, OptionStrategy)
%{Straddle
"The purchase or sale of an equal number of puts and 
calls, with the same strike price and expiration dates."}%
. instance(vStraddle, Straddle) =>
      exists vPrice: U; vDate: U; vNumber: U
          . CardinalityFn(KappaFn(vCall,
                                  a_a_n_d(instance(vCall, CallOption),
                                          part(vCall, vStraddle)))) =
                vNumber
            /\ CardinalityFn(KappaFn(vPut,
                                     a_a_n_d(instance(vPut, PutOption),
                                             part(vPut, vStraddle)))) =
                   vNumber
            /\ (forall vOption: U
                    . instance(vOption, Option) /\ part(vOption, vStraddle) =>
                          expirationDate(vOption, vDate)
                          /\ strikePrice(vOption, vPrice))
. subclass(LongStraddle, Straddle)
%{LongStraddle
"A straddle in which a long position is taken in 
both a put and a call option"}%
. subclass(ShortSale, FinancialTransaction)
%{ShortSale
"Borrowing a security (or commodity futures 
contract) from a broker and selling it, with the understanding that it 
must later be bought back (hopefully at a lower price) and returned to the 
broker.  SEC rules allow investors to sell short only on an uptick or a 
zero-plus tick, to prevent 'pool operators' from driving down a stock 
price through heavy short-selling, then buying the shares for a large 
profit."}%
. subclass(BorrowedStock, Stock)
%{BorrowedStock
"Stock in a short sale."}%
. subclass(StockMarketTransaction, FinancialTransaction)
%{StockMarketTransaction
"Any &%FinancialTransaction which involves 
&%Stock and which occurs in a &%StockMarket."}%
. instance(vTransaction, StockMarketTransaction) =>
      exists vMarket: U
          . instance(vMarket, StockMarket) /\ located(vTransaction, vMarket)
. instance(vTransaction, StockMarketTransaction)
  /\ patient(vTransaction, vStock) =>
      instance(vStock, Stock)
. subclass(Uptick, StockMarketTransaction)
%{Uptick
"A stock market transaction (or sometimes, a quote) 
at a price higher than the preceding one for the same security."}%
. instance(vUptick, Uptick)
  /\ patient(vUptick, vStock)
  /\ WhenFn(vUptick) = vTime1
  /\ price(vStock, vPrice1, vTime1) =>
      exists vTransaction: U; vTime2: U
          . instance(vTransaction, StockMarketTransaction)
            /\ patient(vTransaction, vStock)
            /\ WhenFn(vTransaction) = vTime2
            /\ meetsTemporally(vTime2, vTime1)
            /\ price(vStock, vPrice2, vTime2)
            /\ lessThan(vPrice2, vPrice1)
. subclass(Downtick, StockMarketTransaction)
%{Downtick
"A stock market transaction (or sometimes, a quote) 
at a price lower than the preceding one for the same security."}%
. instance(vDowntick, Downtick)
  /\ patient(vDowntick, vStock)
  /\ WhenFn(vDowntick) = vTime1
  /\ price(vStock, vPrice1, vTime1) =>
      exists vTransaction: U; vTime2: U
          . instance(vTransaction, StockMarketTransaction)
            /\ patient(vTransaction, vStock)
            /\ WhenFn(vTransaction) = vTime2
            /\ meetsTemporally(vTime2, vTime1)
            /\ price(vStock, vPrice2, vTime2)
            /\ greaterThan(vPrice2, vPrice1)
. subclass(Employment, ServiceContract)
. subclass(Employment, FinancialContract)
. employs(vOrg, vAgent) <=>
      (exists vEmployment: U
           . instance(vEmployment, Employment)
             /\ agreementMember(vEmployment, vOrg)
             /\ agreementMember(vEmployment, vAgent))
. instance(income, TernaryPredicate)
. domain(income, a_1, Human)
. domain(income, a_2, CurrencyMeasure)
. domain(income, a_3, TimeInterval)
%{income
"(&%incomeOf ?Agent ?Money ?Period) means that 
?Money is the amount of money or its equivalent received during a period 
of time in exchange for labor or services, from the sale of goods or 
property, or as profit from financial investments"}%
. instance(monthlyIncome, AsymmetricRelation)
. domain(monthlyIncome, a_1, Human)
. domain(monthlyIncome, a_2, CurrencyMeasure)
%{monthlyIncome
"(&%monthlyIncome ?Agent ?Money) means that 
?Money is the amount of money received during one month period"}%
. monthlyIncome(vAgent, vMoney) <=>
      (exists vMonth: U
           . instance(vMonth, Month) /\ income(vAgent, vMoney, vMonth))
. instance(incomeEarned, TernaryPredicate)
. domain(incomeEarned, a_1, Human)
. domain(incomeEarned, a_2, CurrencyMeasure)
. domain(incomeEarned, a_3, OrganizationalProcess)
%{incomeEarned
"(&%incomeEarned ?Agent ?Money ?Action) means 
that ?Agent earned the amount of money ?Money from performing ?Action.  Note 
that &%incomeEarned denotes that amount of money made before taxes are 
deducted."}%
. incomeEarned(vAgent, vMoney, vActivity) =>
      agent(vActivity, vAgent)
. subrelation(taxDeferredIncome, incomeEarned)
. domain(taxDeferredIncome, a_1, Human)
. domain(taxDeferredIncome, a_2, CurrencyMeasure)
. domain(taxDeferredIncome, a_3, OrganizationalProcess)
%{taxDeferredIncome
"Income whose taxes can be postponed 
until a later date.  Examples include IRA, 401(k), Keogh Plan, annuity, 
Savings Bond and Employee Stock Ownership Plan."}%
. taxDeferredIncome(vAgent, vIncome, vActivity)
  /\ time(vActivity, vTime) =>
      not (exists vTax: U
               . instance(vTax, Tax)
                 /\ causes(vActivity, vTax)
                 /\ time(vTax, vTime))
. subrelation(afterTaxIncome, incomeEarned)
. domain(afterTaxIncome, a_1, Human)
. domain(afterTaxIncome, a_2, CurrencyMeasure)
. domain(afterTaxIncome, a_3, OrganizationalProcess)
%{afterTaxIncome
"An amount (usually income) after taxes 
have been subtracted."}%
. (exists vAgent: U; vTax: U
       . incomeEarned(vAgent, vIncome, vActivity)
         /\ amountCharged(vTax, vTaxAmount)
         /\ causes(vActivity, vTax)
         /\ vATIncome = SubtractionFn(vIncome, vTaxAmount)) <=>
      afterTaxIncome(vActivity, vATIncome)
. subrelation(beforeTaxIncome, incomeEarned)
. domain(beforeTaxIncome, a_1, Human)
. domain(beforeTaxIncome, a_2, CurrencyMeasure)
. domain(beforeTaxIncome, a_3, OrganizationalProcess)
%{beforeTaxIncome
"Income before taxes are deducted"}%
. instance(employeeContribution, TernaryPredicate)
. domain(employeeContribution, a_1, Human)
. domain(employeeContribution, a_2, CurrencyMeasure)
. domain(employeeContribution, a_3, TimeInterval)
%{employeeContribution
"An individual's contribution to his/her 
own retirement plan, often tax-deferred."}%
. employeeContribution(vAgent, vMoney, vPeriod) =>
      exists vOrg: U; vPlan: U
          . instance(vPlan, PensionPlan)
            /\ employs(vOrg, vAgent)
            /\ agent(vPlan, vOrg)
            /\ destination(vPlan, vAgent)
. instance(compensationPackage, TernaryPredicate)
. domain(compensationPackage, a_1, Human)
. domain(compensationPackage, a_2, CurrencyMeasure)
. domain(compensationPackage, a_3, TimePosition)
%{compensationPackage
"The total monetary value an employee 
receives during a certain time period."}%
. compensationPackage(vAgent, vMoney, vPeriod) =>
      exists vActivity: U
          . instance(vActivity, Working)
            /\ agent(vActivity, vAgent)
            /\ vPeriod = WhenFn(vActivity)
            /\ incomeEarned(vAgent, vMoney, vActivity)
. subclass(PensionPlan, FinancialTransaction)
. subclass(PensionPlan, Planning)
%{PensionPlan
"A qualified retirement plan set up by a 
corporation, labor union, government, or other organization for its 
employees.  Examples include profit-sharing plans, stock bonus and 
Employee Stock Ownership Plans, thrift plans, target benefit plans, money 
purchase plans, and defined benefit plans."}%
. instance(vPlan, PensionPlan)
  /\ destination(vPlan, vAgent)
  /\ attribute(vAgent, Retired)
  /\ a_r_e_s_u_l_t(vPlan, vCurrency) =>
      uses(vAgent, vCurrency)
. instance(vPlan, PensionPlan)
  /\ destination(vPlan, vAgent)
  /\ employs(vOrg, vAgent) =>
      agent(vPlan, vOrg)
. subclass(ProfitSharingPlan, FinancialTransaction)
%{ProfitSharingPlan
"An arrangement in which an employer 
shares its profits with its employees.  The compensation can be stocks, 
bonds, or cash, and can be immediate or deferred until retirement."}%
. instance(vPlan, ProfitSharingPlan)
  /\ destination(vPlan, vAgent)
  /\ employs(vOrg, vAgent)
  /\ profit(vActivity, vProfit)
  /\ agent(vActivity, vOrg) =>
      exists vCompensation: U; vPayment: U
          . instance(vPayment, Payment)
            /\ transactionAmount(vPayment, vCompensation)
            /\ lessThan(vCompensation, vProfit)
            /\ destination(vPayment, vAgent)
. subclass(IndividualRetirementAccount, SavingsAccount)
. subclass(IndividualRetirementAccount, PersonalAccount)
. subclass(IndividualRetirementAccount, PensionPlan)
%{IndividualRetirementAccount
"A tax-deferred retirement 
account for an individual that permits individuals to set aside up to 
$2,000 per year, with earnings tax-deferred until withdrawals begin at age 
59 1/2 or later (or earlier, with a 10% penalty).  Only those who do not 
participate in a pension plan at work or who do participate and meet 
certain income guidelines can make deductible contributions to an IRA.  
All others can make contributions to an IRA on a non-deductible basis.  
Such contributions qualify as a deduction against income earned in that 
year and interest accumulates tax-deferred until the funds are withdrawn."}%
. subclass(RothIRAAccount, IndividualRetirementAccount)
%{RothIRAAccount
"An individual retirement account in which a person 
can set aside after-tax income up to a specified amount each year. Earnings on the 
account are tax-free, and tax-free withdrawals may be made at retirement age."}%
. subclass(a_4_0_1_K_Minus_P_l_a_n, DefinedContributionPlan)
%{401K-Plan
"A defined contribution plan offered by a 
corporation to its employees, which allows employees to set aside 
tax-deferred income for retirement purposes.  The name 401(k) comes from 
the IRS section describing the program."}%
. subclass(DefinedContributionPlan, PensionPlan)
%{DefinedContributionPlan
"A company retirement plan, such as 
a 401(k) or 403(b), in which the employee elects to defer some amount of 
his/her salary into the plan and bears the investment risk."}%
. subclass(a_4_0_3_B_Minus_P_l_a_n, DefinedContributionPlan)
%{403B-Plan
"A retirement plan similar to a 401(k) plan, but 
one which is offered by non-profit organizations, such as universities and 
some charitable organizations, rather than corporations."}%
. subclass(SARSEPPlan, DefinedContributionPlan)
. subclass(Rollover, FinancialTransaction)
%{Rollover
"A tax-free reinvestment of a distribution from a 
qualified retirement plan into an IRA or other qualified plan within 60 days.  
Also called IRA rollover. Or more generally, a movement of funds from one investment 
to another."}%
. subclass(DirectRollover, Rollover)
%{DirectRollover
"A distribution from qualified pension plan, 401(k)
 plan, or 403(b) plan, that is remitted directly to the trustee, custodian, or 
issuer of the receiving IRA and is reported to the IRS as a rollover. This can only 
be done once per year, per account."}%
. subclass(a_4_0_8_K_Minus_P_l_a_n, PensionPlan)
%{408K-Plan
"A simpler alternative to a 401(k) plan available 
only to companies with 25 or fewer employees, which gives employees the 
opportunity to make contributions to their SEP accounts with pre-tax 
dollars and reduce their current year's net income."}%
. instance(accountNumber, BinaryPredicate)
. instance(accountNumber, AsymmetricRelation)
. domain(accountNumber, a_1, FinancialAccount)
. domain(accountNumber, a_2, PositiveInteger)
. instance(stockSymbol, BinaryPredicate)
. instance(stockSymbol, AsymmetricRelation)
. domain(stockSymbol, a_1, Stock)
. domain(stockSymbol, a_2, SymbolicString)
%{stockSymbol
"A unique symbol assigned to a security. NYSE and 
AMEX listed stocks have symbols of three characters or less. NASDAQ-listed 
securities have four or five characters."}%
. subclass(VisaCard, CreditCard)
. subclass(MasterCard, CreditCard)
. subclass(DiscoverCard, CreditCard)
. subclass(AmericanExpressCard, CreditCard)
. instance(checkNumber, AsymmetricRelation)
. domain(checkNumber, a_1, Check)
. domain(checkNumber, a_2, PositiveInteger)
. instance(netAmount, BinaryPredicate)
. instance(netAmount, AsymmetricRelation)
. domain(netAmount, a_1, Investment)
. domain(netAmount, a_2, CurrencyMeasure)
%{netAmount
"The amount due the supplier after commissions 
have been deducted."}%
. instance(BrokerageAccount, InvestmentAccount)
%{BrokerageAccount
"A fund that a customer has entrusted to 
a securities brokerage."}%
. subrelation(effectiveDate, date)
. domain(effectiveDate, a_1, Contract)
. domain(effectiveDate, a_2, Day)
%{effectiveDate
"Legal date an agreement or document goes into force."}%
. effectiveDate(vAgreement, vStartDate) <=>
      (exists vPeriod: U
           . agreementPeriod(vAgreement, vPeriod)
             /\ starts(vStartDate, vPeriod))
. instance(closingPrice, TernaryPredicate)
. domain(closingPrice, a_1, Stock)
. domain(closingPrice, a_2, CurrencyMeasure)
. domain(closingPrice, a_3, Day)
%{closingPrice
"(&%closingPrice ?Stock ?Amount ?Day) means that the closing 
price of the &%Stock ?Stock on the &%Day ?Day was ?Amount."}%
. subrelation(finalPrice, monetaryValue)
. domain(finalPrice, a_1, Stock)
. domain(finalPrice, a_2, CurrencyMeasure)
. subclass(Cash, FinancialInstrument)
. subclass(Cash, FinancialAsset)
%{Cash
"Circulating paper money"}%
. instance(vCash, Cash) =>
      exists vValue: U . monetaryValue(vCash, vValue)
. instance(riskTolerance, BinaryPredicate)
. instance(riskTolerance, AsymmetricRelation)
. domain(riskTolerance, a_1, Investor)
. domain(riskTolerance, a_2, RiskAttribute)
. riskTolerance(vAgent, vLevel)
  /\ instance(vInvestment, Investment)
  /\ possesses(vAgent, vInvestment) =>
      riskLevel(vInvestment, vLevel)
. instance(cardCode, BinaryPredicate)
. subrelation(cardCode, represents)
. domain(cardCode, a_1, ContentBearingObject)
. domain(cardCode, a_2, BankCard)
%{cardCode
"(&%cardCode ?Code ?Card) means that ?Code represents 
the account number of the BankCard ?Card."}%
. cardCode(vCode, vCard) /\ cardAccount(vCard, vAccount) =>
      exists vEncoding: U
          . instance(vEncoding, Encoding) /\ patient(vEncoding, vAccount)
. subclass(ValidCard, BankCard)
%{ValidCard
"A class of valid BankCards"}%
. instance(vAuthorization, AuthorizationOfTransaction)
  /\ instance(vTransaction, FinancialTransaction)
  /\ instance(vCard, BankCard)
  /\ instrument(vTransaction, vCard)
  /\ causes(vAuthorization, vTransaction) =>
      instance(vCard, ValidCard)
. subclass(ExpiredCard, BankCard)
. disjoint(ExpiredCard, ValidCard)
%{ExpiredCard
"A class of expired BankCards."}%
. holdsDuring(vTime, instance(vCard, ExpiredCard))
  /\ cardAccount(vCard, vAccount) =>
      not agreementActive(vCard, vTime)
. instance(pin, BinaryPredicate)
. subrelation(pin, represents)
. domain(pin, a_1, SymbolicString)
. domain(pin, a_2, BankCard)
%{pin
"(&%pin ?PIN ?Card) means that ?PIN is a personal identification 
number linked to the ?Card."}%
. instance(vCard, DebitCard)
  /\ possesses(vCard, vAgent)
  /\ instance(vTransaction, FinancialTransaction)
  /\ instrument(vTransaction, vCard) =>
      exists vPIN: U; vEnter: U
          . pin(vPIN, vCard)
            /\ instance(vEnter, EnteringAPin)
            /\ patient(vEnter, vPIN)
            /\ agent(vEnter, vAgent)
. subclass(EnteringAPin, AuthorizationOfTransaction)
. subclass(EnteringAPing, ContentDevelopment)
%{EnteringAPin
"A subclass of &%AuthorizationOfTransaction where 
a customer enters his/her personal identification number."}%
. instance(vEnter, EnteringAPin) =>
      exists vPin: U; vCard: U
          . pin(vPin, vCard) /\ patient(vEnter, vPin)
. subclass(VerifyingCardCode, AuthorizationOfTransaction)
%{VerifyingCardCode
"A subclass of &%AuthorizationOfTransaction 
where an ATM machine checks the code of the BankCard inserted to this machine."}%
. instance(vCheck, VerifyingCardCode)
  /\ patient(vCheck, vCode)
  /\ cardCode(vCode, vCard) =>
      exists vDecode: U
          . instance(vDecode, Decoding)
            /\ subProcess(vDecode, vCheck)
            /\ patient(vDecode, vCode)
. subclass(ATMMachine, StationaryArtifact)
%{ATMMachine
"(Automatic Teller Machine) A banking terminal that 
accepts deposits and dispenses cash. ATMs are activated by inserting a cash or 
credit card that contains the user's account number and PIN on a magnetic stripe. 
The ATM calls up the bank's computers to verify the balance, dispenses the cash 
and then transmits a completed transaction notice."}%
. instance(vService, CommercialService)
  /\ agent(vService, vAgent)
  /\ employs(vOrg, vAgent)
  /\ destination(vService, vCustomer) =>
      hasPurpose(vService,
                 True
                     when exists vTransaction: U
                              . instance(vTransaction, FinancialTransaction)
                                /\ destination(vTransaction, vOrg)
                                /\ origin(vTransaction, vCustomer)
                     else False)
. instance(customer, IrreflexiveRelation)
. instance(customer, BinaryPredicate)
. domain(customer, a_1, CognitiveAgent)
. domain(customer, a_2, CognitiveAgent)
%{customer
"A very general relation that exists whenever there
is a &%FinancialTransaction between the two &%Agents such that the first is
the &%destination of the &%FinancialTransaction and the second is the
&%agent."}%
. customer(vAgent1, vAgent2) <=>
      (exists vService: U
           . instance(vService, FinancialTransaction)
             /\ agent(vService, vAgent2)
             /\ destination(vService, vAgent1))
. accountHolder(vAccount, vAgent) /\ accountAt(vAccount, vBank) =>
      customer(vAgent, vBank)
. instance(customerRepresentative, TernaryPredicate)
. domain(customerRepresentative, a_1, CognitiveAgent)
. domain(customerRepresentative, a_2, CognitiveAgent)
. domain(customerRepresentative, a_3, Organization)
%{customerRepresentative
"(&%customerRepresentative 
?PERSON1 ?PERSON2 ?ORG) means that ?PERSON1 acts as a representative 
of &%Organization ?ORG in a &%SocialInteraction involving ?PERSON2."}%
. customerRepresentative(vPerson1, vPerson2, vOrg) <=>
      (exists vService: U
           . instance(vService, FinancialTransaction)
             /\ employs(vOrg, vPerson1)
             /\ agent(vService, vPerson1)
             /\ destination(vService, vPerson2))
. instance(Manager, Position)
%{Manager
"One who directs a business or other enterprise."}%
. subclass(ATMSlot, Hole)
%{ATMSlot
"A narrow opening in an ATM machine where cards are inserted."}%
. instance(vSlot, ATMSlot) =>
      exists vATM: U . instance(vATM, ATMMachine) /\ hole(vSlot, vATM)
. instance(vSlot, ATMSlot) =>
      exists vInsert: U; vCard: U
          . instance(vInsert, Putting)
            /\ patient(vInsert, vCard)
            /\ instance(vCard, BankCard)
            /\ destination(vInsert, vSlot)
. subrelation(postalCode, BinaryPredicate)
. domain(postalCode, a_1, SymbolicString)
. domain(postalCode, a_1, Address)
. instance(phoneNumber, BinaryPredicate)
. subrelation(phoneNumber, refers)
. domain(phoneNumber, a_1, SymbolicString)
. domain(phoneNumber, a_2, Telephone)
%{phoneNumber
"(&%phoneNumber ?Phone ?Agent) holds if ?Phone is 
a phone number corresponding to the Telephone ?Phone."}%
. instance(dayPhone, BinaryPredicate)
. domain(dayPhone, a_1, SymbolicString)
. domain(dayPhone, a_2, Agent)
%{dayPhone
"(&%dayPhone ?Phone ?Agent) means that ?Phone is a phone 
number corresponding to the location where ?Agent can be reached during the day."}%
. dayPhone(vNumber, vAgent) /\ instance(vDay, Day) =>
      exists vPhone: U
          . phoneNumber(vNumber, vPhone)
            /\ holdsDuring(HourFn(vNumber, vDay), possesses(vAgent, vPhone))
            /\ lessThan(vNumber, a_1_8)
. instance(eveningPhone, BinaryPredicate)
. domain(eveningPhone, a_1, SymbolicString)
. domain(eveningPhone, a_2, Agent)
%{eveningPhone
"(&%eveningPhone ?Phone ?Agent) means that ?Phone 
is a phone number corresponidng to the location where ?Agent can be reached 
during the evening."}%
. eveningPhone(vNumber, vAgent) /\ instance(vDay, Day) =>
      exists vPhone: U
          . phoneNumber(vNumber, vPhone)
            /\ holdsDuring(HourFn(vNumber, vDay), possesses(vAgent, vPhone))
            /\ greaterThan(vNumber, a_1_8)
. instance(emailAddress, BinaryPredicate)
. subrelation(emailAddress, refers)
. domain(emailAddress, a_1, SymbolicString)
. domain(emailAddress, a_2, Agent)
%{emailAddress
"(&%emailAddress ?Address ?Agent) means that ?Address is 
an electronic address of the location where ?Agent can be reached."}%
. subclass(Fax, Communication)
%{Fax
"The communication of a printed page between remote locations."}%
. instance(vFax, Fax) =>
      exists vFaxMachine: U
          . instance(vFaxMachine, FaxMachine)
            /\ instrument(vFax, vFaxMachine)
. subclass(FaxMachine, Device)
%{FaxMachine
"Fax machines scan a paper form and transmit a coded 
image over the telephone system. The receiving machine prints a facsimile of 
the original. A fax machine is made up of a scanner, printer and modem with 
fax signaling."}%
. subrelation(firstName, names)
. domain(firstName, a_1, Agent)
. domain(firstName, a_2, SymbolicString)
. instance(firstName, BinaryPredicate)
. instance(firstName, AsymmetricRelation)
%{firstName
"(firstName ?Agent ?Name) holds if ?Name is a given 
name or the name that occurs first in a given name."}%
. subrelation(availableBalance, currentAccountBalance)
. domain(availableBalance, a_1, FinancialAccount)
. domain(availableBalance, a_2, Day)
. domain(availableBalance, a_3, CurrencyMeasure)
%{availableBalance
"(&%availableBalance ?Account ?Day ?Amount) means 
that ?Amount is the balance which is available for withdrawal from the &%FinancialAccount 
?Account."}%
. (exists vTransaction: U
       . instance(vTransaction, FinancialTransaction)
         /\ origin(vTransaction, CurrencyFn(vAccount))
         /\ transactionAmount(vTransaction, vAmount)
         /\ date(vTransaction, vDay)) =>
      exists vAmount2: U
          . availableBalance(vAccount, vDay, vAmount2)
            /\ greaterThanOrEqualTo(vAmount1, vAmount2)
. subrelation(availableCash, availableBalance)
. domain(availableCash, a_1, FinancialAccount)
. domain(availableCash, a_2, Day)
. domain(availableCash, a_3, CurrencyMeasure)
%{availableCash
"(&%availableCash ?Account ?Day ?Cash) holds if 
?Cash is a cash amount available for withdrawal from the &%FinancialAccount 
?Account."}%
. (exists vTransaction: U
       . instance(vTransaction, FinancialTransaction)
         /\ origin(vTransaction, CurrencyFn(vAccount))
         /\ transactionAmount(vTransaction, vAmount)
         /\ instance(vCash, Cash)
         /\ instrument(vTransaction, vCash)
         /\ date(vTransaction, vDay)) =>
      exists vAmount2: U
          . availableCash(vAccount, vDay, vAmount2)
            /\ greaterThanOrEqualTo(vAmount1, vAmount2)
. instance(paymentsPerPeriod, TernaryPredicate)
. domain(paymentsPerPeriod, a_1, FinancialAccount)
. domain(paymentsPerPeriod, a_2, CurrencyMeasure)
. domain(paymentsPerPeriod, a_3, TimeInterval)
%{paymentsPerPeriod
"(&%paymentsPerPeriod ?Account ?Amount ?Period) 
holds if ?Amount is the amount paid on the FinancialAccount ?Account during the 
time period ?Period."}%
. instance(purchasesPerPeriod, TernaryPredicate)
. domain(purchasesPerPeriod, a_1, FinancialAccount)
. domain(purchasesPerPeriod, a_2, CurrencyMeasure)
. domain(purchasesPerPeriod, a_3, TimeInterval)
%{purchasesPerPeriod
"(&%purchasesPerPeriod ?Account ?Amount ?Period) 
holds if ?Amount is the amount of purchases added to the FinancialAccount ?Account 
during the time period ?Period."}%
. instance(creditsPerPeriod, TernaryPredicate)
. domain(creditsPerPeriod, a_1, FinancialAccount)
. domain(creditsPerPeriod, a_2, CurrencyMeasure)
. domain(creditsPerPeriod, a_3, TimeInterval)
%{creditsPerPeriod
"(&%creditsPerPeriod ?Account ?Amount ?Period) 
holds if ?Amount is the amount credited to the FinancialAccount ?Account during 
the time period ?Period."}%
. instance(confirmationNumber, BinaryPredicate)
. instance(confirmationNumber, AsymmetricRelation)
. domain(confirmationNumber, a_1, FinancialTransaction)
. domain(confirmationNumber, a_2, SymbolicString)
. subclass(BankStatement, Proposition)
%{BankStatement
"A monthly report sent to a debtor or bank depositor."}%
. instance(vStatement, BankStatement)
  /\ statementAccount(vStatement, vAccount) =>
      exists vTransaction: U
          . instance(vTransaction, FinancialTransaction)
            /\ (origin(vTransaction, CurrencyFn(vAccount))
                \/ destination(vTransaction, CurrencyFn(vAccount)))
            /\ realization(vStatement, vTransaction)
. instance(lastStatement, BinaryPredicate)
. domain(lastStatement, a_1, FinancialAccount)
. domain(lastStatement, a_2, BankStatement)
%{lastStatement
"(&%lastStatement ?Account ?Statement) means that 
?Statement is the most recent monthly report sent to a debtor or bank depositor."}%
. lastStatement(vAccount, vStatement)
  /\ instance(vTransaction1, FinancialTransaction)
  /\ realization(vStatement, vTransaction1)
  /\ instance(vTransaction2, FinancialTransaction)
  /\ not realization(vStatement, vTransaction2) =>
      earlier(WhenFn(vTransaction2), WhenFn(vTransaction1))
. instance(loanInterest, BinaryPredicate)
. domain(loanInterest, a_1, Loan)
. domain(loanInterest, a_2, CurrencyMeasure)
. (exists vPeriod: U
       . instance(vLoan, Loan)
         /\ agreementPeriod(vLoan, vPeriod)
         /\ interestEarned(vLoan, vAmount, vPeriod)) <=>
      loanInterest(vLoan, vAmount)
. subclass(Title, FinancialInstrument)
%{Title
"The instrument, such as a deed, that constitutes evidence 
of a legal right of possession or control."}%
. instance(vTitle, Title) =>
      exists vProperty: U; vAgent: U
          . containsInformation(vTitle, possesses(vAgent, vProperty))
. instance(bankAccount, BinaryPredicate)
. instance(bankAccount, AsymmetricRelation)
. domainSubclass(bankAccount, a_1, FinancialAccount)
. domain(bankAccount, a_2,
         a_B_a_n_k_Minus_F_i_n_a_n_c_i_a_l_O_r_g_a_n_i_z_a_t_i_o_n)
%{bankAccount
"(&%bankAccount ?Type ?Bank) holds if ?Type is a 
type of the financial accounts offered by the bank."}%
. bankAccount(vAccountType, vBank) <=>
      (exists vAccount: U
           . instance(vAccount, vAccountType) /\ accountAt(vAccount, vBank))
. subclass(ServiceAttribute, Attribute)
%{ServiceAttribute
"The class of attributes which describe 
&%CommercialServices, such as &%OpenService and &%ClosedService."}%
. instance(OpenService, ServiceAttribute)
. contraryAttribute(OpenService, ClosedService)
%{OpenService
"The attribute which describes services that 
are ready to transact business."}%
. (exists vTransaction: U
       . instance(vTransaction, FinancialTransaction)
         /\ destination(vTransaction, vAgent)) =>
      instance(vService, CommercialService)
      /\ agent(vService, vAgent)
      /\ attribute(vService, OpenService)
. instance(ClosedService, ServiceAttribute)
%{ClosedService
"The attribute which describes services that are 
shut or closed."}%
. instance(Receipt, FinancialInstrument)
%{Receipt
"A written acknowledgment that a specified article, 
sum of money, or shipment of merchandise has been received."}%
. subclass(FinancialRequest, FinancialTransaction)
%{FinancialRequest
"A request for financial data sent in order
to get a &%FinancialResponse."}%
. subclass(FinancialResponse, FinancialTransaction)
%{FinancialResponse
"The response data provided to fulfil a &%FinancialRequest."}%
. instance(financialResponseTo, BinaryPredicate)
. domain(financialResponseTo, a_1, FinancialResponse)
. domain(financialResponseTo, a_2, FinancialRequest)
%{financialResponseTo
"(&%financialResponseTo ?Response ?Request) means that 
?Response is a &%FinancialResponse to the &%FinancialRequest ?Request."}%
. instance(dailyLimit, TernaryPredicate)
. domain(dailyLimit, a_1, FinancialAccount)
. domainSubclass(dailyLimit, a_2, FinancialTransaction)
. domain(dailyLimit, a_3, CurrencyMeasure)
%{dailyLimit
"(&%dailyLimit ?Account ?TransactionType ?Amount) 
means that ?Amount is the daily limit of the ?Account for the type of 
&%FinancialTransactions ?TransactionType."}%
. instance(accountStatus, BinaryPredicate)
. domain(accountStatus, a_1, FinancialAccount)
. domain(accountStatus, a_2, StatusAttribute)
%{accountStatus
"(&%accountStatus ?Account ?Status) holds if 
?Status describes the status of the account, such as &%Active, &%Locked, 
&%New or &%Pending."}%
. subclass(StatusAttribute, Attribute)
%{StatusAttribute
"A class of four &%Attributes indicating the 
status of a &%FinancialAccount, viz. &%Active, &%Locked, &%New, and &%Pending."}%
. instance(New, StatusAttribute)
. instance(Active, StatusAttribute)
. instance(Locked, StatusAttribute)
. instance(Pending, StatusAttribute)
. instance(administrator, BinaryPredicate)
. domain(administrator, a_1, FinancialAccount)
. domain(administrator, a_2, Position)
. instance(administratorStatus, BinaryPredicate)
. domain(administratorStatus, a_1, Position)
. domain(administratorStatus, a_2, StatusAttribute)
%{administratorStatus
"(&%administratorStatus ?Administrator ?Status) 
holds is ?Status describes the status of the administrator."}%
. instance(dateOfStatement, BinaryPredicate)
. domain(dateOfStatement, a_1, BankStatement)
. domain(dateOfStatement, a_2, Day)
%{dateOfStatement
"(&%dateOfStatement ?Statement ?Date) holds if 
?Date is the date when BankStatement was issued."}%
. dateOfStatement(vStatement, vDate) =>
      exists vCopy: U
          . containsInformation(vCopy, vStatement) /\ date(vCopy, vDate)
. instance(lastStatementBalance, BinaryPredicate)
. domain(lastStatementBalance, a_1, FinancialAccount)
. domain(lastStatementBalance, a_2, CurrencyMeasure)
%{lastStatementBalance
"(&%lastStatementBalance ?Account ?Amount) 
holds if ?Amount is the balance shown on the last statement."}%
. lastStatementBalance(vAccount, vBalance) =>
      exists vStatement: U
          . lastStatement(vAccount, vStatement)
            /\ dateOfStatement(vStatement, vDate)
            /\ currentAccountBalance(vAccount, vDate, vAccount)
. instance(statementAccount, BinaryPredicate)
. domain(statementAccount, a_1, BankStatement)
. domain(statementAccount, a_2, FinancialAccount)
%{statementAccount
"(&%statementAccount ?Statement ?Account) means 
that ?Account is the account of the BankStatement ?Statement."}%
. instance(statementPeriod, BinaryPredicate)
. domain(statementPeriod, a_1, BankStatement)
. domain(statementPeriod, a_2, TimeInterval)
%{statementPeriod
"(&%statementPeriod ?Statement ?Period) means that 
?Period is the time period of the BankStatement ?Statement."}%
. statementPeriod(vStatement, vPeriod)
  /\ duration(vPeriod, vDuration) =>
      vDuration = MonthDuration
. statementPeriod(vStatement, vPeriod)
  /\ dateOfStatement(vStatement, vDate) =>
      finishes(vDate, vPeriod)
. instance(statementInterest, BinaryPredicate)
. domain(statementInterest, a_1, BankStatement)
. domain(statementInterest, a_2, CurrencyMeasure)
%{statementInterest
"(&%statementInterest ?Statement ?Amount) holds 
if ?Amount is the interest amount as shown on the BankStatement ?Statement."}%
. statementInterest(vStatement, vInterest)
  /\ statementPeriod(vStatement, vPeriod)
  /\ statementAccount(vStatement, vAccount) =>
      exists vAmount: U . interestEarned(vAccount, vAmount, vPeriod)
. instance(buyingPowerAmount, TernaryPredicate)
. subrelation(buyingPowerAmount, availableBalance)
. domain(buyingPowerAmount, a_1, FinancialAccount)
. domain(buyingPowerAmount, a_2, Day)
. domain(buyingPowerAmount, a_3, CurrencyMeasure)
%{buyingPowerAmount
"(&%buyingPowerAmount ?Account ?Day ?Amount) holds 
if ?Amount is the buying power amount of the &%FinancialAccount ?Account on the &%Day 
?Day."}%
. instance(marginBalanceAmount, TernaryPredicate)
. subrelation(marginBalanceAmount, availableBalance)
. domain(marginBalanceAmount, a_1, FinancialAccount)
. domain(marginBalanceAmount, a_2, Day)
. domain(marginBalanceAmount, a_3, CurrencyMeasure)
%{marginBalanceAmount
"(&%marginBalanceAmount ?Account ?Day ?Amount) 
holds if ?Amount is the margin balance amount of the &%FinancialAccount ?Account 
on the &%Day ?Day."}%
. instance(shortBalanceAmount, TernaryPredicate)
. subrelation(shortBalanceAmount, availableBalance)
. domain(shortBalanceAmount, a_1, FinancialAccount)
. domain(shortBalanceAmount, a_2, Day)
. domain(shortBalanceAmount, a_3, CurrencyMeasure)
%{shortBalanceAmount
"(&%shortBalanceAmount ?Account ?Day ?Amount) 
holds if ?Amount is the short balance amount of the &%FinancialAccount ?Account 
on the &%Day ?Day."}%
. instance(marketValueAmount, TernaryPredicate)
. subrelation(marketValueAmount, availableBalance)
. domain(marketValueAmount, a_1, FinancialAccount)
. domain(marketValueAmount, a_2, Day)
. domain(marketValueAmount, a_3, CurrencyMeasure)
%{shortBalanceAmount
"(&%marketvalueAmount ?Account ?Day ?Amount) holds 
if ?Amount is the market value amount of the &%FinancialAccount ?Account on the &%Day 
?Day."}%
. subclass(ExternalTransfer, FinancialTransaction)
%{ExternalTransfer
"A subclass of &%FinancialTransactions from one 
&%FinancialOrganization to another."}%
. instance(vTransfer, ExternalTransfer)
  /\ origin(vTransfer, vOrganization1)
  /\ instance(vOrganization1, FinancialOrganization)
  /\ destination(vTransfer, vOrganization2)
  /\ instance(vOrganization2, FinancialOrganization) =>
      not vOrganization1 = vOrganization2
. subclass(InternalTransfer, FinancialTransaction)
. disjoint(InternalTransfer, ExternalTransfer)
%{InternalTransfer
"A subclass of &%FinancialTransactions within 
one &%FinancialOrganization."}%
. instance(vTransfer, ExternalTransfer)
  /\ origin(vTransfer, vOrganization1)
  /\ instance(vOrganization1, FinancialOrganization)
  /\ destination(vTransfer, vorganization2)
  /\ instance(vOrganization2, FinancialOrganization) =>
      vOrganization1 = vOrganization2
. subclass(Update, FinancialTransaction)
. subclass(Update, ContentDevelopment)
%{Update
"To change data in a file or database"}%
. instance(loanFeeAmount, BinaryPredicate)
. domain(loanFeeAmount, a_1, Loan)
. domain(loanFeeAmount, a_2, CurrencyMeasure)
%{loanFeeAmount
"(&%loanFeeAmount ?Loan ?Amount) means that 
?Amount is the fee amount of the Loan ?Loan."}%
. loanFeeAmount(vLoan, vAmount)
  /\ agreementPeriod(vLoan, vPeriod) =>
      interestEarned(vLoan, vAmount, vPeriod)

library RCC_FO
version 0.1 
%author: S. Wölfl, T. Mossakowski
%date: 10-08-04
%% Region Connection Calculus -- First order theory
%% Bennett's version of RCC_FirstOrder from PhD thesis (1997) %%


spec Sig_RCC_FirstOrder

     = 

     sort Reg

     preds 
	  __ C __: Reg * Reg;

     then %def

      preds
	  __ P __, __ Ov __, __ NTP __: Reg * Reg

     forall x,y: Reg
	  . x P y <=> (forall z:Reg .(z C x => z C y))		%(RCC_def_P)%
	  . x Ov y <=> (exists z:Reg .(z C z /\ z P x /\ z P y)) %(RCC_def_O)%
	  . x NTP y <=> forall z:Reg .(z C x => z Ov y)		%(RCC_def_NTP)%
end	  


spec RCC_FirstOrder 

     = 

     Sig_RCC_FirstOrder 
     
     then 
     
    	forall x,y: Reg
	  . x C y => x C x					%(RCC_C_non_null)%
	  . x C y => y C x					%(RCC_C_sym)%
	  . (forall z:Reg . z C x <=> z C y) => x = y     	%(RCC_C_identity)%
	  . exists z:Reg . (forall u:Reg . 
		(z C u <=> (not(u NTP x) \/ not(u NTP y))))	%(RCC_ex_sum)% 
	  . x C x => exists z:Reg . (z C z /\ z NTP x)
	  %(RCC_no_atoms)%		
     
      then %implies
	
	forall x,y,z: Reg  
	. x Ov y => y Ov x				%(RCC_thm_O_sym)%
	. x P y /\ x C x => x C y			%(RCC_thm_non_null_P_implies_C)%
	. (exists y:Reg. x C y) => x C x		%(RCC_thm_help_1)%
	. (exists y:Reg. y C x) => x C x		%(RCC_thm_help_2)%
	.  x P y /\ (exists z:Reg. z C x) => x C y	%(RCC_thm_help_3)%
	. x P y /\ y P z => x P z			%(RCC_thm_P_trans)%
	. x P y /\ y P x => x = y			%(RCC_thm_P_extensionality)%

end


spec RCC_FirstOrder_Rel 

     = 

     %% Definitions of RCC-relations %% 

     RCC_FirstOrder

     then %def
 
     
	preds
	  __ PP __,  __ POv __,  __ EC __,  __ DC __, __ EQ __, 
	 __ TPP __, __ NTPP __,  __ DR __,  __ Pi __,
	 __ PPi __, __ TPPi __,  __ NTPPi __: Reg * Reg

	forall x,y:Reg 
        .   x PP y   <=>  (x P y /\ not (y P x))              	%(RCC_def_PP)%
        .   x POv y   <=>  (x Ov y /\ not (x P y) /\ not (y P x))	          
								%(RCC_def_PO)%
        .   x DC y   <=>  not (x C y)				%(RCC_def_DC)%   
        .   x DR y   <=>  not (x Ov y)				%(RCC_def_DR)%      	
	.   x EC y   <=>  (x C y /\ not (x Ov y))          	%(RCC_def_EC)%
	.  x TPP y   <=>  (x PP y /\ exists z:Reg.(z EC x /\ z EC y))     
								%(RCC_def_TPP)%
	. x NTPP y   <=>  (x PP y /\ forall z:Reg.(z EC x => not (z EC y))) 
								%(RCC_def_NTPP)%
        .    x Pi y  <=> y P x                                  %(RCC_def_Pi)%
        .   x PPi y  <=> y PP x                                 %(RCC_def_PPi)%
        .  x TPPi y  <=> y TPP x                                %(RCC_def_TPPi)%
        . x NTPPi y  <=> y NTPP x	                	%(RCC_def_NTPPi)%


     then %implies

	forall x,y,z: Reg  
	. x POv y => y POv x 				%(RCC_thm_PO_sym_PO)%
	. x DC y => y DC x 				%(RCC_thm_PO_sym_DC)%
	. x EC y => y EC x 				%(RCC_thm_PO_sym_EC)%
	. x DR y => y DR x 				%(RCC_thm_PO_sym_DR)%
	. x EQ y => y EQ x 				%(RCC_thm_PO_sym_EQ)%
	. x PP y => x P y				%(RCC_thm_PP_subset_P)%
	. x TPP y => x PP y				%(RCC_thm_TPP_subset_PP)%
	. x NTPP y => x PP y				%(RCC_thm_NTPP_subset_PP)%
	. x TPPi y => y PP x				%(RCC_thm_TPPi_subset_Inv_PP)% 
	. x NTPPi y => y PP x				%(RCC_thm_NTPPi_subset_Inv_PP)%
	. x PP y => not y P x				%(RCC_thm_PP_subset_Cpl_Inv_P)% 
	. x P y /\ z C x => z C y			%(RCC_lem_PC_1)%
	. x PP y => not x EC y				%(RCC_thm_PP_implies_not_EC)%
	. x PP y /\ x C x => not x DC y			%(RCC_thm_PP_and_NotNull_implies_not_DC)%
	. x Ov y => x C y				%(RCC_thm_O_subset_C)%
	. x = y /\ x C x => not x DC y			%(RCC_thm_EQ_and_NotNull_implies_not_DC)%
	. x = y /\ x C x => not x EC y			%(RCC_thm_EQ_and_NotNull_implies_not_EC)%
	. x = y /\ x C x => not x TPP y			%(RCC_thm_EQ_and_NotNull_implies_not_TPP)%

end


spec RCC_FirstOrder_RelFunc 

     = 

     %% Definitions of algebraic operations  %%

     RCC_FirstOrder_Rel

     then 
     
	ops
		cp: Reg * Reg -> Reg; 
	     compl: Reg -> Reg;   
               sum: Reg * Reg -> Reg;
              prod: Reg * Reg -> Reg;
                 0: Reg;
                 1: Reg

	forall x,y,z: Reg
	. cp(x,y) = z <=> (forall u:Reg . 
                    (u C z <=> (not(u NTP x) \/ not(u NTP y))))
	.  compl(x) = cp(x,x)
	.  sum(x,y) = cp(cp(x,x),cp(y,y))
	. prod(x,y) = cp(cp(x,y),cp(x,y))
	.         0 = prod(x,compl(x))
	.         1 = sum(x,compl(x))

	
end






















spec fv =
   NATURAL
then
   sort S ;
   sort S1, S2 < S3;		   %% Here < is a reserved word
   sort S0 < S3;

   pred __<__ : Nat*Nat; 	   %% here < is no longer reserved, but * is.
   op __ * __ : Nat * Nat -> Nat;  %% two * with different meanings.
      __*__: Seq*Seq->Seq;

   op <> : Seq';
      <__> : Nat -> Seq';
   op :->, :->>, :-<, :-| , :-<>, #/:->, &:-|, :>--<  : faces

%% the two next ones are incorrect since we cannot have two adjacent tokens
%%  :- and O or < and > without a placeholder between them.
%%
%%  op :-0 : faces ;
%%  op     < > : Seq 

%% Not yet handled:
%%   op :-[], :-{} : faces ;
%%   pred
%%   f __ ? : S ->? S;
%%     { } : List;
%%     {__} : S->Nat; 

   sort S' = { x : S . { x } = 1 } ;
   sort Biz = { x:S . x * y < x*z => x < y }

   sort iso1 = iso2 = iso3;

   op mult(x,y:Nat) : Nat = x*y;
   pred inf(x,y:Nat) <=> x < y;

   op f: Nat*Nat->Nat, comm, assoc, unit 0 * 0;
   op f: Nat*Nat->Nat, comm, assoc, unit 0 < 0;

%% devrait etre errone, puisque "to" est un mot reserve.
%% hide add__to__ 

reveal op __<__, __ < __ : Nat * Nat -> Nat, __ < __,
       op __*__, __ * __ : Nat * Nat -> Nat |-> __<__ : Nat* Nat -> Nat,
       pred __ < __ ,
       pred __<__, __ < __: Nat*Nat
end



spec correct_formulas =

sort N, S
preds F : () ;
      F2: N;
var x:N;
ops   p __, __ r, __ r2 : N -> N ;
      q : N ;
      __ __ : N*N -> N;

axioms
     p(x) q as S when F else x r ;

     p (x) q : S when F else r if F2 (x) ;

%%   syntax error since "r if F2(x)" is a formula, not a term.
%%   p (x) q : S when F else (r if F2 (x)) ;

     (p (x) q : S when F else r) if F2 (x) ;

     p (x) q when F else x r when F2 else x r2 ;

     p x when F if F2 else x r ;

%% Bremen parser does not seem to like any of these:
     p when F else r: S ;
     p when F else (r: S) ;
     (p when F else r) : S ;
end

